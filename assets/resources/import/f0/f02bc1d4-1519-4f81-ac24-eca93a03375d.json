[1,0,0,[["cc.EffectAsset",["_name","shaders","techniques"],0]],[[0,0,1,2,4]],[[0,"../resources/Exported/__builtin__/custom-deferred-combine-lut",[{"hash":3936280978,"name":"../resources/Exported/__builtin__/custom-deferred-combine-lut|vs|fs","blocks":[{"name":"SyncCombineLut","stageFlags":16,"binding":0,"members":[{"name":"sync_CombineLutParam1","type":16,"count":1}],"defines":[]}],"samplerTextures":[],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[],"attributes":[{"name":"a_position","format":32,"location":0,"defines":[]},{"name":"a_normal","format":32,"location":1,"defines":[]},{"name":"a_texCoord","format":21,"location":2,"defines":[]},{"name":"a_tangent","format":44,"location":3,"defines":[]},{"name":"a_vertexId","format":11,"location":6,"defines":["CC_USE_MORPH"]},{"name":"a_joints","location":4,"defines":["CC_USE_SKINNING"]},{"name":"a_weights","format":44,"location":5,"defines":["CC_USE_SKINNING"]},{"name":"a_jointAnimInfo","format":44,"isInstanced":true,"location":7,"defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION","USE_INSTANCING"]}],"varyings":[{"name":"v_uv","type":14,"count":1,"stageFlags":17,"location":0,"defines":[]}],"fragColors":[{"name":"fragColor","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":0,"defines":[]}],"glsl4":{"vert":"#extension GL_EXT_shader_explicit_arithmetic_types_int32: require\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec3 a_normal;\nlayout(location = 2) in vec2 a_texCoord;\nlayout(location = 3) in vec4 a_tangent;\n#if CC_USE_MORPH\n    int getVertexId() {\n      return gl_VertexIndex;\n    }\n  layout(set = 2, binding = 4) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n  };\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n        ivec2 texSize = textureSize(tex, 0);\n        return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture(tex, x)),\n        decode32(texture(tex, y)),\n        decode32(texture(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    layout(set = 2, binding = 7) uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    layout(set = 2, binding = 8) uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    layout(set = 2, binding = 9) uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout StandardVertInput attr) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    attr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    attr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    attr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n    layout(location = 4) in u32vec4 a_joints;\n  layout(location = 5) in vec4 a_weights;\n  #if CC_USE_BAKED_ANIMATION\n    #if USE_INSTANCING\n      layout(location = 7) in highp vec4 a_jointAnimInfo;\n    #endif\n    layout(set = 2, binding = 3) uniform CCSkinningTexture {\n      highp vec4 cc_jointTextureInfo;\n    };\n    layout(set = 2, binding = 2) uniform CCSkinningAnimation {\n      highp vec4 cc_jointAnimInfo;\n    };\n    layout(set = 2, binding = 6) uniform highp sampler2D cc_jointTexture;\n      #else\n    layout(set = 2, binding = 3) uniform CCSkinning {\n      highp vec4 cc_joints[30 * 3];\n    };\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout StandardVertInput attr) {\n    mat4 m = skinMatrix();\n    attr.position = m * attr.position;\n    attr.normal = (m * vec4(attr.normal, 0.0)).xyz;\n    attr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n  }\n#endif\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nlayout(location = 0) out vec2 v_uv;\nvoid main () {\n  StandardVertInput In;\n      In.position = vec4(a_position, 1.0);\n      In.normal = a_normal;\n      In.tangent = a_tangent;\n    #if CC_USE_MORPH\n      applyMorph(In);\n    #endif\n    #if CC_USE_SKINNING\n      CCSkin(In);\n    #endif\n  gl_Position = In.position;\n  v_uv = a_texCoord;\n}","frag":"\n  precision highp float;\n  layout(set = 0, binding = 0) uniform CCGlobal {\n    highp   vec4 cc_time;\n    mediump vec4 cc_screenSize;\n    mediump vec4 cc_nativeSize;\n  };\n  layout(set = 0, binding = 1) uniform CCCamera {\n    highp   mat4 cc_matView;\n    highp   mat4 cc_matViewInv;\n    highp   mat4 cc_matProj;\n    highp   mat4 cc_matProjInv;\n    highp   mat4 cc_matViewProj;\n    highp   mat4 cc_matViewProjInv;\n    highp   vec4 cc_cameraPos;\n    mediump vec4 cc_screenScale;\n    mediump vec4 cc_exposure;\n    mediump vec4 cc_mainLitDir;\n    mediump vec4 cc_mainLitColor;\n    mediump vec4 cc_ambientSky;\n    mediump vec4 cc_ambientGround;\n    mediump vec4 cc_fogColor;\n    mediump vec4 cc_fogBase;\n    mediump vec4 cc_fogAdd;\n    mediump vec4 cc_nearFar;\n    mediump vec4 cc_viewPort;\n  };\nfloat Square(float v)\n{\n    return v * v;\n}\nfloat log10(float n)\n{\n    const float kLogBase10 = 1.0 / log2(10.0);\n    return log2(n) * kLogBase10;\n}\nvec2 log10(vec2 n)\n{\n    return vec2(log10(n.x), log10(n.y));\n}\nvec3 log10(vec3 n)\n{\n    return vec3(log10(n.x), log10(n.y), log10(n.z));\n}\nstruct Light {\n  vec3 color;\n  vec3 direction;\n};\nstruct FDirectLighting\n{\n  vec3 Diffuse;\n  vec3 Specular;\n};\nstruct FPixelMaterialInputs\n{\n  vec3 Normal;\n  vec3 EmissiveColor;\n  float Opacity;\n  float OpacityMask;\n  vec3 BaseColor;\n  float Metallic;\n  float Specular;\n  float Roughness;\n  float AmbientOcclusion;\n  float Anisotropy;\n  float Tangent;\n  float Refraction;\n  float PixelDepthOffset;\n  float ShadingModel;\n  float TwoSidedSign;\n  float RoughnessWithClamp;\n  vec3 DiffuseColor;\n  vec3 SpecularColor;\n  vec3 Subsurface;\n};\nstruct FMaterialPixelParameters {\n  float IndirectIrradiance;\n  vec2 TexCoords_0;\n  vec2 TexCoords_1;\n  vec4 VertexColor;\n  vec3 WorldNormal;\n  vec3 WorldTangent;\n  vec3 ReflectionVector;\n  vec3 CameraVector;\n  vec3 LightVector;\n  vec4 SvPosition;\n  vec4 ScreenPosition;\n  mat3 TangentToWorld;\n  vec3 AbsoluteWorldPosition;\n  vec3 ObjectWorldPosition;\n  vec2 LightmapUVs;\n  int PrimitiveId;\n};\nstruct FMaterialVertexParameters {\n  vec3 WorldPosition;\n  vec4 VertexColor;\n};\n vec4 F4_0101 = vec4(0, 1, 0, 1);\n mat3 AP0_2_XYZ_MAT = mat3(0.952552,0.343966,0.000000,0.000000,0.728166,0.000000,0.000094,(-0.072133),1.008825);\n mat3 XYZ_2_AP0_MAT = mat3(1.049811,(-0.495903),0.000000,0.000000,1.373313,0.000000,(-0.000097),0.098240,0.991252);\n mat3 AP1_2_XYZ_MAT = mat3(0.662454,0.272229,(-0.005575),0.134004,0.674082,0.004061,0.156188,0.053690,1.010339);\n mat3 XYZ_2_AP1_MAT = mat3(1.641023,(-0.663663),0.011722,(-0.324803),1.615332,(-0.008284),(-0.236425),0.016756,0.988395);\n mat3 AP0_2_AP1_MAT = mat3(1.451439,(-0.076554),0.008316,(-0.236511),1.176230,(-0.006032),(-0.214929),(-0.099676),0.997716);\n mat3 AP1_2_AP0_MAT = mat3(0.695452,0.044795,(-0.005526),0.140679,0.859671,0.004025,0.163869,0.095534,1.001501);\n vec3 AP1_RGB2Y = vec3(0.272229, 0.674082, 0.053690);\n mat3 XYZ_2_sRGB_MAT = mat3(3.240970,(-0.969244),0.055630,(-1.537383),1.875968,(-0.203977),(-0.498611),0.041555,1.056972);\n mat3 sRGB_2_XYZ_MAT = mat3(0.412456,0.212673,0.019334,0.357576,0.715152,0.119192,0.180438,0.072175,0.950304);\n mat3 XYZ_2_Rec2020_MAT = mat3(1.716608,(-0.666683),0.017642,(-0.355662),1.616478,(-0.042776),(-0.253360),0.015769,0.942229);\n mat3 Rec2020_2_XYZ_MAT = mat3(0.636974,0.262707,0.000000,0.144617,0.678000,0.028073,0.168858,0.059294,1.060844);\n mat3 XYZ_2_P3D65_MAT = mat3(2.493396,(-0.829487),0.035851,(-0.931346),1.762660,(-0.076183),(-0.402694),0.023625,0.957014);\n mat3 P3D65_2_XYZ_MAT = mat3(0.486591,0.228984,0.000000,0.265668,0.691740,0.045114,0.198190,0.079276,1.043803);\n mat3 D65_2_D60_CAT = mat3(1.013030,0.007698,(-0.002841),0.006105,0.998165,0.004685,(-0.014971),(-0.005032),0.924507);\n mat3 D60_2_D65_CAT = mat3(0.987224,(-0.007598),0.003073,(-0.006113),1.001860,(-0.005096),0.015953,0.005330,1.081680);\n float HALF_MAX = 65504.000000;\nfloat rgb_2_saturation(vec3 rgb) {\n    float minrgb = min(min((rgb).r, (rgb).g), (rgb).b);\n    float maxrgb = max(max((rgb).r, (rgb).g), (rgb).b);\n    return ((max(maxrgb, 0.000000) - max(minrgb, 0.000000)) / max(maxrgb, 0.010000));\n}\nfloat glow_fwd(float ycIn, float glowGainIn, float glowMid) {\n    float glowGainOut;\n    if ((ycIn <= ((2.000000 / 3.000000) * glowMid))) {\n        (glowGainOut = glowGainIn);\n    }\n    else {\n        if ((ycIn >= (2.000000 * glowMid))) {\n            (glowGainOut = 0.000000);\n        }\n        else {\n            (glowGainOut = (glowGainIn * ((glowMid / ycIn) - 0.500000)));\n        }\n    }\n    return glowGainOut;\n}\nfloat sigmoid_shaper(float x) {\n    float t = max((float (1) - abs((0.500000 * x))), float (0));\n    float y = (float (1) + (sign(x) * (float (1) - (t * t))));\n    return (0.500000 * y);\n}\nfloat center_hue(float hue, float centerH) {\n    float hueCentered = (hue - centerH);\n    if ((hueCentered < (-180.000000))) {\n        (hueCentered += float (360));\n    }\n    else {\n        if ((hueCentered > 180.000000)) {\n            (hueCentered -= float (360));\n        }\n    }\n    return hueCentered;\n}\nfloat rgb_2_hue(vec3 rgb) {\n    float hue;\n    if (((rgb[0] == rgb[1]) && (rgb[1] == rgb[2]))) {\n        (hue = float (0));\n    }\n    else {\n        (hue = ((180.000000 / 3.14159265359) * atan((sqrt(3.000000) * (rgb[1] - rgb[2])), (((2.000000 * rgb[0]) - rgb[1]) - rgb[2]))));\n    }\n    if ((hue < 0.000000)) {\n        (hue = (hue + 360.000000));\n    }\n    return clamp(hue, 0.000000, 360.000000);\n}\nfloat rgb_2_yc(vec3 rgb, float ycRadiusWeight) {\n    float r = rgb[0];\n    float g = rgb[1];\n    float b = rgb[2];\n    float chroma = sqrt((((b * (b - g)) + (g * (g - r))) + (r * (r - b))));\n    return ((((b + g) + r) + (ycRadiusWeight * chroma)) / 3.000000);\n}\nvec3 xyY_2_XYZ(vec3 xyY) {\n    vec3 XYZ;\n    (XYZ[0] = ((xyY[0] * xyY[2]) / max(xyY[1], 0.000000)));\n    (XYZ[1] = xyY[2]);\n    (XYZ[2] = ((((1.000000 - xyY[0]) - xyY[1]) * xyY[2]) / max(xyY[1], 0.000000)));\n    return XYZ;\n}\n mat3 ConeResponse = mat3(0.895100,(-0.750200),0.038900,0.266400,1.713500,(-0.068500),(-0.161400),0.036700,1.029600);\n mat3 InvConeResponse = mat3(0.986993,0.432305,(-0.008529),(-0.147054),0.518360,0.040043,0.159963,0.049291,0.968487);\nmat3 ChromaticAdaptation(vec2 src_xy, vec2 dst_xy) {\n    vec3 src_XYZ = xyY_2_XYZ(vec3(src_xy, 1));\n    vec3 dst_XYZ = xyY_2_XYZ(vec3(dst_xy, 1));\n    vec3 src_coneResp = (ConeResponse * src_XYZ);\n    vec3 dst_coneResp = (ConeResponse * dst_XYZ);\n    mat3 VonKriesMat = mat3(((dst_coneResp).x / (src_coneResp).x),0.000000,0.000000,0.000000,((dst_coneResp).y / (src_coneResp).y),0.000000,0.000000,0.000000,((dst_coneResp).z / (src_coneResp).z));\n    return (InvConeResponse * (VonKriesMat * ConeResponse));\n}\n float FilmSlope = 0.880000;\n float FilmToe = 0.550000;\n float FilmShoulder = 0.260000;\n float FilmBlackClip = float (0);\n float FilmWhiteClip = 0.040000;\nvec3 FilmToneMap(vec3 LinearColor) {\n    mat3 sRGB_2_AP0 = (XYZ_2_AP0_MAT * (D65_2_D60_CAT * sRGB_2_XYZ_MAT));\n    mat3 sRGB_2_AP1 = (XYZ_2_AP1_MAT * (D65_2_D60_CAT * sRGB_2_XYZ_MAT));\n    mat3 AP0_2_sRGB = (XYZ_2_sRGB_MAT * (D60_2_D65_CAT * AP0_2_XYZ_MAT));\n    mat3 AP1_2_sRGB = (XYZ_2_sRGB_MAT * (D60_2_D65_CAT * AP1_2_XYZ_MAT));\n    mat3 AP0_2_AP1 = (XYZ_2_AP1_MAT * AP0_2_XYZ_MAT);\n    mat3 AP1_2_AP0 = (XYZ_2_AP0_MAT * AP1_2_XYZ_MAT);\n    vec3 ColorAP1 = vec3 (LinearColor);\n    vec3 ColorAP0 = (AP1_2_AP0 * ColorAP1);\n    float RRT_GLOW_GAIN = 0.050000;\n    float RRT_GLOW_MID = 0.080000;\n    float saturation = rgb_2_saturation(ColorAP0);\n    float ycIn = rgb_2_yc(ColorAP0, 1.750000);\n    float s = sigmoid_shaper(((saturation - 0.400000) / 0.200000));\n    float addedGlow = (float (1) + glow_fwd(ycIn, (RRT_GLOW_GAIN * s), RRT_GLOW_MID));\n    (ColorAP0 *= vec3 (addedGlow));\n    float RRT_RED_SCALE = 0.820000;\n    float RRT_RED_PIVOT = 0.030000;\n    float RRT_RED_HUE = float (0);\n    float RRT_RED_WIDTH = float (135);\n    float hue = rgb_2_hue(ColorAP0);\n    float centeredHue = center_hue(hue, RRT_RED_HUE);\n    float hueWeight = Square(smoothstep(0.000000, 1.000000, (1.000000 - abs(((2.000000 * centeredHue) / RRT_RED_WIDTH)))));\n    ((ColorAP0).r += (((hueWeight * saturation) * (RRT_RED_PIVOT - (ColorAP0).r)) * (1.000000 - RRT_RED_SCALE)));\n    vec3 WorkingColor = (AP0_2_AP1_MAT * ColorAP0);\n    (WorkingColor = max(vec3 (0.000000), WorkingColor));\n    (WorkingColor = vec3 (mix(vec3 (dot(WorkingColor, AP1_RGB2Y)), vec3 (WorkingColor), vec3 (0.960000))));\n    float ToeScale = float (((1.000000 + FilmBlackClip) - FilmToe));\n    float ShoulderScale = float (((1.000000 + FilmWhiteClip) - FilmShoulder));\n    float InMatch = 0.180000;\n    float OutMatch = 0.180000;\n    float ToeMatch;\n    if ((FilmToe > 0.800000)) {\n        (ToeMatch = ((((float (1) - FilmToe) - OutMatch) / FilmSlope) + log10(InMatch)));\n    }\n    else {\n        float bt = (((OutMatch + FilmBlackClip) / ToeScale) - float (1));\n        (ToeMatch = (log10(InMatch) - ((0.500000 * log(((float (1) + bt) / (float (1) - bt)))) * (ToeScale / FilmSlope))));\n    }\n    float StraightMatch = (((float (1) - FilmToe) / FilmSlope) - ToeMatch);\n    float ShoulderMatch = ((FilmShoulder / FilmSlope) - StraightMatch);\n    vec3 LogColor = vec3 (log10(WorkingColor));\n    vec3 StraightColor = vec3 ((FilmSlope * (vec3 (LogColor) + vec3 (StraightMatch))));\n    vec3 ToeColor = vec3 ((vec3 ((-FilmBlackClip)) + ((2.000000 * ToeScale) / (vec3 (1.000000) + exp(((((-2.000000) * FilmSlope) / ToeScale) * (vec3 (LogColor) - vec3 (ToeMatch))))))));\n    vec3 ShoulderColor = vec3 ((vec3 ((1.000000 + FilmWhiteClip)) - ((2.000000 * ShoulderScale) / (vec3 (1.000000) + exp((((2.000000 * FilmSlope) / ShoulderScale) * (vec3 (LogColor) - vec3 (ShoulderMatch))))))));\n    (ToeColor = ((((((LogColor).r < ToeMatch) || ((LogColor).g < ToeMatch)) || ((LogColor).b < ToeMatch)))?(ToeColor):(StraightColor)));\n    (ShoulderColor = ((((((LogColor).r > ShoulderMatch) || ((LogColor).g > ShoulderMatch)) || ((LogColor).b > ShoulderMatch)))?(ShoulderColor):(StraightColor)));\n    vec3 t = vec3 (clamp(((vec3 (LogColor) - vec3 (ToeMatch)) / (ShoulderMatch - ToeMatch)), 0.0, 1.0));\n    (t = vec3 ((((ShoulderMatch < ToeMatch))?((vec3 (1.000000) - vec3 (t))):(t))));\n    (t = vec3 ((((vec3 (3.000000) - (2.000000 * t)) * t) * t)));\n    vec3 ToneColor = mix(ToeColor, ShoulderColor, t);\n    (ToneColor = mix(vec3 (dot(vec3(ToneColor), AP1_RGB2Y)), ToneColor, vec3 (0.930000)));\n    return vec3 (max(vec3 (0.000000), vec3 (ToneColor)));\n}\nmat3 OuputGamutMappingMatrix(int OutputGamut) {\n    mat3 AP1_2_sRGB = (XYZ_2_sRGB_MAT * (D60_2_D65_CAT * AP1_2_XYZ_MAT));\n    return AP1_2_sRGB;\n}\nvec3 LogToLin( vec3 LogColor )\n{\n  const float LinearRange = 14.;\n  const float LinearGrey = 0.18;\n  const float ExposureGrey = 444.;\n  vec3 LinearColor = exp2( ( LogColor - ExposureGrey / 1023.0 ) * LinearRange ) * LinearGrey;\n  return LinearColor;\n}\nfloat LinearToSrgbBranchingChannel(float lin)\n{\n  if(lin < 0.00313067) return lin * 12.92;\n  return pow(lin, (1.0/2.4)) * 1.055 - 0.055;\n}\nvec3 LinearToSrgbBranching(vec3 lin)\n{\n  return vec3(\n    LinearToSrgbBranchingChannel(lin.r),\n    LinearToSrgbBranchingChannel(lin.g),\n    LinearToSrgbBranchingChannel(lin.b));\n}\nvec3 LinearToSrgb(vec3 lin)\n{\n  return LinearToSrgbBranching(lin);\n}\nlayout(set = 1, binding = 0) uniform SyncCombineLut {\n  vec4 sync_CombineLutParam1;\n};\nconst float LUTSize = 32.;\nconst int OutputGamut = 0;\nconst int OutputDevice = 0;\nint GetOutputDevice () {\n    return OutputDevice;\n}\nconst vec3 ColorScale = vec3(1.);\nconst vec4 OverlayColor = vec4(0.);\nconst vec3 InverseGamma = vec3(1./2.2, 2.2/2.2, 1./2.2);\nconst float BlueCorrection = 0.6;\nconst float ExpandGamut = 1.;\nconst vec3 MappingPolynomial = vec3(0., 1., 0.);\nvec3 ColorCorrection(vec3 InLDRColor)\n{\n  return MappingPolynomial.x * (InLDRColor * InLDRColor) + MappingPolynomial.y * InLDRColor + MappingPolynomial.z;\n}\nvec2 PlanckianIsothermal( float Temp, float Tint )\n{\n  float u = ( 0.860117757 + 1.54118254e-4 * Temp + 1.28641212e-7 * Temp*Temp ) / ( 1.0 + 8.42420235e-4 * Temp + 7.08145163e-7 * Temp*Temp );\n  float v = ( 0.317398726 + 4.22806245e-5 * Temp + 4.20481691e-8 * Temp*Temp ) / ( 1.0 - 2.89741816e-5 * Temp + 1.61456053e-7 * Temp*Temp );\n  float ud = ( -1.13758118e9 - 1.91615621e6 * Temp - 1.53177 * Temp*Temp ) / Square( 1.41213984e6 + 1189.62 * Temp + Temp*Temp );\n  float vd = (  1.97471536e9 - 705674.0 * Temp - 308.607 * Temp*Temp ) / Square( 6.19363586e6 - 179.456 * Temp + Temp*Temp );\n  vec2 uvd = normalize( vec2( u, v ) );\n  u += -uvd.y * Tint * 0.05;\n  v +=  uvd.x * Tint * 0.05;\n  float x = 3.*u / ( 2.*u - 8.*v + 4. );\n  float y = 2.*v / ( 2.*u - 8.*v + 4. );\n  return vec2(x,y);\n}\nvec2 D_IlluminantChromaticity( float Temp )\n{\n  Temp *= 1.4388 / 1.438;\n  float x =  Temp <= 7000. ?\n        0.244063 + ( 0.09911e3 + ( 2.9678e6 - 4.6070e9 / Temp ) / Temp ) / Temp :\n        0.237040 + ( 0.24748e3 + ( 1.9018e6 - 2.0064e9 / Temp ) / Temp ) / Temp;\n  float y = -3. * x*x + 2.87 * x - 0.275;\n  return vec2(x,y);\n}\nvec2 PlanckianLocusChromaticity( float Temp )\n{\n  float u = ( 0.860117757 + 1.54118254e-4 * Temp + 1.28641212e-7 * Temp*Temp ) / ( 1.0 + 8.42420235e-4 * Temp + 7.08145163e-7 * Temp*Temp );\n  float v = ( 0.317398726 + 4.22806245e-5 * Temp + 4.20481691e-8 * Temp*Temp ) / ( 1.0 - 2.89741816e-5 * Temp + 1.61456053e-7 * Temp*Temp );\n  float x = 3.*u / ( 2.*u - 8.*v + 4. );\n  float y = 2.*v / ( 2.*u - 8.*v + 4. );\n  return vec2(x,y);\n}\nvec3 WhiteBalance( vec3 LinearColor )\n{\n  float WhiteTemp = sync_CombineLutParam1.x;\n  float WhiteTint = sync_CombineLutParam1.y;\n  vec2 SrcWhiteDaylight = D_IlluminantChromaticity( WhiteTemp );\n  vec2 SrcWhitePlankian = PlanckianLocusChromaticity( WhiteTemp );\n  vec2 SrcWhite = WhiteTemp < 4000. ? SrcWhitePlankian : SrcWhiteDaylight;\n  vec2 D65White = vec2( 0.31270,  0.32900 );\n  {\n    vec2 Isothermal = PlanckianIsothermal( WhiteTemp, WhiteTint ) - SrcWhitePlankian;\n    SrcWhite += Isothermal;\n  }\n  mat3 WhiteBalanceMat = ChromaticAdaptation( SrcWhite, D65White );\n  WhiteBalanceMat = ( XYZ_2_sRGB_MAT * ( WhiteBalanceMat * sRGB_2_XYZ_MAT ) );\n  return ( WhiteBalanceMat * LinearColor );\n}\nconst mat3 BlueCorrect = mat3(0.9404372683,0.0083786969,0.0005471261,-0.0183068787,0.8286599939,-0.0008833746,0.0778696104,0.1629613092,1.0003362486);\nconst mat3 BlueCorrectInv = mat3(1.06318,-0.0106337,-0.000590887,0.0233956,1.20632,0.00105248,-0.0865726,-0.19569,0.999538);\nconst mat3 Wide_2_XYZ_MAT = mat3(0.5441691,0.2394656,-0.0023439,0.2395926,0.7021530,0.0361834,0.1666943,0.0583814,1.0552183);\nvec4 combineLuts (vec2 InUV) {\n    vec4 Neutral;\n  {\n    vec2 UV = InUV;\n    UV -= vec2(0.49999 / (LUTSize * LUTSize), 0.49999 / LUTSize);\n    float Scale = LUTSize / (LUTSize - 1.);\n    vec3 RGB;\n    RGB.r = fract(UV.x * LUTSize);\n    RGB.b = UV.x - RGB.r / LUTSize;\n    RGB.g = UV.y;\n    Neutral = vec4(RGB * Scale, 0.);\n  }\n    vec4 OutColor = vec4(0.);\n  mat3 sRGB_2_AP1 = ( XYZ_2_AP1_MAT * ( D65_2_D60_CAT * sRGB_2_XYZ_MAT ) );\n  mat3 AP1_2_sRGB = ( XYZ_2_sRGB_MAT * ( D60_2_D65_CAT * AP1_2_XYZ_MAT ) );\n  mat3 AP0_2_AP1 = ( XYZ_2_AP1_MAT * AP0_2_XYZ_MAT );\n  mat3 AP1_2_AP0 = ( XYZ_2_AP0_MAT * AP1_2_XYZ_MAT );\n  mat3 AP1_2_Output  = OuputGamutMappingMatrix( OutputGamut );\n    vec3 LUTEncodedColor = Neutral.rgb;\n  vec3 LinearColor;\n  if (GetOutputDevice() >= 3)\n  {\n  }\n  else {\n        LinearColor = LogToLin( LUTEncodedColor ) - LogToLin( vec3(0.) );\n    }\n    vec3 BalancedColor = WhiteBalance( LinearColor );\n  vec3 ColorAP1 = sRGB_2_AP1 * BalancedColor;\n  {\n    float  LumaAP1 = dot( ColorAP1, AP1_RGB2Y );\n    vec3 ChromaAP1 = ColorAP1 / LumaAP1;\n    float ChromaDistSqr = dot( ChromaAP1 - 1., ChromaAP1 - 1. );\n    float ExpandAmount = ( 1. - exp2( -4. * ChromaDistSqr ) ) * ( 1. - exp2( -4. * ExpandGamut * LumaAP1*LumaAP1 ) );\n    mat3 Wide_2_AP1 = XYZ_2_AP1_MAT * Wide_2_XYZ_MAT;\n    mat3 ExpandMat = Wide_2_AP1 * AP1_2_sRGB;\n    vec3 ColorExpand = ExpandMat * ColorAP1;\n    ColorAP1 = mix( ColorAP1, ColorExpand, ExpandAmount );\n  }\n  vec3 GradedColor = AP1_2_sRGB * ColorAP1;\n  mat3 BlueCorrectAP1    = ( AP0_2_AP1 * ( BlueCorrect *    AP1_2_AP0 ) );\n  mat3 BlueCorrectInvAP1 = ( AP0_2_AP1 * ( BlueCorrectInv * AP1_2_AP0 ) );\n  ColorAP1 = mix( ColorAP1, ( BlueCorrectAP1 * ColorAP1 ), BlueCorrection );\n  ColorAP1 = FilmToneMap( ColorAP1 );\n  ColorAP1 = mix( ColorAP1, ( BlueCorrectInvAP1 * ColorAP1 ), BlueCorrection );\n  vec3 FilmColor = max(vec3(0.), ( AP1_2_sRGB * ColorAP1 ));\n  FilmColor = ColorCorrection( FilmColor );\n  vec3 FilmColorNoGamma = mix( FilmColor * ColorScale, OverlayColor.rgb, OverlayColor.a );\n  FilmColor = pow( max(vec3(0.), FilmColorNoGamma), vec3(InverseGamma.y) );\n    vec3 OutDeviceColor = vec3(0.);\n  if( GetOutputDevice() == 0 )\n  {\n    vec3 OutputGamutColor = FilmColor;\n    OutDeviceColor = LinearToSrgb( OutputGamutColor );\n  }\n  OutColor.rgb = OutDeviceColor / 1.05;\n  OutColor.a = 1.;\n  return OutColor;\n}\n  layout(location = 0) in vec2 v_uv;\n  layout(location = 0) out vec4 fragColor;\n  void main () {\n    fragColor = combineLuts(v_uv);\n  }"},"glsl3":{"vert":"\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\nin vec4 a_tangent;\n#if CC_USE_MORPH\n    in float a_vertexId;\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n  layout(std140) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n  };\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n        ivec2 texSize = textureSize(tex, 0);\n        return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture(tex, x)),\n        decode32(texture(tex, y)),\n        decode32(texture(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout StandardVertInput attr) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    attr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    attr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    attr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n    in vec4 a_joints;\n  in vec4 a_weights;\n  #if CC_USE_BAKED_ANIMATION\n    #if USE_INSTANCING\n      in highp vec4 a_jointAnimInfo;\n    #endif\n    layout(std140) uniform CCSkinningTexture {\n      highp vec4 cc_jointTextureInfo;\n    };\n    layout(std140) uniform CCSkinningAnimation {\n      highp vec4 cc_jointAnimInfo;\n    };\n    uniform highp sampler2D cc_jointTexture;\n      #else\n    layout(std140) uniform CCSkinning {\n      highp vec4 cc_joints[30 * 3];\n    };\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout StandardVertInput attr) {\n    mat4 m = skinMatrix();\n    attr.position = m * attr.position;\n    attr.normal = (m * vec4(attr.normal, 0.0)).xyz;\n    attr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n  }\n#endif\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nout vec2 v_uv;\nvoid main () {\n  StandardVertInput In;\n      In.position = vec4(a_position, 1.0);\n      In.normal = a_normal;\n      In.tangent = a_tangent;\n    #if CC_USE_MORPH\n      applyMorph(In);\n    #endif\n    #if CC_USE_SKINNING\n      CCSkin(In);\n    #endif\n  gl_Position = In.position;\n  v_uv = a_texCoord;\n}","frag":"\n  precision highp float;\n  layout(std140) uniform CCGlobal {\n    highp   vec4 cc_time;\n    mediump vec4 cc_screenSize;\n    mediump vec4 cc_nativeSize;\n  };\n  layout(std140) uniform CCCamera {\n    highp   mat4 cc_matView;\n    highp   mat4 cc_matViewInv;\n    highp   mat4 cc_matProj;\n    highp   mat4 cc_matProjInv;\n    highp   mat4 cc_matViewProj;\n    highp   mat4 cc_matViewProjInv;\n    highp   vec4 cc_cameraPos;\n    mediump vec4 cc_screenScale;\n    mediump vec4 cc_exposure;\n    mediump vec4 cc_mainLitDir;\n    mediump vec4 cc_mainLitColor;\n    mediump vec4 cc_ambientSky;\n    mediump vec4 cc_ambientGround;\n    mediump vec4 cc_fogColor;\n    mediump vec4 cc_fogBase;\n    mediump vec4 cc_fogAdd;\n    mediump vec4 cc_nearFar;\n    mediump vec4 cc_viewPort;\n  };\nfloat Square(float v)\n{\n    return v * v;\n}\nfloat log10(float n)\n{\n    const float kLogBase10 = 1.0 / log2(10.0);\n    return log2(n) * kLogBase10;\n}\nvec2 log10(vec2 n)\n{\n    return vec2(log10(n.x), log10(n.y));\n}\nvec3 log10(vec3 n)\n{\n    return vec3(log10(n.x), log10(n.y), log10(n.z));\n}\nstruct Light {\n  vec3 color;\n  vec3 direction;\n};\nstruct FDirectLighting\n{\n  vec3 Diffuse;\n  vec3 Specular;\n};\nstruct FPixelMaterialInputs\n{\n  vec3 Normal;\n  vec3 EmissiveColor;\n  float Opacity;\n  float OpacityMask;\n  vec3 BaseColor;\n  float Metallic;\n  float Specular;\n  float Roughness;\n  float AmbientOcclusion;\n  float Anisotropy;\n  float Tangent;\n  float Refraction;\n  float PixelDepthOffset;\n  float ShadingModel;\n  float TwoSidedSign;\n  float RoughnessWithClamp;\n  vec3 DiffuseColor;\n  vec3 SpecularColor;\n  vec3 Subsurface;\n};\nstruct FMaterialPixelParameters {\n  float IndirectIrradiance;\n  vec2 TexCoords_0;\n  vec2 TexCoords_1;\n  vec4 VertexColor;\n  vec3 WorldNormal;\n  vec3 WorldTangent;\n  vec3 ReflectionVector;\n  vec3 CameraVector;\n  vec3 LightVector;\n  vec4 SvPosition;\n  vec4 ScreenPosition;\n  mat3 TangentToWorld;\n  vec3 AbsoluteWorldPosition;\n  vec3 ObjectWorldPosition;\n  vec2 LightmapUVs;\n  int PrimitiveId;\n};\nstruct FMaterialVertexParameters {\n  vec3 WorldPosition;\n  vec4 VertexColor;\n};\n vec4 F4_0101 = vec4(0, 1, 0, 1);\n mat3 AP0_2_XYZ_MAT = mat3(0.952552,0.343966,0.000000,0.000000,0.728166,0.000000,0.000094,(-0.072133),1.008825);\n mat3 XYZ_2_AP0_MAT = mat3(1.049811,(-0.495903),0.000000,0.000000,1.373313,0.000000,(-0.000097),0.098240,0.991252);\n mat3 AP1_2_XYZ_MAT = mat3(0.662454,0.272229,(-0.005575),0.134004,0.674082,0.004061,0.156188,0.053690,1.010339);\n mat3 XYZ_2_AP1_MAT = mat3(1.641023,(-0.663663),0.011722,(-0.324803),1.615332,(-0.008284),(-0.236425),0.016756,0.988395);\n mat3 AP0_2_AP1_MAT = mat3(1.451439,(-0.076554),0.008316,(-0.236511),1.176230,(-0.006032),(-0.214929),(-0.099676),0.997716);\n mat3 AP1_2_AP0_MAT = mat3(0.695452,0.044795,(-0.005526),0.140679,0.859671,0.004025,0.163869,0.095534,1.001501);\n vec3 AP1_RGB2Y = vec3(0.272229, 0.674082, 0.053690);\n mat3 XYZ_2_sRGB_MAT = mat3(3.240970,(-0.969244),0.055630,(-1.537383),1.875968,(-0.203977),(-0.498611),0.041555,1.056972);\n mat3 sRGB_2_XYZ_MAT = mat3(0.412456,0.212673,0.019334,0.357576,0.715152,0.119192,0.180438,0.072175,0.950304);\n mat3 XYZ_2_Rec2020_MAT = mat3(1.716608,(-0.666683),0.017642,(-0.355662),1.616478,(-0.042776),(-0.253360),0.015769,0.942229);\n mat3 Rec2020_2_XYZ_MAT = mat3(0.636974,0.262707,0.000000,0.144617,0.678000,0.028073,0.168858,0.059294,1.060844);\n mat3 XYZ_2_P3D65_MAT = mat3(2.493396,(-0.829487),0.035851,(-0.931346),1.762660,(-0.076183),(-0.402694),0.023625,0.957014);\n mat3 P3D65_2_XYZ_MAT = mat3(0.486591,0.228984,0.000000,0.265668,0.691740,0.045114,0.198190,0.079276,1.043803);\n mat3 D65_2_D60_CAT = mat3(1.013030,0.007698,(-0.002841),0.006105,0.998165,0.004685,(-0.014971),(-0.005032),0.924507);\n mat3 D60_2_D65_CAT = mat3(0.987224,(-0.007598),0.003073,(-0.006113),1.001860,(-0.005096),0.015953,0.005330,1.081680);\n float HALF_MAX = 65504.000000;\nfloat rgb_2_saturation(vec3 rgb) {\n    float minrgb = min(min((rgb).r, (rgb).g), (rgb).b);\n    float maxrgb = max(max((rgb).r, (rgb).g), (rgb).b);\n    return ((max(maxrgb, 0.000000) - max(minrgb, 0.000000)) / max(maxrgb, 0.010000));\n}\nfloat glow_fwd(float ycIn, float glowGainIn, float glowMid) {\n    float glowGainOut;\n    if ((ycIn <= ((2.000000 / 3.000000) * glowMid))) {\n        (glowGainOut = glowGainIn);\n    }\n    else {\n        if ((ycIn >= (2.000000 * glowMid))) {\n            (glowGainOut = 0.000000);\n        }\n        else {\n            (glowGainOut = (glowGainIn * ((glowMid / ycIn) - 0.500000)));\n        }\n    }\n    return glowGainOut;\n}\nfloat sigmoid_shaper(float x) {\n    float t = max((float (1) - abs((0.500000 * x))), float (0));\n    float y = (float (1) + (sign(x) * (float (1) - (t * t))));\n    return (0.500000 * y);\n}\nfloat center_hue(float hue, float centerH) {\n    float hueCentered = (hue - centerH);\n    if ((hueCentered < (-180.000000))) {\n        (hueCentered += float (360));\n    }\n    else {\n        if ((hueCentered > 180.000000)) {\n            (hueCentered -= float (360));\n        }\n    }\n    return hueCentered;\n}\nfloat rgb_2_hue(vec3 rgb) {\n    float hue;\n    if (((rgb[0] == rgb[1]) && (rgb[1] == rgb[2]))) {\n        (hue = float (0));\n    }\n    else {\n        (hue = ((180.000000 / 3.14159265359) * atan((sqrt(3.000000) * (rgb[1] - rgb[2])), (((2.000000 * rgb[0]) - rgb[1]) - rgb[2]))));\n    }\n    if ((hue < 0.000000)) {\n        (hue = (hue + 360.000000));\n    }\n    return clamp(hue, 0.000000, 360.000000);\n}\nfloat rgb_2_yc(vec3 rgb, float ycRadiusWeight) {\n    float r = rgb[0];\n    float g = rgb[1];\n    float b = rgb[2];\n    float chroma = sqrt((((b * (b - g)) + (g * (g - r))) + (r * (r - b))));\n    return ((((b + g) + r) + (ycRadiusWeight * chroma)) / 3.000000);\n}\nvec3 xyY_2_XYZ(vec3 xyY) {\n    vec3 XYZ;\n    (XYZ[0] = ((xyY[0] * xyY[2]) / max(xyY[1], 0.000000)));\n    (XYZ[1] = xyY[2]);\n    (XYZ[2] = ((((1.000000 - xyY[0]) - xyY[1]) * xyY[2]) / max(xyY[1], 0.000000)));\n    return XYZ;\n}\n mat3 ConeResponse = mat3(0.895100,(-0.750200),0.038900,0.266400,1.713500,(-0.068500),(-0.161400),0.036700,1.029600);\n mat3 InvConeResponse = mat3(0.986993,0.432305,(-0.008529),(-0.147054),0.518360,0.040043,0.159963,0.049291,0.968487);\nmat3 ChromaticAdaptation(vec2 src_xy, vec2 dst_xy) {\n    vec3 src_XYZ = xyY_2_XYZ(vec3(src_xy, 1));\n    vec3 dst_XYZ = xyY_2_XYZ(vec3(dst_xy, 1));\n    vec3 src_coneResp = (ConeResponse * src_XYZ);\n    vec3 dst_coneResp = (ConeResponse * dst_XYZ);\n    mat3 VonKriesMat = mat3(((dst_coneResp).x / (src_coneResp).x),0.000000,0.000000,0.000000,((dst_coneResp).y / (src_coneResp).y),0.000000,0.000000,0.000000,((dst_coneResp).z / (src_coneResp).z));\n    return (InvConeResponse * (VonKriesMat * ConeResponse));\n}\n float FilmSlope = 0.880000;\n float FilmToe = 0.550000;\n float FilmShoulder = 0.260000;\n float FilmBlackClip = float (0);\n float FilmWhiteClip = 0.040000;\nvec3 FilmToneMap(vec3 LinearColor) {\n    mat3 sRGB_2_AP0 = (XYZ_2_AP0_MAT * (D65_2_D60_CAT * sRGB_2_XYZ_MAT));\n    mat3 sRGB_2_AP1 = (XYZ_2_AP1_MAT * (D65_2_D60_CAT * sRGB_2_XYZ_MAT));\n    mat3 AP0_2_sRGB = (XYZ_2_sRGB_MAT * (D60_2_D65_CAT * AP0_2_XYZ_MAT));\n    mat3 AP1_2_sRGB = (XYZ_2_sRGB_MAT * (D60_2_D65_CAT * AP1_2_XYZ_MAT));\n    mat3 AP0_2_AP1 = (XYZ_2_AP1_MAT * AP0_2_XYZ_MAT);\n    mat3 AP1_2_AP0 = (XYZ_2_AP0_MAT * AP1_2_XYZ_MAT);\n    vec3 ColorAP1 = vec3 (LinearColor);\n    vec3 ColorAP0 = (AP1_2_AP0 * ColorAP1);\n    float RRT_GLOW_GAIN = 0.050000;\n    float RRT_GLOW_MID = 0.080000;\n    float saturation = rgb_2_saturation(ColorAP0);\n    float ycIn = rgb_2_yc(ColorAP0, 1.750000);\n    float s = sigmoid_shaper(((saturation - 0.400000) / 0.200000));\n    float addedGlow = (float (1) + glow_fwd(ycIn, (RRT_GLOW_GAIN * s), RRT_GLOW_MID));\n    (ColorAP0 *= vec3 (addedGlow));\n    float RRT_RED_SCALE = 0.820000;\n    float RRT_RED_PIVOT = 0.030000;\n    float RRT_RED_HUE = float (0);\n    float RRT_RED_WIDTH = float (135);\n    float hue = rgb_2_hue(ColorAP0);\n    float centeredHue = center_hue(hue, RRT_RED_HUE);\n    float hueWeight = Square(smoothstep(0.000000, 1.000000, (1.000000 - abs(((2.000000 * centeredHue) / RRT_RED_WIDTH)))));\n    ((ColorAP0).r += (((hueWeight * saturation) * (RRT_RED_PIVOT - (ColorAP0).r)) * (1.000000 - RRT_RED_SCALE)));\n    vec3 WorkingColor = (AP0_2_AP1_MAT * ColorAP0);\n    (WorkingColor = max(vec3 (0.000000), WorkingColor));\n    (WorkingColor = vec3 (mix(vec3 (dot(WorkingColor, AP1_RGB2Y)), vec3 (WorkingColor), vec3 (0.960000))));\n    float ToeScale = float (((1.000000 + FilmBlackClip) - FilmToe));\n    float ShoulderScale = float (((1.000000 + FilmWhiteClip) - FilmShoulder));\n    float InMatch = 0.180000;\n    float OutMatch = 0.180000;\n    float ToeMatch;\n    if ((FilmToe > 0.800000)) {\n        (ToeMatch = ((((float (1) - FilmToe) - OutMatch) / FilmSlope) + log10(InMatch)));\n    }\n    else {\n        float bt = (((OutMatch + FilmBlackClip) / ToeScale) - float (1));\n        (ToeMatch = (log10(InMatch) - ((0.500000 * log(((float (1) + bt) / (float (1) - bt)))) * (ToeScale / FilmSlope))));\n    }\n    float StraightMatch = (((float (1) - FilmToe) / FilmSlope) - ToeMatch);\n    float ShoulderMatch = ((FilmShoulder / FilmSlope) - StraightMatch);\n    vec3 LogColor = vec3 (log10(WorkingColor));\n    vec3 StraightColor = vec3 ((FilmSlope * (vec3 (LogColor) + vec3 (StraightMatch))));\n    vec3 ToeColor = vec3 ((vec3 ((-FilmBlackClip)) + ((2.000000 * ToeScale) / (vec3 (1.000000) + exp(((((-2.000000) * FilmSlope) / ToeScale) * (vec3 (LogColor) - vec3 (ToeMatch))))))));\n    vec3 ShoulderColor = vec3 ((vec3 ((1.000000 + FilmWhiteClip)) - ((2.000000 * ShoulderScale) / (vec3 (1.000000) + exp((((2.000000 * FilmSlope) / ShoulderScale) * (vec3 (LogColor) - vec3 (ShoulderMatch))))))));\n    (ToeColor = ((((((LogColor).r < ToeMatch) || ((LogColor).g < ToeMatch)) || ((LogColor).b < ToeMatch)))?(ToeColor):(StraightColor)));\n    (ShoulderColor = ((((((LogColor).r > ShoulderMatch) || ((LogColor).g > ShoulderMatch)) || ((LogColor).b > ShoulderMatch)))?(ShoulderColor):(StraightColor)));\n    vec3 t = vec3 (clamp(((vec3 (LogColor) - vec3 (ToeMatch)) / (ShoulderMatch - ToeMatch)), 0.0, 1.0));\n    (t = vec3 ((((ShoulderMatch < ToeMatch))?((vec3 (1.000000) - vec3 (t))):(t))));\n    (t = vec3 ((((vec3 (3.000000) - (2.000000 * t)) * t) * t)));\n    vec3 ToneColor = mix(ToeColor, ShoulderColor, t);\n    (ToneColor = mix(vec3 (dot(vec3(ToneColor), AP1_RGB2Y)), ToneColor, vec3 (0.930000)));\n    return vec3 (max(vec3 (0.000000), vec3 (ToneColor)));\n}\nmat3 OuputGamutMappingMatrix(int OutputGamut) {\n    mat3 AP1_2_sRGB = (XYZ_2_sRGB_MAT * (D60_2_D65_CAT * AP1_2_XYZ_MAT));\n    return AP1_2_sRGB;\n}\nvec3 LogToLin( vec3 LogColor )\n{\n  const float LinearRange = 14.;\n  const float LinearGrey = 0.18;\n  const float ExposureGrey = 444.;\n  vec3 LinearColor = exp2( ( LogColor - ExposureGrey / 1023.0 ) * LinearRange ) * LinearGrey;\n  return LinearColor;\n}\nfloat LinearToSrgbBranchingChannel(float lin)\n{\n  if(lin < 0.00313067) return lin * 12.92;\n  return pow(lin, (1.0/2.4)) * 1.055 - 0.055;\n}\nvec3 LinearToSrgbBranching(vec3 lin)\n{\n  return vec3(\n    LinearToSrgbBranchingChannel(lin.r),\n    LinearToSrgbBranchingChannel(lin.g),\n    LinearToSrgbBranchingChannel(lin.b));\n}\nvec3 LinearToSrgb(vec3 lin)\n{\n  return LinearToSrgbBranching(lin);\n}\nlayout(std140) uniform SyncCombineLut {\n  vec4 sync_CombineLutParam1;\n};\nconst float LUTSize = 32.;\nconst int OutputGamut = 0;\nconst int OutputDevice = 0;\nint GetOutputDevice () {\n    return OutputDevice;\n}\nconst vec3 ColorScale = vec3(1.);\nconst vec4 OverlayColor = vec4(0.);\nconst vec3 InverseGamma = vec3(1./2.2, 2.2/2.2, 1./2.2);\nconst float BlueCorrection = 0.6;\nconst float ExpandGamut = 1.;\nconst vec3 MappingPolynomial = vec3(0., 1., 0.);\nvec3 ColorCorrection(vec3 InLDRColor)\n{\n  return MappingPolynomial.x * (InLDRColor * InLDRColor) + MappingPolynomial.y * InLDRColor + MappingPolynomial.z;\n}\nvec2 PlanckianIsothermal( float Temp, float Tint )\n{\n  float u = ( 0.860117757 + 1.54118254e-4 * Temp + 1.28641212e-7 * Temp*Temp ) / ( 1.0 + 8.42420235e-4 * Temp + 7.08145163e-7 * Temp*Temp );\n  float v = ( 0.317398726 + 4.22806245e-5 * Temp + 4.20481691e-8 * Temp*Temp ) / ( 1.0 - 2.89741816e-5 * Temp + 1.61456053e-7 * Temp*Temp );\n  float ud = ( -1.13758118e9 - 1.91615621e6 * Temp - 1.53177 * Temp*Temp ) / Square( 1.41213984e6 + 1189.62 * Temp + Temp*Temp );\n  float vd = (  1.97471536e9 - 705674.0 * Temp - 308.607 * Temp*Temp ) / Square( 6.19363586e6 - 179.456 * Temp + Temp*Temp );\n  vec2 uvd = normalize( vec2( u, v ) );\n  u += -uvd.y * Tint * 0.05;\n  v +=  uvd.x * Tint * 0.05;\n  float x = 3.*u / ( 2.*u - 8.*v + 4. );\n  float y = 2.*v / ( 2.*u - 8.*v + 4. );\n  return vec2(x,y);\n}\nvec2 D_IlluminantChromaticity( float Temp )\n{\n  Temp *= 1.4388 / 1.438;\n  float x =  Temp <= 7000. ?\n        0.244063 + ( 0.09911e3 + ( 2.9678e6 - 4.6070e9 / Temp ) / Temp ) / Temp :\n        0.237040 + ( 0.24748e3 + ( 1.9018e6 - 2.0064e9 / Temp ) / Temp ) / Temp;\n  float y = -3. * x*x + 2.87 * x - 0.275;\n  return vec2(x,y);\n}\nvec2 PlanckianLocusChromaticity( float Temp )\n{\n  float u = ( 0.860117757 + 1.54118254e-4 * Temp + 1.28641212e-7 * Temp*Temp ) / ( 1.0 + 8.42420235e-4 * Temp + 7.08145163e-7 * Temp*Temp );\n  float v = ( 0.317398726 + 4.22806245e-5 * Temp + 4.20481691e-8 * Temp*Temp ) / ( 1.0 - 2.89741816e-5 * Temp + 1.61456053e-7 * Temp*Temp );\n  float x = 3.*u / ( 2.*u - 8.*v + 4. );\n  float y = 2.*v / ( 2.*u - 8.*v + 4. );\n  return vec2(x,y);\n}\nvec3 WhiteBalance( vec3 LinearColor )\n{\n  float WhiteTemp = sync_CombineLutParam1.x;\n  float WhiteTint = sync_CombineLutParam1.y;\n  vec2 SrcWhiteDaylight = D_IlluminantChromaticity( WhiteTemp );\n  vec2 SrcWhitePlankian = PlanckianLocusChromaticity( WhiteTemp );\n  vec2 SrcWhite = WhiteTemp < 4000. ? SrcWhitePlankian : SrcWhiteDaylight;\n  vec2 D65White = vec2( 0.31270,  0.32900 );\n  {\n    vec2 Isothermal = PlanckianIsothermal( WhiteTemp, WhiteTint ) - SrcWhitePlankian;\n    SrcWhite += Isothermal;\n  }\n  mat3 WhiteBalanceMat = ChromaticAdaptation( SrcWhite, D65White );\n  WhiteBalanceMat = ( XYZ_2_sRGB_MAT * ( WhiteBalanceMat * sRGB_2_XYZ_MAT ) );\n  return ( WhiteBalanceMat * LinearColor );\n}\nconst mat3 BlueCorrect = mat3(0.9404372683,0.0083786969,0.0005471261,-0.0183068787,0.8286599939,-0.0008833746,0.0778696104,0.1629613092,1.0003362486);\nconst mat3 BlueCorrectInv = mat3(1.06318,-0.0106337,-0.000590887,0.0233956,1.20632,0.00105248,-0.0865726,-0.19569,0.999538);\nconst mat3 Wide_2_XYZ_MAT = mat3(0.5441691,0.2394656,-0.0023439,0.2395926,0.7021530,0.0361834,0.1666943,0.0583814,1.0552183);\nvec4 combineLuts (vec2 InUV) {\n    vec4 Neutral;\n  {\n    vec2 UV = InUV;\n    UV -= vec2(0.49999 / (LUTSize * LUTSize), 0.49999 / LUTSize);\n    float Scale = LUTSize / (LUTSize - 1.);\n    vec3 RGB;\n    RGB.r = fract(UV.x * LUTSize);\n    RGB.b = UV.x - RGB.r / LUTSize;\n    RGB.g = UV.y;\n    Neutral = vec4(RGB * Scale, 0.);\n  }\n    vec4 OutColor = vec4(0.);\n  mat3 sRGB_2_AP1 = ( XYZ_2_AP1_MAT * ( D65_2_D60_CAT * sRGB_2_XYZ_MAT ) );\n  mat3 AP1_2_sRGB = ( XYZ_2_sRGB_MAT * ( D60_2_D65_CAT * AP1_2_XYZ_MAT ) );\n  mat3 AP0_2_AP1 = ( XYZ_2_AP1_MAT * AP0_2_XYZ_MAT );\n  mat3 AP1_2_AP0 = ( XYZ_2_AP0_MAT * AP1_2_XYZ_MAT );\n  mat3 AP1_2_Output  = OuputGamutMappingMatrix( OutputGamut );\n    vec3 LUTEncodedColor = Neutral.rgb;\n  vec3 LinearColor;\n  if (GetOutputDevice() >= 3)\n  {\n  }\n  else {\n        LinearColor = LogToLin( LUTEncodedColor ) - LogToLin( vec3(0.) );\n    }\n    vec3 BalancedColor = WhiteBalance( LinearColor );\n  vec3 ColorAP1 = sRGB_2_AP1 * BalancedColor;\n  {\n    float  LumaAP1 = dot( ColorAP1, AP1_RGB2Y );\n    vec3 ChromaAP1 = ColorAP1 / LumaAP1;\n    float ChromaDistSqr = dot( ChromaAP1 - 1., ChromaAP1 - 1. );\n    float ExpandAmount = ( 1. - exp2( -4. * ChromaDistSqr ) ) * ( 1. - exp2( -4. * ExpandGamut * LumaAP1*LumaAP1 ) );\n    mat3 Wide_2_AP1 = XYZ_2_AP1_MAT * Wide_2_XYZ_MAT;\n    mat3 ExpandMat = Wide_2_AP1 * AP1_2_sRGB;\n    vec3 ColorExpand = ExpandMat * ColorAP1;\n    ColorAP1 = mix( ColorAP1, ColorExpand, ExpandAmount );\n  }\n  vec3 GradedColor = AP1_2_sRGB * ColorAP1;\n  mat3 BlueCorrectAP1    = ( AP0_2_AP1 * ( BlueCorrect *    AP1_2_AP0 ) );\n  mat3 BlueCorrectInvAP1 = ( AP0_2_AP1 * ( BlueCorrectInv * AP1_2_AP0 ) );\n  ColorAP1 = mix( ColorAP1, ( BlueCorrectAP1 * ColorAP1 ), BlueCorrection );\n  ColorAP1 = FilmToneMap( ColorAP1 );\n  ColorAP1 = mix( ColorAP1, ( BlueCorrectInvAP1 * ColorAP1 ), BlueCorrection );\n  vec3 FilmColor = max(vec3(0.), ( AP1_2_sRGB * ColorAP1 ));\n  FilmColor = ColorCorrection( FilmColor );\n  vec3 FilmColorNoGamma = mix( FilmColor * ColorScale, OverlayColor.rgb, OverlayColor.a );\n  FilmColor = pow( max(vec3(0.), FilmColorNoGamma), vec3(InverseGamma.y) );\n    vec3 OutDeviceColor = vec3(0.);\n  if( GetOutputDevice() == 0 )\n  {\n    vec3 OutputGamutColor = FilmColor;\n    OutDeviceColor = LinearToSrgb( OutputGamutColor );\n  }\n  OutColor.rgb = OutDeviceColor / 1.05;\n  OutColor.a = 1.;\n  return OutColor;\n}\n  in vec2 v_uv;\n  layout(location = 0) out vec4 fragColor;\n  void main () {\n    fragColor = combineLuts(v_uv);\n  }"},"glsl1":{"vert":"\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\nattribute vec4 a_tangent;\n#if CC_USE_MORPH\n    attribute float a_vertexId;\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n  uniform vec4 cc_displacementWeights[15];\n  uniform vec4 cc_displacementTextureInfo;\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n        int pixelIndex = elementIndex;\n        vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n        vec2 uv = getPixelCoordFromLocation(location, cc_displacementTextureInfo.xy);\n        return texture2D(tex, uv);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture2D(tex, x)),\n        decode32(texture2D(tex, y)),\n        decode32(texture2D(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout StandardVertInput attr) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    attr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    attr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    attr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n    attribute vec4 a_joints;\n  attribute vec4 a_weights;\n  #if CC_USE_BAKED_ANIMATION\n    #if USE_INSTANCING\n      attribute highp vec4 a_jointAnimInfo;\n    #endif\n    uniform highp vec4 cc_jointTextureInfo;\n    uniform highp vec4 cc_jointAnimInfo;\n    uniform highp sampler2D cc_jointTexture;\n      #else\n    uniform highp vec4 cc_joints[90];\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout StandardVertInput attr) {\n    mat4 m = skinMatrix();\n    attr.position = m * attr.position;\n    attr.normal = (m * vec4(attr.normal, 0.0)).xyz;\n    attr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n  }\n#endif\nvarying vec2 v_uv;\nvoid main () {\n  StandardVertInput In;\n      In.position = vec4(a_position, 1.0);\n      In.normal = a_normal;\n      In.tangent = a_tangent;\n    #if CC_USE_MORPH\n      applyMorph(In);\n    #endif\n    #if CC_USE_SKINNING\n      CCSkin(In);\n    #endif\n  gl_Position = In.position;\n  v_uv = a_texCoord;\n}","frag":"\n  precision highp float;\n  #ifdef GL_OES_standard_derivatives\n  #else\n  #endif\nfloat Square(float v)\n{\n    return v * v;\n}\nfloat log10(float n)\n{\n    const float kLogBase10 = 1.0 / log2(10.0);\n    return log2(n) * kLogBase10;\n}\nvec2 log10(vec2 n)\n{\n    return vec2(log10(n.x), log10(n.y));\n}\nvec3 log10(vec3 n)\n{\n    return vec3(log10(n.x), log10(n.y), log10(n.z));\n}\nstruct Light {\n  vec3 color;\n  vec3 direction;\n};\nstruct FDirectLighting\n{\n  vec3 Diffuse;\n  vec3 Specular;\n};\nstruct FPixelMaterialInputs\n{\n  vec3 Normal;\n  vec3 EmissiveColor;\n  float Opacity;\n  float OpacityMask;\n  vec3 BaseColor;\n  float Metallic;\n  float Specular;\n  float Roughness;\n  float AmbientOcclusion;\n  float Anisotropy;\n  float Tangent;\n  float Refraction;\n  float PixelDepthOffset;\n  float ShadingModel;\n  float TwoSidedSign;\n  float RoughnessWithClamp;\n  vec3 DiffuseColor;\n  vec3 SpecularColor;\n  vec3 Subsurface;\n};\nstruct FMaterialPixelParameters {\n  float IndirectIrradiance;\n  vec2 TexCoords_0;\n  vec2 TexCoords_1;\n  vec4 VertexColor;\n  vec3 WorldNormal;\n  vec3 WorldTangent;\n  vec3 ReflectionVector;\n  vec3 CameraVector;\n  vec3 LightVector;\n  vec4 SvPosition;\n  vec4 ScreenPosition;\n  mat3 TangentToWorld;\n  vec3 AbsoluteWorldPosition;\n  vec3 ObjectWorldPosition;\n  vec2 LightmapUVs;\n  int PrimitiveId;\n};\nstruct FMaterialVertexParameters {\n  vec3 WorldPosition;\n  vec4 VertexColor;\n};\n vec4 F4_0101 = vec4(0, 1, 0, 1);\n mat3 AP0_2_XYZ_MAT = mat3(0.952552,0.343966,0.000000,0.000000,0.728166,0.000000,0.000094,(-0.072133),1.008825);\n mat3 XYZ_2_AP0_MAT = mat3(1.049811,(-0.495903),0.000000,0.000000,1.373313,0.000000,(-0.000097),0.098240,0.991252);\n mat3 AP1_2_XYZ_MAT = mat3(0.662454,0.272229,(-0.005575),0.134004,0.674082,0.004061,0.156188,0.053690,1.010339);\n mat3 XYZ_2_AP1_MAT = mat3(1.641023,(-0.663663),0.011722,(-0.324803),1.615332,(-0.008284),(-0.236425),0.016756,0.988395);\n mat3 AP0_2_AP1_MAT = mat3(1.451439,(-0.076554),0.008316,(-0.236511),1.176230,(-0.006032),(-0.214929),(-0.099676),0.997716);\n mat3 AP1_2_AP0_MAT = mat3(0.695452,0.044795,(-0.005526),0.140679,0.859671,0.004025,0.163869,0.095534,1.001501);\n vec3 AP1_RGB2Y = vec3(0.272229, 0.674082, 0.053690);\n mat3 XYZ_2_sRGB_MAT = mat3(3.240970,(-0.969244),0.055630,(-1.537383),1.875968,(-0.203977),(-0.498611),0.041555,1.056972);\n mat3 sRGB_2_XYZ_MAT = mat3(0.412456,0.212673,0.019334,0.357576,0.715152,0.119192,0.180438,0.072175,0.950304);\n mat3 XYZ_2_Rec2020_MAT = mat3(1.716608,(-0.666683),0.017642,(-0.355662),1.616478,(-0.042776),(-0.253360),0.015769,0.942229);\n mat3 Rec2020_2_XYZ_MAT = mat3(0.636974,0.262707,0.000000,0.144617,0.678000,0.028073,0.168858,0.059294,1.060844);\n mat3 XYZ_2_P3D65_MAT = mat3(2.493396,(-0.829487),0.035851,(-0.931346),1.762660,(-0.076183),(-0.402694),0.023625,0.957014);\n mat3 P3D65_2_XYZ_MAT = mat3(0.486591,0.228984,0.000000,0.265668,0.691740,0.045114,0.198190,0.079276,1.043803);\n mat3 D65_2_D60_CAT = mat3(1.013030,0.007698,(-0.002841),0.006105,0.998165,0.004685,(-0.014971),(-0.005032),0.924507);\n mat3 D60_2_D65_CAT = mat3(0.987224,(-0.007598),0.003073,(-0.006113),1.001860,(-0.005096),0.015953,0.005330,1.081680);\n float HALF_MAX = 65504.000000;\nfloat rgb_2_saturation(vec3 rgb) {\n    float minrgb = min(min((rgb).r, (rgb).g), (rgb).b);\n    float maxrgb = max(max((rgb).r, (rgb).g), (rgb).b);\n    return ((max(maxrgb, 0.000000) - max(minrgb, 0.000000)) / max(maxrgb, 0.010000));\n}\nfloat glow_fwd(float ycIn, float glowGainIn, float glowMid) {\n    float glowGainOut;\n    if ((ycIn <= ((2.000000 / 3.000000) * glowMid))) {\n        (glowGainOut = glowGainIn);\n    }\n    else {\n        if ((ycIn >= (2.000000 * glowMid))) {\n            (glowGainOut = 0.000000);\n        }\n        else {\n            (glowGainOut = (glowGainIn * ((glowMid / ycIn) - 0.500000)));\n        }\n    }\n    return glowGainOut;\n}\nfloat sigmoid_shaper(float x) {\n    float t = max((float (1) - abs((0.500000 * x))), float (0));\n    float y = (float (1) + (sign(x) * (float (1) - (t * t))));\n    return (0.500000 * y);\n}\nfloat center_hue(float hue, float centerH) {\n    float hueCentered = (hue - centerH);\n    if ((hueCentered < (-180.000000))) {\n        (hueCentered += float (360));\n    }\n    else {\n        if ((hueCentered > 180.000000)) {\n            (hueCentered -= float (360));\n        }\n    }\n    return hueCentered;\n}\nfloat rgb_2_hue(vec3 rgb) {\n    float hue;\n    if (((rgb[0] == rgb[1]) && (rgb[1] == rgb[2]))) {\n        (hue = float (0));\n    }\n    else {\n        (hue = ((180.000000 / 3.14159265359) * atan((sqrt(3.000000) * (rgb[1] - rgb[2])), (((2.000000 * rgb[0]) - rgb[1]) - rgb[2]))));\n    }\n    if ((hue < 0.000000)) {\n        (hue = (hue + 360.000000));\n    }\n    return clamp(hue, 0.000000, 360.000000);\n}\nfloat rgb_2_yc(vec3 rgb, float ycRadiusWeight) {\n    float r = rgb[0];\n    float g = rgb[1];\n    float b = rgb[2];\n    float chroma = sqrt((((b * (b - g)) + (g * (g - r))) + (r * (r - b))));\n    return ((((b + g) + r) + (ycRadiusWeight * chroma)) / 3.000000);\n}\nvec3 xyY_2_XYZ(vec3 xyY) {\n    vec3 XYZ;\n    (XYZ[0] = ((xyY[0] * xyY[2]) / max(xyY[1], 0.000000)));\n    (XYZ[1] = xyY[2]);\n    (XYZ[2] = ((((1.000000 - xyY[0]) - xyY[1]) * xyY[2]) / max(xyY[1], 0.000000)));\n    return XYZ;\n}\n mat3 ConeResponse = mat3(0.895100,(-0.750200),0.038900,0.266400,1.713500,(-0.068500),(-0.161400),0.036700,1.029600);\n mat3 InvConeResponse = mat3(0.986993,0.432305,(-0.008529),(-0.147054),0.518360,0.040043,0.159963,0.049291,0.968487);\nmat3 ChromaticAdaptation(vec2 src_xy, vec2 dst_xy) {\n    vec3 src_XYZ = xyY_2_XYZ(vec3(src_xy, 1));\n    vec3 dst_XYZ = xyY_2_XYZ(vec3(dst_xy, 1));\n    vec3 src_coneResp = (ConeResponse * src_XYZ);\n    vec3 dst_coneResp = (ConeResponse * dst_XYZ);\n    mat3 VonKriesMat = mat3(((dst_coneResp).x / (src_coneResp).x),0.000000,0.000000,0.000000,((dst_coneResp).y / (src_coneResp).y),0.000000,0.000000,0.000000,((dst_coneResp).z / (src_coneResp).z));\n    return (InvConeResponse * (VonKriesMat * ConeResponse));\n}\n float FilmSlope = 0.880000;\n float FilmToe = 0.550000;\n float FilmShoulder = 0.260000;\n float FilmBlackClip = float (0);\n float FilmWhiteClip = 0.040000;\nvec3 FilmToneMap(vec3 LinearColor) {\n    mat3 sRGB_2_AP0 = (XYZ_2_AP0_MAT * (D65_2_D60_CAT * sRGB_2_XYZ_MAT));\n    mat3 sRGB_2_AP1 = (XYZ_2_AP1_MAT * (D65_2_D60_CAT * sRGB_2_XYZ_MAT));\n    mat3 AP0_2_sRGB = (XYZ_2_sRGB_MAT * (D60_2_D65_CAT * AP0_2_XYZ_MAT));\n    mat3 AP1_2_sRGB = (XYZ_2_sRGB_MAT * (D60_2_D65_CAT * AP1_2_XYZ_MAT));\n    mat3 AP0_2_AP1 = (XYZ_2_AP1_MAT * AP0_2_XYZ_MAT);\n    mat3 AP1_2_AP0 = (XYZ_2_AP0_MAT * AP1_2_XYZ_MAT);\n    vec3 ColorAP1 = vec3 (LinearColor);\n    vec3 ColorAP0 = (AP1_2_AP0 * ColorAP1);\n    float RRT_GLOW_GAIN = 0.050000;\n    float RRT_GLOW_MID = 0.080000;\n    float saturation = rgb_2_saturation(ColorAP0);\n    float ycIn = rgb_2_yc(ColorAP0, 1.750000);\n    float s = sigmoid_shaper(((saturation - 0.400000) / 0.200000));\n    float addedGlow = (float (1) + glow_fwd(ycIn, (RRT_GLOW_GAIN * s), RRT_GLOW_MID));\n    (ColorAP0 *= vec3 (addedGlow));\n    float RRT_RED_SCALE = 0.820000;\n    float RRT_RED_PIVOT = 0.030000;\n    float RRT_RED_HUE = float (0);\n    float RRT_RED_WIDTH = float (135);\n    float hue = rgb_2_hue(ColorAP0);\n    float centeredHue = center_hue(hue, RRT_RED_HUE);\n    float hueWeight = Square(smoothstep(0.000000, 1.000000, (1.000000 - abs(((2.000000 * centeredHue) / RRT_RED_WIDTH)))));\n    ((ColorAP0).r += (((hueWeight * saturation) * (RRT_RED_PIVOT - (ColorAP0).r)) * (1.000000 - RRT_RED_SCALE)));\n    vec3 WorkingColor = (AP0_2_AP1_MAT * ColorAP0);\n    (WorkingColor = max(vec3 (0.000000), WorkingColor));\n    (WorkingColor = vec3 (mix(vec3 (dot(WorkingColor, AP1_RGB2Y)), vec3 (WorkingColor), vec3 (0.960000))));\n    float ToeScale = float (((1.000000 + FilmBlackClip) - FilmToe));\n    float ShoulderScale = float (((1.000000 + FilmWhiteClip) - FilmShoulder));\n    float InMatch = 0.180000;\n    float OutMatch = 0.180000;\n    float ToeMatch;\n    if ((FilmToe > 0.800000)) {\n        (ToeMatch = ((((float (1) - FilmToe) - OutMatch) / FilmSlope) + log10(InMatch)));\n    }\n    else {\n        float bt = (((OutMatch + FilmBlackClip) / ToeScale) - float (1));\n        (ToeMatch = (log10(InMatch) - ((0.500000 * log(((float (1) + bt) / (float (1) - bt)))) * (ToeScale / FilmSlope))));\n    }\n    float StraightMatch = (((float (1) - FilmToe) / FilmSlope) - ToeMatch);\n    float ShoulderMatch = ((FilmShoulder / FilmSlope) - StraightMatch);\n    vec3 LogColor = vec3 (log10(WorkingColor));\n    vec3 StraightColor = vec3 ((FilmSlope * (vec3 (LogColor) + vec3 (StraightMatch))));\n    vec3 ToeColor = vec3 ((vec3 ((-FilmBlackClip)) + ((2.000000 * ToeScale) / (vec3 (1.000000) + exp(((((-2.000000) * FilmSlope) / ToeScale) * (vec3 (LogColor) - vec3 (ToeMatch))))))));\n    vec3 ShoulderColor = vec3 ((vec3 ((1.000000 + FilmWhiteClip)) - ((2.000000 * ShoulderScale) / (vec3 (1.000000) + exp((((2.000000 * FilmSlope) / ShoulderScale) * (vec3 (LogColor) - vec3 (ShoulderMatch))))))));\n    (ToeColor = ((((((LogColor).r < ToeMatch) || ((LogColor).g < ToeMatch)) || ((LogColor).b < ToeMatch)))?(ToeColor):(StraightColor)));\n    (ShoulderColor = ((((((LogColor).r > ShoulderMatch) || ((LogColor).g > ShoulderMatch)) || ((LogColor).b > ShoulderMatch)))?(ShoulderColor):(StraightColor)));\n    vec3 t = vec3 (clamp(((vec3 (LogColor) - vec3 (ToeMatch)) / (ShoulderMatch - ToeMatch)), 0.0, 1.0));\n    (t = vec3 ((((ShoulderMatch < ToeMatch))?((vec3 (1.000000) - vec3 (t))):(t))));\n    (t = vec3 ((((vec3 (3.000000) - (2.000000 * t)) * t) * t)));\n    vec3 ToneColor = mix(ToeColor, ShoulderColor, t);\n    (ToneColor = mix(vec3 (dot(vec3(ToneColor), AP1_RGB2Y)), ToneColor, vec3 (0.930000)));\n    return vec3 (max(vec3 (0.000000), vec3 (ToneColor)));\n}\nmat3 OuputGamutMappingMatrix(int OutputGamut) {\n    mat3 AP1_2_sRGB = (XYZ_2_sRGB_MAT * (D60_2_D65_CAT * AP1_2_XYZ_MAT));\n    return AP1_2_sRGB;\n}\nvec3 LogToLin( vec3 LogColor )\n{\n  const float LinearRange = 14.;\n  const float LinearGrey = 0.18;\n  const float ExposureGrey = 444.;\n  vec3 LinearColor = exp2( ( LogColor - ExposureGrey / 1023.0 ) * LinearRange ) * LinearGrey;\n  return LinearColor;\n}\nfloat LinearToSrgbBranchingChannel(float lin)\n{\n  if(lin < 0.00313067) return lin * 12.92;\n  return pow(lin, (1.0/2.4)) * 1.055 - 0.055;\n}\nvec3 LinearToSrgbBranching(vec3 lin)\n{\n  return vec3(\n    LinearToSrgbBranchingChannel(lin.r),\n    LinearToSrgbBranchingChannel(lin.g),\n    LinearToSrgbBranchingChannel(lin.b));\n}\nvec3 LinearToSrgb(vec3 lin)\n{\n  return LinearToSrgbBranching(lin);\n}\n    uniform vec4 sync_CombineLutParam1;\nconst float LUTSize = 32.;\nconst int OutputGamut = 0;\nconst int OutputDevice = 0;\nint GetOutputDevice () {\n    return OutputDevice;\n}\nconst vec3 ColorScale = vec3(1.);\nconst vec4 OverlayColor = vec4(0.);\nconst vec3 InverseGamma = vec3(1./2.2, 2.2/2.2, 1./2.2);\nconst float BlueCorrection = 0.6;\nconst float ExpandGamut = 1.;\nconst vec3 MappingPolynomial = vec3(0., 1., 0.);\nvec3 ColorCorrection(vec3 InLDRColor)\n{\n  return MappingPolynomial.x * (InLDRColor * InLDRColor) + MappingPolynomial.y * InLDRColor + MappingPolynomial.z;\n}\nvec2 PlanckianIsothermal( float Temp, float Tint )\n{\n  float u = ( 0.860117757 + 1.54118254e-4 * Temp + 1.28641212e-7 * Temp*Temp ) / ( 1.0 + 8.42420235e-4 * Temp + 7.08145163e-7 * Temp*Temp );\n  float v = ( 0.317398726 + 4.22806245e-5 * Temp + 4.20481691e-8 * Temp*Temp ) / ( 1.0 - 2.89741816e-5 * Temp + 1.61456053e-7 * Temp*Temp );\n  float ud = ( -1.13758118e9 - 1.91615621e6 * Temp - 1.53177 * Temp*Temp ) / Square( 1.41213984e6 + 1189.62 * Temp + Temp*Temp );\n  float vd = (  1.97471536e9 - 705674.0 * Temp - 308.607 * Temp*Temp ) / Square( 6.19363586e6 - 179.456 * Temp + Temp*Temp );\n  vec2 uvd = normalize( vec2( u, v ) );\n  u += -uvd.y * Tint * 0.05;\n  v +=  uvd.x * Tint * 0.05;\n  float x = 3.*u / ( 2.*u - 8.*v + 4. );\n  float y = 2.*v / ( 2.*u - 8.*v + 4. );\n  return vec2(x,y);\n}\nvec2 D_IlluminantChromaticity( float Temp )\n{\n  Temp *= 1.4388 / 1.438;\n  float x =  Temp <= 7000. ?\n        0.244063 + ( 0.09911e3 + ( 2.9678e6 - 4.6070e9 / Temp ) / Temp ) / Temp :\n        0.237040 + ( 0.24748e3 + ( 1.9018e6 - 2.0064e9 / Temp ) / Temp ) / Temp;\n  float y = -3. * x*x + 2.87 * x - 0.275;\n  return vec2(x,y);\n}\nvec2 PlanckianLocusChromaticity( float Temp )\n{\n  float u = ( 0.860117757 + 1.54118254e-4 * Temp + 1.28641212e-7 * Temp*Temp ) / ( 1.0 + 8.42420235e-4 * Temp + 7.08145163e-7 * Temp*Temp );\n  float v = ( 0.317398726 + 4.22806245e-5 * Temp + 4.20481691e-8 * Temp*Temp ) / ( 1.0 - 2.89741816e-5 * Temp + 1.61456053e-7 * Temp*Temp );\n  float x = 3.*u / ( 2.*u - 8.*v + 4. );\n  float y = 2.*v / ( 2.*u - 8.*v + 4. );\n  return vec2(x,y);\n}\nvec3 WhiteBalance( vec3 LinearColor )\n{\n  float WhiteTemp = sync_CombineLutParam1.x;\n  float WhiteTint = sync_CombineLutParam1.y;\n  vec2 SrcWhiteDaylight = D_IlluminantChromaticity( WhiteTemp );\n  vec2 SrcWhitePlankian = PlanckianLocusChromaticity( WhiteTemp );\n  vec2 SrcWhite = WhiteTemp < 4000. ? SrcWhitePlankian : SrcWhiteDaylight;\n  vec2 D65White = vec2( 0.31270,  0.32900 );\n  {\n    vec2 Isothermal = PlanckianIsothermal( WhiteTemp, WhiteTint ) - SrcWhitePlankian;\n    SrcWhite += Isothermal;\n  }\n  mat3 WhiteBalanceMat = ChromaticAdaptation( SrcWhite, D65White );\n  WhiteBalanceMat = ( XYZ_2_sRGB_MAT * ( WhiteBalanceMat * sRGB_2_XYZ_MAT ) );\n  return ( WhiteBalanceMat * LinearColor );\n}\nconst mat3 BlueCorrect = mat3(0.9404372683,0.0083786969,0.0005471261,-0.0183068787,0.8286599939,-0.0008833746,0.0778696104,0.1629613092,1.0003362486);\nconst mat3 BlueCorrectInv = mat3(1.06318,-0.0106337,-0.000590887,0.0233956,1.20632,0.00105248,-0.0865726,-0.19569,0.999538);\nconst mat3 Wide_2_XYZ_MAT = mat3(0.5441691,0.2394656,-0.0023439,0.2395926,0.7021530,0.0361834,0.1666943,0.0583814,1.0552183);\nvec4 combineLuts (vec2 InUV) {\n    vec4 Neutral;\n  {\n    vec2 UV = InUV;\n    UV -= vec2(0.49999 / (LUTSize * LUTSize), 0.49999 / LUTSize);\n    float Scale = LUTSize / (LUTSize - 1.);\n    vec3 RGB;\n    RGB.r = fract(UV.x * LUTSize);\n    RGB.b = UV.x - RGB.r / LUTSize;\n    RGB.g = UV.y;\n    Neutral = vec4(RGB * Scale, 0.);\n  }\n    vec4 OutColor = vec4(0.);\n  mat3 sRGB_2_AP1 = ( XYZ_2_AP1_MAT * ( D65_2_D60_CAT * sRGB_2_XYZ_MAT ) );\n  mat3 AP1_2_sRGB = ( XYZ_2_sRGB_MAT * ( D60_2_D65_CAT * AP1_2_XYZ_MAT ) );\n  mat3 AP0_2_AP1 = ( XYZ_2_AP1_MAT * AP0_2_XYZ_MAT );\n  mat3 AP1_2_AP0 = ( XYZ_2_AP0_MAT * AP1_2_XYZ_MAT );\n  mat3 AP1_2_Output  = OuputGamutMappingMatrix( OutputGamut );\n    vec3 LUTEncodedColor = Neutral.rgb;\n  vec3 LinearColor;\n  if (GetOutputDevice() >= 3)\n  {\n  }\n  else {\n        LinearColor = LogToLin( LUTEncodedColor ) - LogToLin( vec3(0.) );\n    }\n    vec3 BalancedColor = WhiteBalance( LinearColor );\n  vec3 ColorAP1 = sRGB_2_AP1 * BalancedColor;\n  {\n    float  LumaAP1 = dot( ColorAP1, AP1_RGB2Y );\n    vec3 ChromaAP1 = ColorAP1 / LumaAP1;\n    float ChromaDistSqr = dot( ChromaAP1 - 1., ChromaAP1 - 1. );\n    float ExpandAmount = ( 1. - exp2( -4. * ChromaDistSqr ) ) * ( 1. - exp2( -4. * ExpandGamut * LumaAP1*LumaAP1 ) );\n    mat3 Wide_2_AP1 = XYZ_2_AP1_MAT * Wide_2_XYZ_MAT;\n    mat3 ExpandMat = Wide_2_AP1 * AP1_2_sRGB;\n    vec3 ColorExpand = ExpandMat * ColorAP1;\n    ColorAP1 = mix( ColorAP1, ColorExpand, ExpandAmount );\n  }\n  vec3 GradedColor = AP1_2_sRGB * ColorAP1;\n  mat3 BlueCorrectAP1    = ( AP0_2_AP1 * ( BlueCorrect *    AP1_2_AP0 ) );\n  mat3 BlueCorrectInvAP1 = ( AP0_2_AP1 * ( BlueCorrectInv * AP1_2_AP0 ) );\n  ColorAP1 = mix( ColorAP1, ( BlueCorrectAP1 * ColorAP1 ), BlueCorrection );\n  ColorAP1 = FilmToneMap( ColorAP1 );\n  ColorAP1 = mix( ColorAP1, ( BlueCorrectInvAP1 * ColorAP1 ), BlueCorrection );\n  vec3 FilmColor = max(vec3(0.), ( AP1_2_sRGB * ColorAP1 ));\n  FilmColor = ColorCorrection( FilmColor );\n  vec3 FilmColorNoGamma = mix( FilmColor * ColorScale, OverlayColor.rgb, OverlayColor.a );\n  FilmColor = pow( max(vec3(0.), FilmColorNoGamma), vec3(InverseGamma.y) );\n    vec3 OutDeviceColor = vec3(0.);\n  if( GetOutputDevice() == 0 )\n  {\n    vec3 OutputGamutColor = FilmColor;\n    OutDeviceColor = LinearToSrgb( OutputGamutColor );\n  }\n  OutColor.rgb = OutDeviceColor / 1.05;\n  OutColor.a = 1.;\n  return OutColor;\n}\n  varying vec2 v_uv;\n  void main () {\n    gl_FragColor = combineLuts(v_uv);\n  }"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]},{"name":"CCCamera","defines":[]}],"samplerTextures":[],"buffers":[],"images":[]},"locals":{"blocks":[{"name":"CCMorph","defines":["CC_USE_MORPH"]},{"name":"CCSkinningTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinningAnimation","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinning","defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION"]}],"samplerTextures":[{"name":"cc_PositionDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_POSITION"]},{"name":"cc_NormalDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_NORMAL"]},{"name":"cc_TangentDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_TANGENT"]},{"name":"cc_jointTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]}],"buffers":[],"images":[]},"statistics":{"CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS":147,"CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS":40}},"defines":[{"name":"CC_USE_MORPH","type":"boolean","defines":[]},{"name":"CC_MORPH_TARGET_COUNT","type":"number","defines":["CC_USE_MORPH"],"range":[2,8]},{"name":"CC_MORPH_PRECOMPUTED","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_POSITION","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_NORMAL","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_TANGENT","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_USE_SKINNING","type":"boolean","defines":[]},{"name":"CC_USE_BAKED_ANIMATION","type":"boolean","defines":["CC_USE_SKINNING"]},{"name":"USE_INSTANCING","type":"boolean","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]}]}],[{"passes":[{"program":"../resources/Exported/__builtin__/custom-deferred-combine-lut|vs|fs","blendState":{"targets":[{"blend":true,"blendSrc":2,"blendDst":4,"blendDstAlpha":4}]},"rasterizerState":{"cullMode":0},"depthStencilState":{"depthTest":false,"depthWrite":false},"properties":{"WhiteTemp":{"type":13,"value":[6500],"handleInfo":["sync_CombineLutParam1",0,13]},"WhiteTint":{"type":13,"value":[0],"handleInfo":["sync_CombineLutParam1",1,13]},"sync_CombineLutParam1":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[6500,0,0,0]}}}]}]]],0,0,[],[],[]]
