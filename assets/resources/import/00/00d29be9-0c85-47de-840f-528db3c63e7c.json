[1,0,0,[["cc.EffectAsset",["_name","shaders","techniques"],0]],[[0,0,1,2,4]],[[0,"../resources/Exported/__builtin__/custom-deferred-lighting",[{"hash":4259630791,"name":"../resources/Exported/__builtin__/custom-deferred-lighting|lighting-vs|lighting-fs","blocks":[],"samplerTextures":[{"name":"preIntegratedGF","type":28,"count":1,"stageFlags":16,"binding":4,"defines":[]},{"name":"ssao_map","type":28,"count":1,"stageFlags":16,"binding":5,"defines":[]}],"samplers":[],"textures":[],"buffers":[{"name":"b_ccLightsBuffer","memoryAccess":1,"stageFlags":16,"binding":6,"defines":["CC_ENABLE_CLUSTERED_LIGHT_CULLING","CC_ENABLE_Builtin_CLUSTERED_LIGHT_CULLING"]},{"name":"b_clusterLightIndicesBuffer","memoryAccess":1,"stageFlags":16,"binding":7,"defines":["CC_ENABLE_CLUSTERED_LIGHT_CULLING","CC_ENABLE_Builtin_CLUSTERED_LIGHT_CULLING"]},{"name":"b_clusterLightGridBuffer","memoryAccess":1,"stageFlags":16,"binding":8,"defines":["CC_ENABLE_CLUSTERED_LIGHT_CULLING","CC_ENABLE_Builtin_CLUSTERED_LIGHT_CULLING"]}],"images":[],"subpassInputs":[{"name":"gbuffer_albedoMap","count":1,"stageFlags":16,"binding":0,"defines":["CC_DEVICE_CAN_BENEFIT_FROM_INPUT_ATTACHMENT"]},{"name":"gbuffer_positionMap","count":1,"stageFlags":16,"binding":1,"defines":["CC_DEVICE_CAN_BENEFIT_FROM_INPUT_ATTACHMENT"]},{"name":"gbuffer_normalMap","count":1,"stageFlags":16,"binding":2,"defines":["CC_DEVICE_CAN_BENEFIT_FROM_INPUT_ATTACHMENT"]},{"name":"gbuffer_emissiveMap","count":1,"stageFlags":16,"binding":3,"defines":["CC_DEVICE_CAN_BENEFIT_FROM_INPUT_ATTACHMENT"]}],"attributes":[{"name":"a_position","format":32,"location":0,"defines":[]},{"name":"a_normal","format":32,"location":1,"defines":[]},{"name":"a_texCoord","format":21,"location":2,"defines":[]},{"name":"a_tangent","format":44,"location":3,"defines":[]}],"varyings":[{"name":"v_uv","type":14,"count":1,"stageFlags":17,"location":0,"defines":[]},{"name":"v_luv","type":15,"count":1,"stageFlags":16,"location":1,"defines":["CC_USE_LIGHTMAP","!USE_BATCHING","!CC_FORWARD_ADD"]},{"name":"v_lightingMapAdds0","type":16,"count":1,"stageFlags":16,"location":2,"defines":["CC_USE_LIGHTMAP","!USE_BATCHING","!CC_FORWARD_ADD","USE_INSTANCING"]},{"name":"v_lightingMapAdds1","type":16,"count":1,"stageFlags":16,"location":3,"defines":["CC_USE_LIGHTMAP","!USE_BATCHING","!CC_FORWARD_ADD","USE_INSTANCING"]},{"name":"v_lightingMapScales0","type":16,"count":1,"stageFlags":16,"location":4,"defines":["CC_USE_LIGHTMAP","!USE_BATCHING","!CC_FORWARD_ADD","USE_INSTANCING"]},{"name":"v_lightingMapScales1","type":16,"count":1,"stageFlags":16,"location":5,"defines":["CC_USE_LIGHTMAP","!USE_BATCHING","!CC_FORWARD_ADD","USE_INSTANCING"]}],"fragColors":[{"name":"fragColor","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":0,"tags":[],"defines":[]}],"glsl4":{"vert":"\nprecision highp float;\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec3 a_normal;\nlayout(location = 2) in vec2 a_texCoord;\nlayout(location = 3) in vec4 a_tangent;\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nlayout(location = 0) out vec2 v_uv;\nvoid main () {\n  vec4 position;\n    position = vec4(a_position, 1.0);\n  position.xy = cc_cameraPos.w == 0.0 ? vec2(position.xy.x, -position.xy.y) : position.xy;\n  gl_Position = vec4(position.x, position.y, 1.0, 1.0);\n  v_uv = a_texCoord;\n}","frag":"\n  precision highp float;\n  layout(set = 0, binding = 0) uniform CCGlobal {\n    highp   vec4 cc_time;\n    mediump vec4 cc_screenSize;\n    mediump vec4 cc_nativeSize;\n  };\n  layout(set = 0, binding = 1) uniform CCCamera {\n    highp   mat4 cc_matView;\n    highp   mat4 cc_matViewInv;\n    highp   mat4 cc_matProj;\n    highp   mat4 cc_matProjInv;\n    highp   mat4 cc_matViewProj;\n    highp   mat4 cc_matViewProjInv;\n    highp   vec4 cc_cameraPos;\n    mediump vec4 cc_screenScale;\n    mediump vec4 cc_exposure;\n    mediump vec4 cc_mainLitDir;\n    mediump vec4 cc_mainLitColor;\n    mediump vec4 cc_ambientSky;\n    mediump vec4 cc_ambientGround;\n    mediump vec4 cc_fogColor;\n    mediump vec4 cc_fogBase;\n    mediump vec4 cc_fogAdd;\n    mediump vec4 cc_nearFar;\n    mediump vec4 cc_viewPort;\n  };\n  layout(set = 0, binding = 2) uniform CCShadow {\n    highp mat4 cc_matLightPlaneProj;\n    highp mat4 cc_matLightView;\n    highp mat4 cc_matLightViewProj;\n    highp vec4 cc_shadowInvProjDepthInfo;\n    highp vec4 cc_shadowProjDepthInfo;\n    highp vec4 cc_shadowProjInfo;\n    lowp  vec4 cc_shadowNFLSInfo;\n    lowp  vec4 cc_shadowWHPBInfo;\n    lowp  vec4 cc_shadowLPNNInfo;\n    lowp  vec4 cc_shadowColor;\n  };\n  float CCGetLinearDepthFromViewSpace(vec3 viewPos) {\n    float dist = length(viewPos);\n    return (dist - cc_shadowNFLSInfo.x) / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x);\n  }\n  float CCGetLinearDepth(vec3 worldPos) {\n    vec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n    return CCGetLinearDepthFromViewSpace(viewStartPos.xyz);\n  }\n  #if CC_RECEIVE_SHADOW\n    layout(set = 0, binding = 3) uniform highp sampler2D cc_shadowMap;\n    layout(set = 0, binding = 5) uniform highp sampler2D cc_spotLightingMap;\n    vec4 ApplyShadowDepthBias_FaceNormal(vec4 shadowPos, vec3 worldNormal)\n    {\n      vec4 newShadowPos = shadowPos;\n      if(cc_shadowLPNNInfo.z > 0.0001)\n      {\n        vec4 viewNormal = cc_matLightView * vec4(worldNormal, 0.0);\n        if(viewNormal.z < 0.1)\n          newShadowPos.xy += viewNormal.xy * cc_shadowProjInfo.xy * cc_shadowLPNNInfo.z * clamp(viewNormal.z, 0.001, 0.1);\n      }\n      return newShadowPos;\n    }\n    vec4 ApplyShadowDepthBias_Perspective(vec4 shadowPos, float viewspaceDepthBias)\n    {\n      vec3 viewSpacePos;\n      viewSpacePos.xy = shadowPos.xy * cc_shadowProjInfo.zw;\n      viewSpacePos.z = shadowPos.z * cc_shadowInvProjDepthInfo.x + shadowPos.w * cc_shadowInvProjDepthInfo.y;\n      viewSpacePos.xyz += cc_shadowProjDepthInfo.z * normalize(viewSpacePos.xyz) * viewspaceDepthBias;\n      vec4 clipSpacePos;\n      clipSpacePos.xy = viewSpacePos.xy * cc_shadowProjInfo.xy;\n      clipSpacePos.zw = viewSpacePos.z * cc_shadowProjDepthInfo.xz + vec2(cc_shadowProjDepthInfo.y, 0.0);\n      if (cc_shadowNFLSInfo.z > 0.000001) {\n        clipSpacePos.z = CCGetLinearDepthFromViewSpace(viewSpacePos.xyz);\n        clipSpacePos.z = (clipSpacePos.z * 2.0 - 1.0) * clipSpacePos.w;\n      }\n      return clipSpacePos;\n    }\n    vec4 ApplyShadowDepthBias_Orthographic(vec4 shadowPos, float viewspaceDepthBias)\n    {\n      float coeffA = cc_shadowProjDepthInfo.x;\n      float coeffB = cc_shadowProjDepthInfo.y;\n      float viewSpacePos_z = (shadowPos.z - coeffB) / coeffA;\n      viewSpacePos_z += viewspaceDepthBias;\n      vec4 result = shadowPos;\n      result.z = viewSpacePos_z * coeffA + coeffB;\n      return result;\n    }\n    float CCGetShadowFactorHard (vec4 shadowPos) {\n      vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, cc_shadowWHPBInfo.w);\n      vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n      if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n          clipPos.y < 0.0 || clipPos.y > 1.0 ||\n          clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n      clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n      float shadow = 0.0;\n      float closestDepth = 0.0;\n      if (cc_shadowLPNNInfo.y > 0.000001) {\n        closestDepth = dot(texture(cc_shadowMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n      } else {\n        closestDepth = texture(cc_shadowMap, clipPos.xy).x;\n      }\n      shadow = step(clipPos.z, closestDepth);\n      return shadow;\n    }\n    float CCGetShadowFactorSoft (vec4 shadowPos) {\n      vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, cc_shadowWHPBInfo.w);\n      vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n      if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n          clipPos.y < 0.0 || clipPos.y > 1.0 ||\n          clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n      clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n      float offsetDepth = clipPos.z;\n      vec2 mapSize = cc_shadowWHPBInfo.xy;\n      vec2 oneTap = 1.0 / mapSize;\n      vec2 clipPos_offset = clipPos.xy + oneTap;\n      float block0, block1, block2, block3;\n      if (cc_shadowLPNNInfo.y > 0.000001) {\n        block0 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block1 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block2 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block3 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      } else {\n        block0 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\n        block1 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)).x);\n        block2 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)).x);\n        block3 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);\n      }\n      float coefX   = mod(clipPos.x, oneTap.x) * mapSize.x;\n      float resultX = mix(block0, block1, coefX);\n      float resultY = mix(block2, block3, coefX);\n      float coefY   = mod(clipPos.y, oneTap.y) * mapSize.y;\n      return mix(resultX, resultY, coefY);\n    }\n    float CCGetShadowFactorSoft2X (vec4 shadowPos) {\n      vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, cc_shadowWHPBInfo.w);\n      vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n      if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n          clipPos.y < 0.0 || clipPos.y > 1.0 ||\n          clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n      clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n      float offsetDepth = clipPos.z;\n      vec2 mapSize = cc_shadowWHPBInfo.xy;\n      vec2 oneTap = 1.0 / mapSize;\n      float clipPos_offset_L = clipPos.x - oneTap.x;\n      float clipPos_offset_R = clipPos.x + oneTap.x;\n      float clipPos_offset_U = clipPos.y - oneTap.y;\n      float clipPos_offset_D = clipPos.y + oneTap.y;\n      float block0, block1, block2, block3, block4, block5, block6, block7, block8;\n      if (cc_shadowLPNNInfo.y > 0.000001) {\n        block0 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block1 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block2 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block3 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block4 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block5 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block6 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block7 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block8 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      } else {\n        block0 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);\n        block1 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)).x);\n        block2 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);\n        block3 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)).x);\n        block4 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\n        block5 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)).x);\n        block6 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);\n        block7 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)).x);\n        block8 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);\n      }\n      float coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\n      float coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\n      float shadow = 0.0;\n      float resultX = mix(block0, block1, coefX);\n      float resultY = mix(block3, block4, coefX);\n      shadow += mix(resultX , resultY, coefY);\n      resultX = mix(block1, block2, coefX);\n      resultY = mix(block4, block5, coefX);\n      shadow += mix(resultX , resultY, coefY);\n      resultX = mix(block3, block4, coefX);\n      resultY = mix(block6, block7, coefX);\n      shadow += mix(resultX, resultY, coefY);\n      resultX = mix(block4, block5, coefX);\n      resultY = mix(block7, block8, coefX);\n      shadow += mix(resultX, resultY, coefY);\n      return shadow * 0.25;\n    }\n    float CCGetSpotLightShadowFactorHard (vec4 shadowPos, vec3 worldPos) {\n      vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, cc_shadowWHPBInfo.w);\n      vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n      if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n          clipPos.y < 0.0 || clipPos.y > 1.0 ||\n          clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n      clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n      float shadow = 0.0;\n      float closestDepth = 0.0;\n      float depth = clipPos.z;\n      if (cc_shadowLPNNInfo.y > 0.000001) {\n        closestDepth = dot(texture(cc_spotLightingMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n      } else {\n        closestDepth = texture(cc_spotLightingMap, clipPos.xy).x;\n      }\n      shadow = step(depth, closestDepth);\n      return shadow;\n    }\n    float CCGetSpotLightShadowFactorSoft (vec4 shadowPos, vec3 worldPos) {\n      vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, cc_shadowWHPBInfo.w);\n      vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n      if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n          clipPos.y < 0.0 || clipPos.y > 1.0 ||\n          clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n      clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n      float depth = 0.0;\n      if (cc_shadowNFLSInfo.z > 0.000001) {\n        depth = CCGetLinearDepth(worldPos);\n      } else {\n        depth = clipPos.z;\n      }\n      float bias = cc_shadowWHPBInfo.w;\n      vec2 oneTap = 1.0 / cc_shadowWHPBInfo.xy;\n      vec2 clipPos_offset = clipPos.xy + oneTap;\n      float block0, block1, block2, block3;\n      if (cc_shadowLPNNInfo.y > 0.000001) {\n        block0 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block1 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block2 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block3 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      } else {\n        block0 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x);\n        block1 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos.y)).x);\n        block2 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset.y)).x);\n        block3 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);\n      }\n      float coefX   = mod(clipPos.x, oneTap.x) * cc_shadowWHPBInfo.x;\n      float resultX = mix(block0, block1, coefX);\n      float resultY = mix(block2, block3, coefX);\n      float coefY   = mod(clipPos.y, oneTap.y) * cc_shadowWHPBInfo.y;\n      return mix(resultX, resultY, coefY);\n    }\n    float CCGetSpotLightShadowFactorSoft2X (vec4 shadowPos, vec3 worldPos) {\n      vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, cc_shadowWHPBInfo.w);\n      vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n      if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n          clipPos.y < 0.0 || clipPos.y > 1.0 ||\n          clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n      clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n      float depth = 0.0;\n      if (cc_shadowNFLSInfo.z > 0.000001) {\n        depth = CCGetLinearDepth(worldPos);\n      } else {\n        depth = clipPos.z;\n      }\n      float bias = cc_shadowWHPBInfo.w;\n      vec2 mapSize = cc_shadowWHPBInfo.xy;\n      vec2 oneTap = 1.0 / mapSize;\n      float clipPos_offset_L = clipPos.x - oneTap.x;\n      float clipPos_offset_R = clipPos.x + oneTap.x;\n      float clipPos_offset_U = clipPos.y - oneTap.y;\n      float clipPos_offset_D = clipPos.y + oneTap.y;\n      float block0, block1, block2, block3, block4, block5, block6, block7, block8;\n      if (cc_shadowLPNNInfo.y > 0.000001) {\n        block0 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block1 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block2 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block3 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block4 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block5 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block6 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block7 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block8 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      } else {\n        block0 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);\n        block1 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_U)).x);\n        block2 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);\n        block3 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos.y)).x);\n        block4 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x);\n        block5 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos.y)).x);\n        block6 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);\n        block7 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_D)).x);\n        block8 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);\n      }\n      float coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\n      float coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\n      float shadow = 0.0;\n      float resultX = mix(block0, block1, coefX);\n      float resultY = mix(block3, block4, coefX);\n      shadow += mix(resultX , resultY, coefY);\n      resultX = mix(block1, block2, coefX);\n      resultY = mix(block4, block5, coefX);\n      shadow += mix(resultX , resultY, coefY);\n      resultX = mix(block3, block4, coefX);\n      resultY = mix(block6, block7, coefX);\n      shadow += mix(resultX, resultY, coefY);\n      resultX = mix(block4, block5, coefX);\n      resultY = mix(block7, block8, coefX);\n      shadow += mix(resultX, resultY, coefY);\n      return shadow * 0.25;\n    }\n  #endif\n  layout(location = 0) in vec2 v_uv;\n  #if CC_DEVICE_CAN_BENEFIT_FROM_INPUT_ATTACHMENT\n      layout(set = 1, binding = 0, input_attachment_index = 0) uniform subpassInput gbuffer_albedoMap;\n      layout(set = 1, binding = 1, input_attachment_index = 1) uniform subpassInput gbuffer_positionMap;\n      layout(set = 1, binding = 2, input_attachment_index = 2) uniform subpassInput gbuffer_normalMap;\n      layout(set = 1, binding = 3, input_attachment_index = 3) uniform subpassInput gbuffer_emissiveMap;\n  #else\n    layout(set = 1, binding = 0) uniform sampler2D gbuffer_albedoMap;\n    layout(set = 1, binding = 1) uniform sampler2D gbuffer_positionMap;\n    layout(set = 1, binding = 2) uniform sampler2D gbuffer_normalMap;\n    layout(set = 1, binding = 3) uniform sampler2D gbuffer_emissiveMap;\n  #endif\n  layout(set = 1, binding = 4) uniform sampler2D preIntegratedGF;\n  layout(set = 1, binding = 5) uniform sampler2D ssao_map;\nvec3 CCRGBE2Linear (vec4 rgbe) {\n    return rgbe.rgb * pow(1.1, rgbe.a * 255.0 - 128.0);\n}\nvec4 decodeCCRGBE (vec4 color) {\n  color.rgb = CCRGBE2Linear(color);\n  color.a = 1.;\n  return color;\n}\nfloat rsqrt (float x) {\n  return 1. / sqrt(x);\n}\nfloat Square(float v)\n{\n    return v * v;\n}\nlayout(set = 0, binding = 7) uniform CCCustomView {\n    mat4 cc_view_taa_prev_viewProj;\n    mat4 cc_view_inverse_transpose_mirror;\n    vec4 cc_view_pr_reflectionPlane;\n    vec4 cc_view_pr_parameters;\n    vec4 cc_view_SkyIrradianceEnvironmentMap[7];\n    vec4 cc_view_SkyColor;\n    vec4 cc_view_SkyLightParameters;\n    vec4 cc_view_IndirectLightingColorScale_Intensity;\n    vec4 cc_view_PreExposure;\n    vec4 cc_view_taa_params1;\n    vec4 cc_view_taa_params2;\n    vec4 cc_view_final_screen_params;\n    vec4 cc_ibl_cluster_BoundsMin;\n    vec4 cc_ibl_cluster_BoundsDelta;\n    vec4 cc_ibl_cluster_CellsDot;\n    vec4 cc_ibl_cluster_CellsMax;\n    vec4 cc_ibl_cluster_TextureSize;\n    vec4 cc_ibl_cluster_InfoTextureInvSize;\n    vec4 cc_ibl_cluster_CellsCountByBoundsSizeAndPixelsPerCell;\n    vec4 cc_light_cluster_BoundsMin;\n    vec4 cc_light_cluster_BoundsDelta;\n    vec4 cc_light_cluster_CellsDot;\n    vec4 cc_light_cluster_CellsMax;\n    vec4 cc_light_cluster_TextureSize;\n    vec4 cc_light_cluster_InfoTextureInvSize;\n    vec4 cc_light_cluster_CellsCountByBoundsSizeAndPixelsPerCell;\n    vec4 FogStruct_ExponentialFogParameters;\n    vec4 FogStruct_ExponentialFogColorParameter;\n    vec4 FogStruct_ExponentialFogParameters2;\n    vec4 FogStruct_ExponentialFogParameters3;\n    vec4 cc_global_parameters;\n};\nstruct GlobalView {\n    vec3 IndirectLightingColorScale;\n    float PreExposure;\n};\nvoid getGlobalView (out GlobalView View) {\n    View.IndirectLightingColorScale = cc_view_IndirectLightingColorScale_Intensity.rgb * cc_view_IndirectLightingColorScale_Intensity.w;\n    View.PreExposure = cc_view_PreExposure.x;\n}\nvec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {\n    return textureLod(tex, coord, lod);\n}\nvec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {\n    return textureLod(tex, coord, lod);\n}\nstruct Light {\n  vec3 color;\n  vec3 direction;\n};\nstruct FDirectLighting\n{\n  vec3 Diffuse;\n  vec3 Specular;\n};\nstruct FPixelMaterialInputs\n{\n  vec3 Normal;\n  vec3 EmissiveColor;\n  float Opacity;\n  float OpacityMask;\n  vec3 BaseColor;\n  float Metallic;\n  float Specular;\n  float Roughness;\n  float AmbientOcclusion;\n  float Anisotropy;\n  float Tangent;\n  float Refraction;\n  float PixelDepthOffset;\n  float ShadingModel;\n  float TwoSidedSign;\n  float RoughnessWithClamp;\n  vec3 DiffuseColor;\n  vec3 SpecularColor;\n  vec3 Subsurface;\n};\nstruct FMaterialPixelParameters {\n  float IndirectIrradiance;\n  vec2 TexCoords_0;\n  vec2 TexCoords_1;\n  vec4 VertexColor;\n  vec3 WorldNormal;\n  vec3 WorldTangent;\n  vec3 ReflectionVector;\n  vec3 CameraVector;\n  vec3 LightVector;\n  vec4 SvPosition;\n  vec4 ScreenPosition;\n  mat3 TangentToWorld;\n  vec3 AbsoluteWorldPosition;\n  vec3 ObjectWorldPosition;\n  vec2 LightmapUVs;\n  int PrimitiveId;\n};\nstruct FMaterialVertexParameters {\n  vec3 WorldPosition;\n  vec4 VertexColor;\n};\nfloat Luminance( vec3 LinearColor )\n{\n  return dot( LinearColor, vec3( 0.3, 0.59, 0.11 ) );\n}\nfloat ComputeReflectionCaptureMipFromRoughness(float Roughness, float CubemapMaxMip)\n{\n  float LevelFrom1x1 = 1.000001 - 1.2 * log2(Roughness);\n  return CubemapMaxMip - 1. - LevelFrom1x1;\n}\nlayout(set = 0, binding = 9) uniform samplerCube cc_ibl_map_sky;\nvec3 GetSkyLightReflection(vec3 ReflectionVector, float Roughness, out float OutSkyAverageBrightness) {\n  float AbsoluteSpecularMip = ComputeReflectionCaptureMipFromRoughness(Roughness, cc_view_SkyLightParameters.x);\n  vec3 Reflection = decodeCCRGBE(fragTextureLod(cc_ibl_map_sky, ReflectionVector, AbsoluteSpecularMip)).rgb;\n  OutSkyAverageBrightness = cc_view_SkyColor.w * Luminance( cc_view_SkyColor.rgb );\n  return Reflection * cc_view_SkyColor.rgb;\n}\nvec3 posWS2screen (vec3 posWS) {\n  vec4 res = cc_matViewProj * vec4(posWS, 1.);\n  res.xyz /= res.w;\n  res.xyz = res.xyz * 0.5 + 0.5;\n  return res.xyz;\n}\nfloat GGX_Mobile(float Roughness, float NoH, vec3 H, vec3 N)\n{\n    vec3 NxH = cross(N, H);\n    float OneMinusNoHSqr = dot(NxH, NxH);\n    float a = Roughness * Roughness;\n    float n = NoH * a;\n    float p = a / (OneMinusNoHSqr + n * n);\n    return p * p;\n}\nfloat CalcSpecular(float Roughness, float RoughnessWithClamp, float NoH, vec3 H, vec3 N)\n{\n  return (Roughness*0.25 + 0.25) * GGX_Mobile(RoughnessWithClamp, NoH, H, N);\n}\nFDirectLighting MobileIntegrateBxDF(FPixelMaterialInputs ShadingModelContext, vec3 N, vec3 H, float NoH)\n{\n  FDirectLighting Lighting;\n  Lighting.Specular = ShadingModelContext.SpecularColor * CalcSpecular(ShadingModelContext.Roughness, ShadingModelContext.RoughnessWithClamp, NoH, H, N);\n  Lighting.Diffuse = ShadingModelContext.DiffuseColor;\n  return Lighting;\n}\nvec3 EnvBRDF(sampler2D PreIntegratedGF, vec3 SpecularColor, float Roughness, float NoV ) {\n  vec2 AB = texture( PreIntegratedGF, vec2( NoV, Roughness )).rg;\n  vec3 GF = SpecularColor * AB.x + clamp(50.0 * SpecularColor.g, 0.0, 1.0) * AB.y;\n  return GF;\n}\nlayout(set = 0, binding = 10) uniform sampler2D cc_ibl_cluster_InfoTexture;\nlayout(set = 0, binding = 11) uniform sampler2D cc_ibl_cluster_Texture;\nlayout(set = 0, binding = 12) uniform sampler2D cc_ibl_cluster_CubemapAtlas;\nvec2 envMapEquirect(vec3 wcNormal) {\n  float phi = acos(-wcNormal.y);\n  float theta = atan(1. * wcNormal.x, wcNormal.z) + 3.14159265359;\n  vec2 uv = vec2(theta / 6.28318530718, 1. - phi / 3.14159265359);\n  return uv;\n}\nfloat ComputeMixingWeight(float IndirectIrradiance, float AverageBrightness, float Roughness)\n{\n  float MixingAlpha = smoothstep(0., 1., clamp(Roughness * 5.000001 + -0.5, 0.0, 1.0));\n  float MixingWeight = IndirectIrradiance / max(AverageBrightness, .0001);\n  MixingWeight = min(MixingWeight, 10000.000001);\n  return mix(1.0, MixingWeight, MixingAlpha);\n}\nvec3 GetLookupVectorForSphereCapture(vec3 ReflectionVector, vec3 WorldPosition, vec4 SphereCapturePositionAndRadius, float NormalizedDistanceToCapture, vec3 LocalCaptureOffset, inout float DistanceAlpha)\n{\n  vec3 ProjectedCaptureVector = ReflectionVector;\n  float ProjectionSphereRadius = SphereCapturePositionAndRadius.w;\n  float SphereRadiusSquared = ProjectionSphereRadius * ProjectionSphereRadius;\n  vec3 LocalPosition = WorldPosition - SphereCapturePositionAndRadius.xyz;\n  float LocalPositionSqr = dot(LocalPosition, LocalPosition);\n  vec3 QuadraticCoef;\n  QuadraticCoef.x = 1.;\n  QuadraticCoef.y = dot(ReflectionVector, LocalPosition);\n  QuadraticCoef.z = LocalPositionSqr - SphereRadiusSquared;\n  float Determinant = QuadraticCoef.y * QuadraticCoef.y - QuadraticCoef.z;\n  if (Determinant >= 0.)\n  {\n    float FarIntersection = sqrt(Determinant) - QuadraticCoef.y;\n    vec3 LocalIntersectionPosition = LocalPosition + FarIntersection * ReflectionVector;\n    ProjectedCaptureVector = normalize(LocalIntersectionPosition - LocalCaptureOffset);\n    float x = clamp(2.5 * NormalizedDistanceToCapture - 1.5, 0.0, 1.0);\n    DistanceAlpha = 1. - x*x*(3. - 2.*x);\n  }\n  return ProjectedCaptureVector;\n}\nvoid EvaluateClusterIBL(float iblIndex, FMaterialPixelParameters MaterialParameters, float mip, float IndirectIrradiance, inout vec4 ImageBasedReflections, inout vec2 CompositedAverageBrightness) {\n  float iblV = (iblIndex + 0.5) * cc_ibl_cluster_InfoTextureInvSize.y;\n  vec4 posRange = texture(cc_ibl_cluster_InfoTexture, vec2(0.5 * cc_ibl_cluster_InfoTextureInvSize.x, iblV));\n  float iblDistance = length(MaterialParameters.AbsoluteWorldPosition - posRange.xyz);\n  float DistanceAlpha = 0.;\n  vec3 ProjectedCaptureVector = MaterialParameters.ReflectionVector;\n  if (iblDistance < posRange.w) {\n    float NormalizedDistanceToCapture = clamp(iblDistance / posRange.w, 0.0, 1.0);\n    ProjectedCaptureVector = GetLookupVectorForSphereCapture(ProjectedCaptureVector, MaterialParameters.AbsoluteWorldPosition, posRange, NormalizedDistanceToCapture, vec3(0.0), DistanceAlpha);\n  }\n  vec4 data3 = texture(cc_ibl_cluster_InfoTexture, vec2(2.5 * cc_ibl_cluster_InfoTextureInvSize.x, iblV));\n  float AverageBrightness = data3.x;\n  float brightness = data3.y;\n  vec2 uv = envMapEquirect(ProjectedCaptureVector);\n  vec4 uvMapping = texture(cc_ibl_cluster_InfoTexture, vec2(1.5 * cc_ibl_cluster_InfoTextureInvSize.x, iblV));\n  vec2 scaleUV = vec2(uvMapping.z, uvMapping.w * 0.5);\n  vec2 rgbUV = uvMapping.xy + scaleUV * uv;\n  vec2 aUV = uvMapping.xy + scaleUV * vec2(uv.x, uv.y + 1.);\n  vec4 SpecularIBL = decodeCCRGBE(fragTextureLod(cc_ibl_cluster_CubemapAtlas, rgbUV, mip));\n  float pixelBrightness = decodeCCRGBE(fragTextureLod(cc_ibl_cluster_CubemapAtlas, aUV, mip)).r;\n  ImageBasedReflections.rgb += SpecularIBL.rgb * brightness * DistanceAlpha * ImageBasedReflections.a;\n  ImageBasedReflections.a *= 1. - (pixelBrightness * DistanceAlpha);\n  CompositedAverageBrightness.x += AverageBrightness * DistanceAlpha * CompositedAverageBrightness.y;\n  CompositedAverageBrightness.y *= 1. - DistanceAlpha;\n}\nvoid EvalCluster (float clusterU, float clusterV, in FMaterialPixelParameters MaterialParameters, float mip, float IndirectIrradiance, inout vec4 ImageBasedReflections, vec2 CompositedAverageBrightness) {\n  #if CC_IBL_MaxPixelsPerCell\n    int calcedIblCount = 0;\n    for (float pixelIndex = 0.5; pixelIndex < float(CC_IBL_MaxPixelsPerCell); pixelIndex++) {\n      vec4 iblIndices = texture(cc_ibl_cluster_Texture, vec2(cc_ibl_cluster_TextureSize.y * (clusterU + pixelIndex), clusterV));\n      vec4 indices = iblIndices * 255.0;\n      for (int e = 0; e < 4; e++) {\n        float iblIndex = indices[e];\n        if (iblIndex <= 0.0)\n          break;\n          EvaluateClusterIBL(iblIndex, MaterialParameters, mip, IndirectIrradiance, ImageBasedReflections, CompositedAverageBrightness);\n      }\n    }\n  #endif\n}\nfloat GetSpecularOcclusion(float NoV, float RoughnessSq, float AO)\n{\n  return clamp(pow( NoV + AO, RoughnessSq ) - 1. + AO, 0.0, 1.0);\n}\nvec3 GetOffSpecularPeakReflectionDir(vec3 Normal, vec3 ReflectionVector, float Roughness)\n{\n  float a = Square(Roughness);\n  return mix( Normal, ReflectionVector, (1. - a) * ( sqrt(1. - a) + a ) );\n}\nlayout(set = 0, binding = 15) uniform sampler2D cc_planar_reflection_Texture;\nvec4 GetPlanarReflection (FMaterialPixelParameters MaterialParameters, GlobalView View) {\n  vec4 planarReflection = vec4(0.);\n  float DistanceFade = 1. - clamp(abs(MaterialParameters.AbsoluteWorldPosition.y) / 0.1, 0.0, 1.0);\n  if (DistanceFade > 0.) {\n    vec3 CameraToPixel = -MaterialParameters.CameraVector;\n    vec3 MirroredCameraVector = reflect(CameraToPixel, -cc_view_pr_reflectionPlane.xyz);\n    vec3 MirroredNormal = (cc_view_inverse_transpose_mirror * vec4(MaterialParameters.WorldNormal, 0.)).xyz;\n    vec3 MirroredReflectionVectorOffNormal = reflect(MirroredCameraVector, MirroredNormal);\n    vec3 VirtualReflectionSpherePosition = MaterialParameters.AbsoluteWorldPosition + MirroredReflectionVectorOffNormal * cc_view_pr_parameters.y;\n    vec2 screenUV = posWS2screen(VirtualReflectionSpherePosition.rgb).xy;\n    planarReflection = texture(cc_planar_reflection_Texture, screenUV * cc_view_pr_parameters.x);\n    planarReflection.a *= DistanceFade;\n    planarReflection.rgb /= View.PreExposure;\n  }\n  return planarReflection;\n}\nvec3 GetImageBasedReflectionLighting(FMaterialPixelParameters MaterialParameters, FPixelMaterialInputs ShadingModelContext, float IndirectIrradiance, GlobalView View) {\n  float Roughness = ShadingModelContext.Roughness;\n  float RoughnessSq = Roughness * Roughness;\n  float NoV = max(dot(MaterialParameters.WorldNormal, MaterialParameters.CameraVector), 0.);\n  float AO = ShadingModelContext.AmbientOcclusion;\n  float SpecularOcclusion = GetSpecularOcclusion(NoV, RoughnessSq, AO);\n  vec2 CompositedAverageBrightness = vec2(0.0, 1.0);\n  vec4 ImageBasedReflections = vec4(vec3(0.), SpecularOcclusion);\n  vec3 ReflectionVector = 2. * dot( MaterialParameters.CameraVector, MaterialParameters.WorldNormal ) * MaterialParameters.WorldNormal - MaterialParameters.CameraVector;\n  ReflectionVector = GetOffSpecularPeakReflectionDir(MaterialParameters.WorldNormal, ReflectionVector, Roughness);\n  MaterialParameters.ReflectionVector = ReflectionVector;\n  if (ImageBasedReflections.a > 0.) {\n    vec4 planarReflection = GetPlanarReflection(MaterialParameters, View);\n    ImageBasedReflections.rgb += planarReflection.rgb * ImageBasedReflections.a;\n    ImageBasedReflections.a -= planarReflection.a;\n  }\n  vec3 cellCoords = floor((MaterialParameters.AbsoluteWorldPosition - cc_ibl_cluster_BoundsMin.xyz) * cc_ibl_cluster_CellsCountByBoundsSizeAndPixelsPerCell.xyz);\n  if (ImageBasedReflections.a <= 0. || (cellCoords.x < 0.) || (cellCoords.y < 0.) || (cellCoords.z < 0.) ||\n      (cellCoords.x > cc_ibl_cluster_CellsMax.x) || (cellCoords.y > cc_ibl_cluster_CellsMax.y) || (cellCoords.z > cc_ibl_cluster_CellsMax.z)) {\n  }\n  else {\n    float mip = ComputeReflectionCaptureMipFromRoughness(Roughness, 7.000001);\n    float cellIndex = dot(cc_ibl_cluster_CellsDot.xyz, cellCoords);\n    float clusterV = floor(cellIndex * cc_ibl_cluster_TextureSize.y);\n    float clusterU = floor(cellIndex - (clusterV * cc_ibl_cluster_TextureSize.x));\n    clusterV = (clusterV + 0.5) * cc_ibl_cluster_TextureSize.z;\n    EvalCluster(clusterU, clusterV, MaterialParameters, mip, IndirectIrradiance, ImageBasedReflections, CompositedAverageBrightness);\n  }\n  ImageBasedReflections.rgb *= View.IndirectLightingColorScale;\n  CompositedAverageBrightness.x *= Luminance( View.IndirectLightingColorScale );\n  if (ImageBasedReflections.a > 0.) {\n    float SkyAverageBrightness = 1.;\n    vec3 SkyLighting = GetSkyLightReflection(ReflectionVector, Roughness, SkyAverageBrightness);\n    ImageBasedReflections.rgb += ImageBasedReflections.a * SkyLighting;\n    CompositedAverageBrightness.x += SkyAverageBrightness * CompositedAverageBrightness.y;\n      ImageBasedReflections.rgb *= ComputeMixingWeight(IndirectIrradiance, CompositedAverageBrightness.x, Roughness);\n  }\n    vec3 brdf = EnvBRDF(preIntegratedGF, ShadingModelContext.SpecularColor, Roughness, NoV);\n  ImageBasedReflections.rgb *= brdf;\n  return ImageBasedReflections.rgb;\n}\n#if (CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD)\n    layout(location = 1) in vec3 v_luv;\n    layout(set = 2, binding = 10) uniform sampler2D cc_lightingMap;\n    #if USE_INSTANCING\n      layout(location = 2) in vec4 v_lightingMapAdds0;\n      layout(location = 3) in vec4 v_lightingMapAdds1;\n      layout(location = 4) in vec4 v_lightingMapScales0;\n      layout(location = 5) in vec4 v_lightingMapScales1;\n    #endif\n#endif\nvec4 lightingBase (FPixelMaterialInputs ShadingModelContext, FMaterialPixelParameters MaterialParameters, GlobalView View, vec4 shadowPos) {\n  vec3 Color = vec3(0);\n  #if CC_Lighting_Heavily\n    Color += vec3(0.1, 0, 0);\n  #else\n    vec3 direction = normalize(-cc_mainLitDir.xyz);\n    vec3 lightColor = cc_mainLitColor.rgb * cc_mainLitColor.w;\n    lightColor /= 3.14159265359;\n    float NoL = max(0., dot(MaterialParameters.WorldNormal, direction));\n    vec3 H = normalize(MaterialParameters.CameraVector + direction);\n    float NoH = max(0., dot(MaterialParameters.WorldNormal, H));\n    float Shadow = 1.;\n    #if CC_RECEIVE_SHADOW\n      if (cc_global_parameters.y != 0.) {\n          {\n            vec4 pos = ApplyShadowDepthBias_FaceNormal(shadowPos, MaterialParameters.WorldNormal);\n            float pcf = cc_shadowWHPBInfo.z;\n            if (pcf > 1.9) Shadow = CCGetShadowFactorSoft2X(pos);\n            else if (pcf > 0.9) Shadow = CCGetShadowFactorSoft(pos);\n            else Shadow = CCGetShadowFactorHard(pos);\n            Shadow = mix(Shadow, 1.0, cc_shadowNFLSInfo.w);\n          }\n      }\n    #endif\n    FDirectLighting Lighting = MobileIntegrateBxDF(ShadingModelContext, MaterialParameters.WorldNormal, H, NoH);\n    Color += (Shadow * NoL) * lightColor * (Lighting.Diffuse + Lighting.Specular );\n    float IndirectIrradiance = MaterialParameters.IndirectIrradiance * Shadow;\n    #if CC_ENABLE_IBL\n      vec3 SpecularIBL = GetImageBasedReflectionLighting(MaterialParameters, ShadingModelContext, IndirectIrradiance, View);\n      SpecularIBL *= min(Shadow * 2., 1.);\n      Color += SpecularIBL;\n    #endif\n    Color += ShadingModelContext.EmissiveColor;\n  #endif\n  return vec4(Color, ShadingModelContext.Opacity);\n}\n#if CC_FORWARD_ADD\n#if CC_PIPELINE_TYPE == 0\n# define LIGHTS_PER_PASS 1\n#else\n# define LIGHTS_PER_PASS 10\n#endif\n#if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\nlayout(set = 2, binding = 1) uniform CCForwardLight {\n  highp vec4 cc_lightPos[LIGHTS_PER_PASS];\n  vec4 cc_lightColor[LIGHTS_PER_PASS];\n  vec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];\n  vec4 cc_lightDir[LIGHTS_PER_PASS];\n};\n#endif\n#endif\nfloat SpotAttenuationMask(vec3 L, vec3 SpotDirection, vec2 SpotAngles)\n{\n  return clamp((dot(L, -SpotDirection) - SpotAngles.x) * SpotAngles.y, 0.0, 1.0);\n}\nfloat SpotAttenuation(vec3 L, vec3 SpotDirection, vec2 SpotAngles)\n{\n  float ConeAngleFalloff = Square(SpotAttenuationMask(L, SpotDirection, SpotAngles));\n  return ConeAngleFalloff;\n}\nvoid lightingAddPerLight(\n  in FPixelMaterialInputs ShadingModelContext, in FMaterialPixelParameters MaterialParameters,\n  vec3 pos, bool isSpotLight,\n  vec3 lightColor, float intensity,\n  float range, float spotAngle,\n  vec3 dir,\n  vec4 shadowPos,\n  inout vec3 outColor) {\n  vec3 toLight = pos - MaterialParameters.AbsoluteWorldPosition;\n  float distanceSqr = dot(toLight, toLight);\n  vec3 L = toLight * rsqrt(distanceSqr);\n  vec3 PointH = normalize(MaterialParameters.CameraVector + L);\n  float PointNoL = max(0., dot(MaterialParameters.WorldNormal, L));\n  float PointNoH = max(0., dot(MaterialParameters.WorldNormal, PointH));\n  float Attenuation;\n  {\n    Attenuation = 1. / ( distanceSqr + 0.01 );\n    float InvRadius = 1.0 / max(range, 0.01);\n    float LightRadiusMask = Square(clamp(1. - Square(distanceSqr * (InvRadius * InvRadius)), 0.0, 1.0));\n    Attenuation *= LightRadiusMask;\n  }\n  if (isSpotLight) {\n    vec3 SL = normalize(toLight);\n    float cosInner = 1.;\n    float cosOuter = spotAngle;\n    float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\n    vec2 SpotAngles = vec2(cosOuter, litAngleScale);\n    Attenuation *= SpotAttenuation(L, dir, SpotAngles);\n    float shadow = 1.;\n    #if CC_RECEIVE_SHADOW\n        {\n          vec4 pos = ApplyShadowDepthBias_FaceNormal(shadowPos, MaterialParameters.WorldNormal);\n          float pcf = cc_shadowWHPBInfo.z;\n          if (pcf > 1.9) shadow = CCGetShadowFactorSoft2X(pos);\n          else if (pcf > 0.9) shadow = CCGetShadowFactorSoft(pos);\n          else shadow = CCGetShadowFactorHard(pos);\n          shadow = mix(shadow, 1.0, cc_shadowNFLSInfo.w);\n        }\n    #endif\n    lightColor *= shadow;\n  }\n  FDirectLighting Lighting = MobileIntegrateBxDF(ShadingModelContext, MaterialParameters.WorldNormal, PointH, PointNoH);\n  outColor += min(vec3(65000.0), (Attenuation * PointNoL) * lightColor * intensity / 3.14159265359 * (Lighting.Diffuse + Lighting.Specular));\n}\nlayout(set = 0, binding = 13) uniform sampler2D cc_light_cluster_InfoTexture;\nlayout(set = 0, binding = 14) uniform sampler2D cc_light_cluster_Texture;\nvoid lightingCluster(float clusterIndex, in FPixelMaterialInputs ShadingModelContext, in FMaterialPixelParameters MaterialParameters, vec4 shadowPos, inout vec3 outColor) {\n  #if CC_Lighting_Heavily\n    outColor += vec3(0.1, 0, 0);\n  #else\n    float iblV = (clusterIndex + 0.5) * cc_light_cluster_InfoTextureInvSize.y;\n    vec4 lightPos = texture(cc_light_cluster_InfoTexture, vec2(0.5 * cc_light_cluster_InfoTextureInvSize.x, iblV));\n    vec4 lightColor = texture(cc_light_cluster_InfoTexture, vec2(1.5 * cc_light_cluster_InfoTextureInvSize.x, iblV));\n    vec4 lightSizeRangeAngle = texture(cc_light_cluster_InfoTexture, vec2(2.5 * cc_light_cluster_InfoTextureInvSize.x, iblV));\n    vec4 lightDir = texture(cc_light_cluster_InfoTexture, vec2(3.5 * cc_light_cluster_InfoTextureInvSize.x, iblV));\n    lightingAddPerLight(\n      ShadingModelContext, MaterialParameters,\n      lightPos.xyz, lightPos.w > 0.0,\n      lightColor.rgb, lightColor.w,\n      lightSizeRangeAngle.y, lightSizeRangeAngle.z,\n      lightDir.xyz,\n      shadowPos,\n      outColor\n    );\n  #endif\n}\n#if CC_ENABLE_CLUSTERED_LIGHT_CULLING && CC_ENABLE_Builtin_CLUSTERED_LIGHT_CULLING\n  float SmoothDistAtt (float distSqr, float invSqrAttRadius) {\n    float factor = distSqr * invSqrAttRadius;\n    float smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\n    return smoothFactor * smoothFactor;\n  }\n  float GetDistAtt (float distSqr, float invSqrAttRadius) {\n    float attenuation = 1.0 / max(distSqr, 0.01*0.01);\n    attenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\n    return attenuation;\n  }\n  float GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\n    float cd = dot(litDir, L);\n    float attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\n    return (attenuation * attenuation);\n  }\n  #if CC_USE_IBL\n    layout(set = 0, binding = 4) uniform samplerCube cc_environment;\n    #if CC_USE_DIFFUSEMAP\n      layout(set = 0, binding = 6) uniform samplerCube cc_diffuseMap;\n    #endif\n  #endif\n  float GGXMobile (float roughness, float NoH, vec3 H, vec3 N) {\n    vec3 NxH = cross(N, H);\n    float OneMinusNoHSqr = dot(NxH, NxH);\n    float a = roughness * roughness;\n    float n = NoH * a;\n    float p = a / (OneMinusNoHSqr + n * n);\n    return p * p;\n  }\n  float CalcSpecular (float roughness, float NoH, vec3 H, vec3 N) {\n    return (roughness * 0.25 + 0.25) * GGXMobile(roughness, NoH, H, N);\n  }\n  vec3 BRDFApprox (vec3 specular, float roughness, float NoV) {\n    const vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);\n    const vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);\n    vec4 r = roughness * c0 + c1;\n    float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\n    vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\n    AB.y *= clamp(50.0 * specular.g, 0.0, 1.0);\n    return specular * AB.x + AB.y;\n  }\n  #if USE_REFLECTION_DENOISE\n  #endif\n  struct StandardSurface {\n    vec4 albedo;\n    vec3 position;\n    vec3 normal;\n    vec3 emissive;\n    vec3 lightmap;\n    float lightmap_test;\n    float roughness;\n    float metallic;\n    float occlusion;\n  };\n  layout(set = 1, binding = 6) readonly buffer b_ccLightsBuffer { vec4 b_ccLights[]; };\n  layout(set = 1, binding = 7) readonly buffer b_clusterLightIndicesBuffer { uint b_clusterLightIndices[]; };\n  layout(set = 1, binding = 8) readonly buffer b_clusterLightGridBuffer { uvec4 b_clusterLightGrid[]; };\n  struct CCLight\n  {\n    vec4 cc_lightPos;\n    vec4 cc_lightColor;\n    vec4 cc_lightSizeRangeAngle;\n    vec4 cc_lightDir;\n  };\n  struct Cluster\n  {\n    vec3 minBounds;\n    vec3 maxBounds;\n  };\n  struct LightGrid\n  {\n    uint offset;\n    uint ccLights;\n  };\n  CCLight getCCLight(uint i)\n  {\n    CCLight light;\n    light.cc_lightPos = b_ccLights[4u * i + 0u];\n    light.cc_lightColor = b_ccLights[4u * i + 1u];\n    light.cc_lightSizeRangeAngle = b_ccLights[4u * i + 2u];\n    light.cc_lightDir = b_ccLights[4u * i + 3u];\n    return light;\n  }\n  LightGrid getLightGrid(uint cluster)\n  {\n    uvec4 gridvec = b_clusterLightGrid[cluster];\n    LightGrid grid;\n    grid.offset = gridvec.x;\n    grid.ccLights = gridvec.y;\n    return grid;\n  }\n  uint getGridLightIndex(uint start, uint offset)\n  {\n    return b_clusterLightIndices[start + offset];\n  }\n  uint getClusterZIndex(vec4 worldPos)\n  {\n    float scale = float(24) / log(cc_nearFar.y / cc_nearFar.x);\n    float bias = -(float(24) * log(cc_nearFar.x) / log(cc_nearFar.y / cc_nearFar.x));\n    float eyeDepth = -(cc_matView * worldPos).z;\n    uint zIndex = uint(max(log(eyeDepth) * scale + bias, 0.0));\n    return zIndex;\n  }\n  uint getClusterIndex(vec4 fragCoord, vec4 worldPos)\n  {\n    uint zIndex = getClusterZIndex(worldPos);\n    float clusterSizeX = ceil(cc_nativeSize.x / float(16));\n    float clusterSizeY = ceil(cc_nativeSize.y / float(8));\n    uvec3 indices = uvec3(uvec2(fragCoord.xy / vec2(clusterSizeX, clusterSizeY)), zIndex);\n    uint cluster = (16u * 8u) * indices.z + 16u * indices.y + indices.x;\n    return cluster;\n  }\n  vec4 CCClusterShadingAdditive (StandardSurface s, vec4 shadowPos) {\n    vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n    vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n    vec3 diffuseContrib = diffuse / 3.14159265359;\n    vec3 N = normalize(s.normal);\n    vec3 V = normalize(cc_cameraPos.xyz - s.position);\n    float NV = max(abs(dot(N, V)), 0.001);\n    specular = BRDFApprox(specular, s.roughness, NV);\n    vec3 finalColor = vec3(0.0);\n    uint cluster = getClusterIndex(gl_FragCoord, vec4(s.position, 1.0));\n    LightGrid grid = getLightGrid(cluster);\n    uint numLights = grid.ccLights;\n    for (uint i = 0u; i < 100u; i++) {\n      if (i >= numLights) break;\n      uint lightIndex = getGridLightIndex(grid.offset, i);\n      CCLight light = getCCLight(lightIndex);\n      vec3 SLU = light.cc_lightPos.xyz - s.position;\n      vec3 SL = normalize(SLU);\n      vec3 SH = normalize(SL + V);\n      float SNL = max(dot(N, SL), 0.001);\n      float SNH = max(dot(N, SH), 0.0);\n      float distSqr = dot(SLU, SLU);\n      float litRadius = light.cc_lightSizeRangeAngle.x;\n      float litRadiusSqr = litRadius * litRadius;\n      float illum = 3.14159265359 * (litRadiusSqr / max(litRadiusSqr , distSqr));\n      float attRadiusSqrInv = 1.0 / max(light.cc_lightSizeRangeAngle.y, 0.01);\n      attRadiusSqrInv *= attRadiusSqrInv;\n      float att = GetDistAtt(distSqr, attRadiusSqrInv);\n      vec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\n      if (light.cc_lightPos.w > 0.0) {\n        float cosInner = max(dot(-light.cc_lightDir.xyz, SL), 0.01);\n        float cosOuter = light.cc_lightSizeRangeAngle.z;\n        float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\n        float litAngleOffset = -cosOuter * litAngleScale;\n        att *= GetAngleAtt(SL, -light.cc_lightDir.xyz, litAngleScale, litAngleOffset);\n      }\n      vec3 lightColor = light.cc_lightColor.rgb;\n      float shadow = 1.0;\n      #if CC_RECEIVE_SHADOW\n        if (light.cc_lightPos.w > 0.0) {\n            {\n              float pcf = cc_shadowWHPBInfo.z;\n              if (pcf > 1.9) shadow = CCGetSpotLightShadowFactorSoft2X(shadowPos, s.position);\n              else if (pcf > 0.9) shadow = CCGetSpotLightShadowFactorSoft(shadowPos, s.position);\n              else shadow = CCGetSpotLightShadowFactorHard(shadowPos, s.position);\n            }\n        }\n      #endif\n      lightColor *= shadow;\n      finalColor += SNL * lightColor * light.cc_lightColor.w * illum * att * (diffuseContrib + lspec);\n    }\n    return vec4(finalColor, 0.0);\n  }\n#endif\nvec4 lightingAdd (in FPixelMaterialInputs ShadingModelContext, in FMaterialPixelParameters MaterialParameters, vec4 shadowPos) {\n  vec3 color = vec3(0.);\n  #if CC_ENABLE_CLUSTERED_LIGHT_CULLING && CC_ENABLE_Builtin_CLUSTERED_LIGHT_CULLING\n    StandardSurface s;\n    s.albedo.xyz = ShadingModelContext.BaseColor;\n    s.albedo.w = ShadingModelContext.Opacity;\n    s.metallic = ShadingModelContext.Metallic;\n    s.roughness = ShadingModelContext.Roughness;\n    s.normal = MaterialParameters.WorldNormal;\n    s.position = MaterialParameters.AbsoluteWorldPosition;\n    color = CCClusterShadingAdditive(s, shadowPos).rgb;\n  #else\n  vec3 cellCoords = floor((MaterialParameters.AbsoluteWorldPosition - cc_light_cluster_BoundsMin.xyz) * cc_light_cluster_CellsCountByBoundsSizeAndPixelsPerCell.xyz);\n  if ((cellCoords.x < 0.) || (cellCoords.y < 0.) || (cellCoords.z < 0.) ||\n      (cellCoords.x > cc_light_cluster_CellsMax.x) ||\n      (cellCoords.y > cc_light_cluster_CellsMax.y) ||\n      (cellCoords.z > cc_light_cluster_CellsMax.z)) {\n  }\n  else {\n    float cellIndex = dot(cc_light_cluster_CellsDot.xyz, cellCoords);\n    float clusterV = floor(cellIndex * cc_light_cluster_TextureSize.y);\n    float clusterU = cellIndex - (clusterV * cc_light_cluster_TextureSize.x);\n    clusterV = (clusterV + 0.5) * cc_light_cluster_TextureSize.z;\n    #if CC_LIGHT_MaxPixelsPerCell\n    for (float cellIndex = 0.5; cellIndex < float(CC_LIGHT_MaxPixelsPerCell); cellIndex++) {\n      vec4 lightIndices = texture(cc_light_cluster_Texture, vec2(cc_light_cluster_TextureSize.y * (clusterU + cellIndex), clusterV));\n      vec4 indices = lightIndices * 255.0;\n      for (int e = 0; e < 4; e++) {\n        if (indices[e] <= 0.0) {\n          break;\n        }\n        lightingCluster(indices[e], ShadingModelContext, MaterialParameters, shadowPos, color);\n      }\n      if (cellIndex > cc_light_cluster_CellsCountByBoundsSizeAndPixelsPerCell.w) {\n        break;\n      }\n    }\n    #endif\n  }\n  #endif\n  return vec4(color, ShadingModelContext.Opacity);\n}\nvoid InitShadingModelContext(inout FPixelMaterialInputs ShadingModelContext, FMaterialPixelParameters MaterialParameters) {\n  ShadingModelContext.RoughnessWithClamp = max(0.015625, ShadingModelContext.Roughness);\n  float NoV = max(dot(MaterialParameters.WorldNormal, MaterialParameters.CameraVector), 0.);\n  float DielectricSpecular = 0.08 * ShadingModelContext.Specular;\n  ShadingModelContext.DiffuseColor = ShadingModelContext.BaseColor - ShadingModelContext.BaseColor * ShadingModelContext.Metallic;\n  ShadingModelContext.SpecularColor = mix(0.08 * vec3(ShadingModelContext.Specular), ShadingModelContext.BaseColor, ShadingModelContext.Metallic);\n}\nvec4 lighting (FPixelMaterialInputs ShadingModelContext, FMaterialPixelParameters MaterialParameters, GlobalView View, vec4 shadowPos) {\n  vec4 color = vec4(vec3(0.), 1.);\n    #if CC_ENABLE_LIGHTING_BASE\n      color = lightingBase(ShadingModelContext, MaterialParameters, View, shadowPos);\n    #endif\n    #if CC_ENABLE_LIGHTING_ADD && (1 || 1)\n      color += lightingAdd(ShadingModelContext, MaterialParameters, shadowPos);\n    #endif\n  color *= ShadingModelContext.AmbientOcclusion;\n  return color;\n}\nconst float FLT_EPSILON = 0.001;\nconst float FLT_EPSILON2 = 0.01;\nfloat CalculateLineIntegralShared(float FogHeightFalloff, float RayDirectionZ, float RayOriginTerms)\n{\n  float Falloff = max(-127.0, FogHeightFalloff * RayDirectionZ);\n  float LineIntegral = ( 1.0 - exp2(-Falloff) ) / Falloff;\n  float LineIntegralTaylor = log(2.0) - ( 0.5 * (pow(2., log(2.0))) ) * Falloff;\n  return RayOriginTerms * ( abs(Falloff) > FLT_EPSILON2 ? LineIntegral : LineIntegralTaylor );\n}\nvec3 ComputeInscatteringColor(vec3 CameraToReceiver, float CameraToReceiverLength)\n{\n  vec3 Inscattering = FogStruct_ExponentialFogColorParameter.xyz;\n  return Inscattering;\n}\nvec4 GetExponentialHeightFog(vec3 WorldPositionRelativeToCamera, float ExcludeDistance)\n{\n  float MinFogOpacity = FogStruct_ExponentialFogColorParameter.w;\n  float MaxWorldObserverHeight = FogStruct_ExponentialFogParameters.z;\n  vec3 View_WorldCameraOrigin = cc_cameraPos.xyz;\n  vec3 WorldObserverOrigin = vec3(View_WorldCameraOrigin.x, min(View_WorldCameraOrigin.y, MaxWorldObserverHeight), View_WorldCameraOrigin.z);\n  vec3 CameraToReceiver = WorldPositionRelativeToCamera;\n  CameraToReceiver.y += View_WorldCameraOrigin.y - WorldObserverOrigin.y;\n  float CameraToReceiverLengthSqr = dot(CameraToReceiver, CameraToReceiver);\n  float CameraToReceiverLengthInv = rsqrt(CameraToReceiverLengthSqr);\n  float CameraToReceiverLength = CameraToReceiverLengthSqr * CameraToReceiverLengthInv;\n  vec3 CameraToReceiverNormalized = CameraToReceiver * CameraToReceiverLengthInv;\n  float RayOriginTerms = FogStruct_ExponentialFogParameters.x;\n  float RayOriginTermsSecond = FogStruct_ExponentialFogParameters2.x;\n  float RayLength = CameraToReceiverLength;\n  float RayDirectionZ = CameraToReceiver.y;\n  ExcludeDistance = max(ExcludeDistance, FogStruct_ExponentialFogParameters.w);\n  if (ExcludeDistance > 0.)\n  {\n    float ExcludeIntersectionTime = ExcludeDistance * CameraToReceiverLengthInv;\n    float CameraToExclusionIntersectionZ = ExcludeIntersectionTime * CameraToReceiver.y;\n    float ExclusionIntersectionZ = WorldObserverOrigin.y + CameraToExclusionIntersectionZ;\n    float ExclusionIntersectionToReceiverZ = CameraToReceiver.y - CameraToExclusionIntersectionZ;\n    RayLength = (1.0 - ExcludeIntersectionTime) * CameraToReceiverLength;\n    RayDirectionZ = ExclusionIntersectionToReceiverZ;\n    float Exponent = max(-127.0, FogStruct_ExponentialFogParameters.y * (ExclusionIntersectionZ - FogStruct_ExponentialFogParameters3.y));\n    RayOriginTerms = FogStruct_ExponentialFogParameters3.x * exp2(-Exponent);\n    float ExponentSecond = max(-127.0, FogStruct_ExponentialFogParameters2.y * (ExclusionIntersectionZ - FogStruct_ExponentialFogParameters2.w));\n    RayOriginTermsSecond = FogStruct_ExponentialFogParameters2.z * exp2(-ExponentSecond);\n  }\n  float ExponentialHeightLineIntegralShared = CalculateLineIntegralShared(FogStruct_ExponentialFogParameters.y, RayDirectionZ, RayOriginTerms) + CalculateLineIntegralShared(FogStruct_ExponentialFogParameters2.y, RayDirectionZ, RayOriginTermsSecond);\n  float ExponentialHeightLineIntegral = ExponentialHeightLineIntegralShared * RayLength;\n  vec3 InscatteringColor = ComputeInscatteringColor(CameraToReceiver, CameraToReceiverLength);\n  vec3 DirectionalInscattering = vec3(0.);\n  float ExpFogFactor = max(clamp(exp2(-ExponentialHeightLineIntegral), 0.0, 1.0), MinFogOpacity);\n  if (FogStruct_ExponentialFogParameters3.w > 0. && CameraToReceiverLength > FogStruct_ExponentialFogParameters3.w)\n  {\n    ExpFogFactor = 1.;\n    DirectionalInscattering = vec3(0.);\n  }\n    vec3 FogColor = (InscatteringColor) * (1. - ExpFogFactor) + DirectionalInscattering;\n  return vec4(FogColor, ExpFogFactor);\n}\nvec4 CalculateHeightFog(vec3 WorldPositionRelativeToCamera)\n{\n  vec3 WorldPosition = WorldPositionRelativeToCamera;\n  float ExcludeDistance = 0.;\n  vec4 FogInscatteringAndOpacity = GetExponentialHeightFog(WorldPositionRelativeToCamera, ExcludeDistance);\n  return FogInscatteringAndOpacity;\n}\n  #if !CC_DEVICE_CAN_BENEFIT_FROM_INPUT_ATTACHMENT || __VERSION__ >= 450\n    layout(location = 0) out vec4 fragColor;\n  #endif\n  const mat3 kernel9 = mat3(\n    0.0625, 0.125, 0.0625,\n    0.125, 0.25, 0.125,\n    0.0625, 0.125, 0.0625\n  );\n  vec4 gaussianBlur9(sampler2D Tex, vec2 UV, float Intensity) {\n    vec3 sum = vec3(0.);\n    vec2 offset = vec2(0.0);\n    const int size = 3;\n    const float start = floor(float(size) / 2.);\n    vec2 normalizedSize = vec2(1.0 / vec2(cc_screenSize.xy));\n    for (int u = 0; u < size; u++) {\n      for (int v = 0; v < size; v++) {\n        offset = normalizedSize * (vec2(u, v) - start) * Intensity;\n        sum += texture(Tex, UV + offset).rgb * kernel9[v][u];\n      }\n    }\n    return vec4(sum, texture(Tex, UV).a);\n  }\n  void main () {\n    #if CC_DEVICE_CAN_BENEFIT_FROM_INPUT_ATTACHMENT\n        vec4 albedoMap = subpassLoad(gbuffer_albedoMap);\n        vec4 positionMap = subpassLoad(gbuffer_positionMap);\n        vec4 normalMap = subpassLoad(gbuffer_normalMap);\n        vec4 emissiveMap = subpassLoad(gbuffer_emissiveMap);\n    #else\n      vec4 albedoMap = texture(gbuffer_albedoMap,v_uv);\n      vec4 positionMap = texture(gbuffer_positionMap,v_uv);\n      vec4 normalMap = texture(gbuffer_normalMap,v_uv);\n      vec4 emissiveMap = texture(gbuffer_emissiveMap,v_uv);\n    #endif\n    FMaterialPixelParameters Parameters;\n    Parameters.AbsoluteWorldPosition = positionMap.xyz;\n    Parameters.WorldNormal = normalMap.xyz;\n    Parameters.CameraVector = normalize(cc_cameraPos.xyz - Parameters.AbsoluteWorldPosition);\n    Parameters.ReflectionVector = normalize(reflect(-Parameters.CameraVector, Parameters.WorldNormal));\n    FPixelMaterialInputs PixelMaterialInputs;\n    PixelMaterialInputs.BaseColor = albedoMap.xyz;\n    PixelMaterialInputs.Opacity = albedoMap.w;\n    PixelMaterialInputs.Roughness = positionMap.w;\n    PixelMaterialInputs.Metallic = normalMap.w;\n    PixelMaterialInputs.EmissiveColor = emissiveMap.xyz;\n    Parameters.IndirectIrradiance = emissiveMap.w;\n    PixelMaterialInputs.AmbientOcclusion = 1.;\n    PixelMaterialInputs.Specular = 0.5;\n    float ssao = 1.;\n    if (cc_global_parameters.x != 0.) {\n      ssao = gaussianBlur9(ssao_map, v_uv, 3.0).r;\n    }\n    PixelMaterialInputs.AmbientOcclusion *= ssao;\n    InitShadingModelContext(PixelMaterialInputs, Parameters);\n    GlobalView View;\n    getGlobalView(View);\n    vec4 shadowPos;\n      shadowPos = cc_matLightViewProj * vec4(Parameters.AbsoluteWorldPosition, 1);\n    #if CC_ENABLE_LIGHTING\n      vec4 color = lighting(PixelMaterialInputs, Parameters, View, shadowPos);\n    #else\n      vec4 color = vec4(vec3(0.), 1.);\n    #endif\n    #if !CC_Lighting_Heavily\n      vec4 fogColor = CalculateHeightFog(Parameters.AbsoluteWorldPosition.xyz - cc_cameraPos.xyz);\n      color.rgb = color.rgb * fogColor.a + fogColor.rgb;\n      color.rgb *= View.PreExposure;\n    #endif\n    color.a = 1.;\n    #if CC_DEVICE_CAN_BENEFIT_FROM_INPUT_ATTACHMENT\n        fragColor = color;\n    #else\n      fragColor = color;\n    #endif\n  }"},"glsl3":{"vert":"\nprecision highp float;\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\nin vec4 a_tangent;\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nout vec2 v_uv;\nvoid main () {\n  vec4 position;\n    position = vec4(a_position, 1.0);\n  position.xy = cc_cameraPos.w == 0.0 ? vec2(position.xy.x, -position.xy.y) : position.xy;\n  gl_Position = vec4(position.x, position.y, 1.0, 1.0);\n  v_uv = a_texCoord;\n}","frag":"\n#ifdef GL_EXT_shader_framebuffer_fetch\n#extension GL_EXT_shader_framebuffer_fetch: enable\n#endif\n  precision highp float;\n  layout(std140) uniform CCGlobal {\n    highp   vec4 cc_time;\n    mediump vec4 cc_screenSize;\n    mediump vec4 cc_nativeSize;\n  };\n  layout(std140) uniform CCCamera {\n    highp   mat4 cc_matView;\n    highp   mat4 cc_matViewInv;\n    highp   mat4 cc_matProj;\n    highp   mat4 cc_matProjInv;\n    highp   mat4 cc_matViewProj;\n    highp   mat4 cc_matViewProjInv;\n    highp   vec4 cc_cameraPos;\n    mediump vec4 cc_screenScale;\n    mediump vec4 cc_exposure;\n    mediump vec4 cc_mainLitDir;\n    mediump vec4 cc_mainLitColor;\n    mediump vec4 cc_ambientSky;\n    mediump vec4 cc_ambientGround;\n    mediump vec4 cc_fogColor;\n    mediump vec4 cc_fogBase;\n    mediump vec4 cc_fogAdd;\n    mediump vec4 cc_nearFar;\n    mediump vec4 cc_viewPort;\n  };\n  layout(std140) uniform CCShadow {\n    highp mat4 cc_matLightPlaneProj;\n    highp mat4 cc_matLightView;\n    highp mat4 cc_matLightViewProj;\n    highp vec4 cc_shadowInvProjDepthInfo;\n    highp vec4 cc_shadowProjDepthInfo;\n    highp vec4 cc_shadowProjInfo;\n    lowp  vec4 cc_shadowNFLSInfo;\n    lowp  vec4 cc_shadowWHPBInfo;\n    lowp  vec4 cc_shadowLPNNInfo;\n    lowp  vec4 cc_shadowColor;\n  };\n  float CCGetLinearDepthFromViewSpace(vec3 viewPos) {\n    float dist = length(viewPos);\n    return (dist - cc_shadowNFLSInfo.x) / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x);\n  }\n  float CCGetLinearDepth(vec3 worldPos) {\n    vec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n    return CCGetLinearDepthFromViewSpace(viewStartPos.xyz);\n  }\n  #if CC_RECEIVE_SHADOW\n    uniform highp sampler2D cc_shadowMap;\n    uniform highp sampler2D cc_spotLightingMap;\n    vec4 ApplyShadowDepthBias_FaceNormal(vec4 shadowPos, vec3 worldNormal)\n    {\n      vec4 newShadowPos = shadowPos;\n      if(cc_shadowLPNNInfo.z > 0.0001)\n      {\n        vec4 viewNormal = cc_matLightView * vec4(worldNormal, 0.0);\n        if(viewNormal.z < 0.1)\n          newShadowPos.xy += viewNormal.xy * cc_shadowProjInfo.xy * cc_shadowLPNNInfo.z * clamp(viewNormal.z, 0.001, 0.1);\n      }\n      return newShadowPos;\n    }\n    vec4 ApplyShadowDepthBias_Perspective(vec4 shadowPos, float viewspaceDepthBias)\n    {\n      vec3 viewSpacePos;\n      viewSpacePos.xy = shadowPos.xy * cc_shadowProjInfo.zw;\n      viewSpacePos.z = shadowPos.z * cc_shadowInvProjDepthInfo.x + shadowPos.w * cc_shadowInvProjDepthInfo.y;\n      viewSpacePos.xyz += cc_shadowProjDepthInfo.z * normalize(viewSpacePos.xyz) * viewspaceDepthBias;\n      vec4 clipSpacePos;\n      clipSpacePos.xy = viewSpacePos.xy * cc_shadowProjInfo.xy;\n      clipSpacePos.zw = viewSpacePos.z * cc_shadowProjDepthInfo.xz + vec2(cc_shadowProjDepthInfo.y, 0.0);\n      if (cc_shadowNFLSInfo.z > 0.000001) {\n        clipSpacePos.z = CCGetLinearDepthFromViewSpace(viewSpacePos.xyz);\n        clipSpacePos.z = (clipSpacePos.z * 2.0 - 1.0) * clipSpacePos.w;\n      }\n      return clipSpacePos;\n    }\n    vec4 ApplyShadowDepthBias_Orthographic(vec4 shadowPos, float viewspaceDepthBias)\n    {\n      float coeffA = cc_shadowProjDepthInfo.x;\n      float coeffB = cc_shadowProjDepthInfo.y;\n      float viewSpacePos_z = (shadowPos.z - coeffB) / coeffA;\n      viewSpacePos_z += viewspaceDepthBias;\n      vec4 result = shadowPos;\n      result.z = viewSpacePos_z * coeffA + coeffB;\n      return result;\n    }\n    float CCGetShadowFactorHard (vec4 shadowPos) {\n      vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, cc_shadowWHPBInfo.w);\n      vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n      if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n          clipPos.y < 0.0 || clipPos.y > 1.0 ||\n          clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n      clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n      float shadow = 0.0;\n      float closestDepth = 0.0;\n      if (cc_shadowLPNNInfo.y > 0.000001) {\n        closestDepth = dot(texture(cc_shadowMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n      } else {\n        closestDepth = texture(cc_shadowMap, clipPos.xy).x;\n      }\n      shadow = step(clipPos.z, closestDepth);\n      return shadow;\n    }\n    float CCGetShadowFactorSoft (vec4 shadowPos) {\n      vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, cc_shadowWHPBInfo.w);\n      vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n      if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n          clipPos.y < 0.0 || clipPos.y > 1.0 ||\n          clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n      clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n      float offsetDepth = clipPos.z;\n      vec2 mapSize = cc_shadowWHPBInfo.xy;\n      vec2 oneTap = 1.0 / mapSize;\n      vec2 clipPos_offset = clipPos.xy + oneTap;\n      float block0, block1, block2, block3;\n      if (cc_shadowLPNNInfo.y > 0.000001) {\n        block0 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block1 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block2 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block3 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      } else {\n        block0 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\n        block1 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)).x);\n        block2 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)).x);\n        block3 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);\n      }\n      float coefX   = mod(clipPos.x, oneTap.x) * mapSize.x;\n      float resultX = mix(block0, block1, coefX);\n      float resultY = mix(block2, block3, coefX);\n      float coefY   = mod(clipPos.y, oneTap.y) * mapSize.y;\n      return mix(resultX, resultY, coefY);\n    }\n    float CCGetShadowFactorSoft2X (vec4 shadowPos) {\n      vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, cc_shadowWHPBInfo.w);\n      vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n      if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n          clipPos.y < 0.0 || clipPos.y > 1.0 ||\n          clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n      clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n      float offsetDepth = clipPos.z;\n      vec2 mapSize = cc_shadowWHPBInfo.xy;\n      vec2 oneTap = 1.0 / mapSize;\n      float clipPos_offset_L = clipPos.x - oneTap.x;\n      float clipPos_offset_R = clipPos.x + oneTap.x;\n      float clipPos_offset_U = clipPos.y - oneTap.y;\n      float clipPos_offset_D = clipPos.y + oneTap.y;\n      float block0, block1, block2, block3, block4, block5, block6, block7, block8;\n      if (cc_shadowLPNNInfo.y > 0.000001) {\n        block0 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block1 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block2 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block3 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block4 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block5 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block6 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block7 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block8 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      } else {\n        block0 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);\n        block1 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)).x);\n        block2 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);\n        block3 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)).x);\n        block4 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\n        block5 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)).x);\n        block6 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);\n        block7 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)).x);\n        block8 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);\n      }\n      float coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\n      float coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\n      float shadow = 0.0;\n      float resultX = mix(block0, block1, coefX);\n      float resultY = mix(block3, block4, coefX);\n      shadow += mix(resultX , resultY, coefY);\n      resultX = mix(block1, block2, coefX);\n      resultY = mix(block4, block5, coefX);\n      shadow += mix(resultX , resultY, coefY);\n      resultX = mix(block3, block4, coefX);\n      resultY = mix(block6, block7, coefX);\n      shadow += mix(resultX, resultY, coefY);\n      resultX = mix(block4, block5, coefX);\n      resultY = mix(block7, block8, coefX);\n      shadow += mix(resultX, resultY, coefY);\n      return shadow * 0.25;\n    }\n    float CCGetSpotLightShadowFactorHard (vec4 shadowPos, vec3 worldPos) {\n      vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, cc_shadowWHPBInfo.w);\n      vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n      if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n          clipPos.y < 0.0 || clipPos.y > 1.0 ||\n          clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n      clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n      float shadow = 0.0;\n      float closestDepth = 0.0;\n      float depth = clipPos.z;\n      if (cc_shadowLPNNInfo.y > 0.000001) {\n        closestDepth = dot(texture(cc_spotLightingMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n      } else {\n        closestDepth = texture(cc_spotLightingMap, clipPos.xy).x;\n      }\n      shadow = step(depth, closestDepth);\n      return shadow;\n    }\n    float CCGetSpotLightShadowFactorSoft (vec4 shadowPos, vec3 worldPos) {\n      vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, cc_shadowWHPBInfo.w);\n      vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n      if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n          clipPos.y < 0.0 || clipPos.y > 1.0 ||\n          clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n      clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n      float depth = 0.0;\n      if (cc_shadowNFLSInfo.z > 0.000001) {\n        depth = CCGetLinearDepth(worldPos);\n      } else {\n        depth = clipPos.z;\n      }\n      float bias = cc_shadowWHPBInfo.w;\n      vec2 oneTap = 1.0 / cc_shadowWHPBInfo.xy;\n      vec2 clipPos_offset = clipPos.xy + oneTap;\n      float block0, block1, block2, block3;\n      if (cc_shadowLPNNInfo.y > 0.000001) {\n        block0 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block1 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block2 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block3 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      } else {\n        block0 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x);\n        block1 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos.y)).x);\n        block2 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset.y)).x);\n        block3 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);\n      }\n      float coefX   = mod(clipPos.x, oneTap.x) * cc_shadowWHPBInfo.x;\n      float resultX = mix(block0, block1, coefX);\n      float resultY = mix(block2, block3, coefX);\n      float coefY   = mod(clipPos.y, oneTap.y) * cc_shadowWHPBInfo.y;\n      return mix(resultX, resultY, coefY);\n    }\n    float CCGetSpotLightShadowFactorSoft2X (vec4 shadowPos, vec3 worldPos) {\n      vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, cc_shadowWHPBInfo.w);\n      vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n      if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n          clipPos.y < 0.0 || clipPos.y > 1.0 ||\n          clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n      clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n      float depth = 0.0;\n      if (cc_shadowNFLSInfo.z > 0.000001) {\n        depth = CCGetLinearDepth(worldPos);\n      } else {\n        depth = clipPos.z;\n      }\n      float bias = cc_shadowWHPBInfo.w;\n      vec2 mapSize = cc_shadowWHPBInfo.xy;\n      vec2 oneTap = 1.0 / mapSize;\n      float clipPos_offset_L = clipPos.x - oneTap.x;\n      float clipPos_offset_R = clipPos.x + oneTap.x;\n      float clipPos_offset_U = clipPos.y - oneTap.y;\n      float clipPos_offset_D = clipPos.y + oneTap.y;\n      float block0, block1, block2, block3, block4, block5, block6, block7, block8;\n      if (cc_shadowLPNNInfo.y > 0.000001) {\n        block0 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block1 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block2 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block3 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block4 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block5 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block6 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block7 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block8 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      } else {\n        block0 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);\n        block1 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_U)).x);\n        block2 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);\n        block3 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos.y)).x);\n        block4 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x);\n        block5 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos.y)).x);\n        block6 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);\n        block7 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_D)).x);\n        block8 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);\n      }\n      float coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\n      float coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\n      float shadow = 0.0;\n      float resultX = mix(block0, block1, coefX);\n      float resultY = mix(block3, block4, coefX);\n      shadow += mix(resultX , resultY, coefY);\n      resultX = mix(block1, block2, coefX);\n      resultY = mix(block4, block5, coefX);\n      shadow += mix(resultX , resultY, coefY);\n      resultX = mix(block3, block4, coefX);\n      resultY = mix(block6, block7, coefX);\n      shadow += mix(resultX, resultY, coefY);\n      resultX = mix(block4, block5, coefX);\n      resultY = mix(block7, block8, coefX);\n      shadow += mix(resultX, resultY, coefY);\n      return shadow * 0.25;\n    }\n  #endif\n  in vec2 v_uv;\n  #if CC_DEVICE_CAN_BENEFIT_FROM_INPUT_ATTACHMENT\n      layout(location = 0) inout vec4 gbuffer_albedoMap;\n      layout(location = 1) inout vec4 gbuffer_positionMap;\n      layout(location = 2) inout vec4 gbuffer_normalMap;\n      layout(location = 3) inout vec4 gbuffer_emissiveMap;\n  #else\n    uniform sampler2D gbuffer_albedoMap;\n    uniform sampler2D gbuffer_positionMap;\n    uniform sampler2D gbuffer_normalMap;\n    uniform sampler2D gbuffer_emissiveMap;\n  #endif\n  uniform sampler2D preIntegratedGF;\n  uniform sampler2D ssao_map;\nvec3 CCRGBE2Linear (vec4 rgbe) {\n    return rgbe.rgb * pow(1.1, rgbe.a * 255.0 - 128.0);\n}\nvec4 decodeCCRGBE (vec4 color) {\n  color.rgb = CCRGBE2Linear(color);\n  color.a = 1.;\n  return color;\n}\nfloat rsqrt (float x) {\n  return 1. / sqrt(x);\n}\nfloat Square(float v)\n{\n    return v * v;\n}\nlayout(std140) uniform CCCustomView {\n    mat4 cc_view_taa_prev_viewProj;\n    mat4 cc_view_inverse_transpose_mirror;\n    vec4 cc_view_pr_reflectionPlane;\n    vec4 cc_view_pr_parameters;\n    vec4 cc_view_SkyIrradianceEnvironmentMap[7];\n    vec4 cc_view_SkyColor;\n    vec4 cc_view_SkyLightParameters;\n    vec4 cc_view_IndirectLightingColorScale_Intensity;\n    vec4 cc_view_PreExposure;\n    vec4 cc_view_taa_params1;\n    vec4 cc_view_taa_params2;\n    vec4 cc_view_final_screen_params;\n    vec4 cc_ibl_cluster_BoundsMin;\n    vec4 cc_ibl_cluster_BoundsDelta;\n    vec4 cc_ibl_cluster_CellsDot;\n    vec4 cc_ibl_cluster_CellsMax;\n    vec4 cc_ibl_cluster_TextureSize;\n    vec4 cc_ibl_cluster_InfoTextureInvSize;\n    vec4 cc_ibl_cluster_CellsCountByBoundsSizeAndPixelsPerCell;\n    vec4 cc_light_cluster_BoundsMin;\n    vec4 cc_light_cluster_BoundsDelta;\n    vec4 cc_light_cluster_CellsDot;\n    vec4 cc_light_cluster_CellsMax;\n    vec4 cc_light_cluster_TextureSize;\n    vec4 cc_light_cluster_InfoTextureInvSize;\n    vec4 cc_light_cluster_CellsCountByBoundsSizeAndPixelsPerCell;\n    vec4 FogStruct_ExponentialFogParameters;\n    vec4 FogStruct_ExponentialFogColorParameter;\n    vec4 FogStruct_ExponentialFogParameters2;\n    vec4 FogStruct_ExponentialFogParameters3;\n    vec4 cc_global_parameters;\n};\nstruct GlobalView {\n    vec3 IndirectLightingColorScale;\n    float PreExposure;\n};\nvoid getGlobalView (out GlobalView View) {\n    View.IndirectLightingColorScale = cc_view_IndirectLightingColorScale_Intensity.rgb * cc_view_IndirectLightingColorScale_Intensity.w;\n    View.PreExposure = cc_view_PreExposure.x;\n}\nvec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {\n    return textureLod(tex, coord, lod);\n}\nvec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {\n    return textureLod(tex, coord, lod);\n}\nstruct Light {\n  vec3 color;\n  vec3 direction;\n};\nstruct FDirectLighting\n{\n  vec3 Diffuse;\n  vec3 Specular;\n};\nstruct FPixelMaterialInputs\n{\n  vec3 Normal;\n  vec3 EmissiveColor;\n  float Opacity;\n  float OpacityMask;\n  vec3 BaseColor;\n  float Metallic;\n  float Specular;\n  float Roughness;\n  float AmbientOcclusion;\n  float Anisotropy;\n  float Tangent;\n  float Refraction;\n  float PixelDepthOffset;\n  float ShadingModel;\n  float TwoSidedSign;\n  float RoughnessWithClamp;\n  vec3 DiffuseColor;\n  vec3 SpecularColor;\n  vec3 Subsurface;\n};\nstruct FMaterialPixelParameters {\n  float IndirectIrradiance;\n  vec2 TexCoords_0;\n  vec2 TexCoords_1;\n  vec4 VertexColor;\n  vec3 WorldNormal;\n  vec3 WorldTangent;\n  vec3 ReflectionVector;\n  vec3 CameraVector;\n  vec3 LightVector;\n  vec4 SvPosition;\n  vec4 ScreenPosition;\n  mat3 TangentToWorld;\n  vec3 AbsoluteWorldPosition;\n  vec3 ObjectWorldPosition;\n  vec2 LightmapUVs;\n  int PrimitiveId;\n};\nstruct FMaterialVertexParameters {\n  vec3 WorldPosition;\n  vec4 VertexColor;\n};\nfloat Luminance( vec3 LinearColor )\n{\n  return dot( LinearColor, vec3( 0.3, 0.59, 0.11 ) );\n}\nfloat ComputeReflectionCaptureMipFromRoughness(float Roughness, float CubemapMaxMip)\n{\n  float LevelFrom1x1 = 1.000001 - 1.2 * log2(Roughness);\n  return CubemapMaxMip - 1. - LevelFrom1x1;\n}\nuniform samplerCube cc_ibl_map_sky;\nvec3 GetSkyLightReflection(vec3 ReflectionVector, float Roughness, out float OutSkyAverageBrightness) {\n  float AbsoluteSpecularMip = ComputeReflectionCaptureMipFromRoughness(Roughness, cc_view_SkyLightParameters.x);\n  vec3 Reflection = decodeCCRGBE(fragTextureLod(cc_ibl_map_sky, ReflectionVector, AbsoluteSpecularMip)).rgb;\n  OutSkyAverageBrightness = cc_view_SkyColor.w * Luminance( cc_view_SkyColor.rgb );\n  return Reflection * cc_view_SkyColor.rgb;\n}\nvec3 posWS2screen (vec3 posWS) {\n  vec4 res = cc_matViewProj * vec4(posWS, 1.);\n  res.xyz /= res.w;\n  res.xyz = res.xyz * 0.5 + 0.5;\n  return res.xyz;\n}\nfloat GGX_Mobile(float Roughness, float NoH, vec3 H, vec3 N)\n{\n    vec3 NxH = cross(N, H);\n    float OneMinusNoHSqr = dot(NxH, NxH);\n    float a = Roughness * Roughness;\n    float n = NoH * a;\n    float p = a / (OneMinusNoHSqr + n * n);\n    return p * p;\n}\nfloat CalcSpecular(float Roughness, float RoughnessWithClamp, float NoH, vec3 H, vec3 N)\n{\n  return (Roughness*0.25 + 0.25) * GGX_Mobile(RoughnessWithClamp, NoH, H, N);\n}\nFDirectLighting MobileIntegrateBxDF(FPixelMaterialInputs ShadingModelContext, vec3 N, vec3 H, float NoH)\n{\n  FDirectLighting Lighting;\n  Lighting.Specular = ShadingModelContext.SpecularColor * CalcSpecular(ShadingModelContext.Roughness, ShadingModelContext.RoughnessWithClamp, NoH, H, N);\n  Lighting.Diffuse = ShadingModelContext.DiffuseColor;\n  return Lighting;\n}\nvec3 EnvBRDF(sampler2D PreIntegratedGF, vec3 SpecularColor, float Roughness, float NoV ) {\n  vec2 AB = texture( PreIntegratedGF, vec2( NoV, Roughness )).rg;\n  vec3 GF = SpecularColor * AB.x + clamp(50.0 * SpecularColor.g, 0.0, 1.0) * AB.y;\n  return GF;\n}\nuniform sampler2D cc_ibl_cluster_InfoTexture;\nuniform sampler2D cc_ibl_cluster_Texture;\nuniform sampler2D cc_ibl_cluster_CubemapAtlas;\nvec2 envMapEquirect(vec3 wcNormal) {\n  float phi = acos(-wcNormal.y);\n  float theta = atan(1. * wcNormal.x, wcNormal.z) + 3.14159265359;\n  vec2 uv = vec2(theta / 6.28318530718, 1. - phi / 3.14159265359);\n  return uv;\n}\nfloat ComputeMixingWeight(float IndirectIrradiance, float AverageBrightness, float Roughness)\n{\n  float MixingAlpha = smoothstep(0., 1., clamp(Roughness * 5.000001 + -0.5, 0.0, 1.0));\n  float MixingWeight = IndirectIrradiance / max(AverageBrightness, .0001);\n  MixingWeight = min(MixingWeight, 10000.000001);\n  return mix(1.0, MixingWeight, MixingAlpha);\n}\nvec3 GetLookupVectorForSphereCapture(vec3 ReflectionVector, vec3 WorldPosition, vec4 SphereCapturePositionAndRadius, float NormalizedDistanceToCapture, vec3 LocalCaptureOffset, inout float DistanceAlpha)\n{\n  vec3 ProjectedCaptureVector = ReflectionVector;\n  float ProjectionSphereRadius = SphereCapturePositionAndRadius.w;\n  float SphereRadiusSquared = ProjectionSphereRadius * ProjectionSphereRadius;\n  vec3 LocalPosition = WorldPosition - SphereCapturePositionAndRadius.xyz;\n  float LocalPositionSqr = dot(LocalPosition, LocalPosition);\n  vec3 QuadraticCoef;\n  QuadraticCoef.x = 1.;\n  QuadraticCoef.y = dot(ReflectionVector, LocalPosition);\n  QuadraticCoef.z = LocalPositionSqr - SphereRadiusSquared;\n  float Determinant = QuadraticCoef.y * QuadraticCoef.y - QuadraticCoef.z;\n  if (Determinant >= 0.)\n  {\n    float FarIntersection = sqrt(Determinant) - QuadraticCoef.y;\n    vec3 LocalIntersectionPosition = LocalPosition + FarIntersection * ReflectionVector;\n    ProjectedCaptureVector = normalize(LocalIntersectionPosition - LocalCaptureOffset);\n    float x = clamp(2.5 * NormalizedDistanceToCapture - 1.5, 0.0, 1.0);\n    DistanceAlpha = 1. - x*x*(3. - 2.*x);\n  }\n  return ProjectedCaptureVector;\n}\nvoid EvaluateClusterIBL(float iblIndex, FMaterialPixelParameters MaterialParameters, float mip, float IndirectIrradiance, inout vec4 ImageBasedReflections, inout vec2 CompositedAverageBrightness) {\n  float iblV = (iblIndex + 0.5) * cc_ibl_cluster_InfoTextureInvSize.y;\n  vec4 posRange = texture(cc_ibl_cluster_InfoTexture, vec2(0.5 * cc_ibl_cluster_InfoTextureInvSize.x, iblV));\n  float iblDistance = length(MaterialParameters.AbsoluteWorldPosition - posRange.xyz);\n  float DistanceAlpha = 0.;\n  vec3 ProjectedCaptureVector = MaterialParameters.ReflectionVector;\n  if (iblDistance < posRange.w) {\n    float NormalizedDistanceToCapture = clamp(iblDistance / posRange.w, 0.0, 1.0);\n    ProjectedCaptureVector = GetLookupVectorForSphereCapture(ProjectedCaptureVector, MaterialParameters.AbsoluteWorldPosition, posRange, NormalizedDistanceToCapture, vec3(0.0), DistanceAlpha);\n  }\n  vec4 data3 = texture(cc_ibl_cluster_InfoTexture, vec2(2.5 * cc_ibl_cluster_InfoTextureInvSize.x, iblV));\n  float AverageBrightness = data3.x;\n  float brightness = data3.y;\n  vec2 uv = envMapEquirect(ProjectedCaptureVector);\n  vec4 uvMapping = texture(cc_ibl_cluster_InfoTexture, vec2(1.5 * cc_ibl_cluster_InfoTextureInvSize.x, iblV));\n  vec2 scaleUV = vec2(uvMapping.z, uvMapping.w * 0.5);\n  vec2 rgbUV = uvMapping.xy + scaleUV * uv;\n  vec2 aUV = uvMapping.xy + scaleUV * vec2(uv.x, uv.y + 1.);\n  vec4 SpecularIBL = decodeCCRGBE(fragTextureLod(cc_ibl_cluster_CubemapAtlas, rgbUV, mip));\n  float pixelBrightness = decodeCCRGBE(fragTextureLod(cc_ibl_cluster_CubemapAtlas, aUV, mip)).r;\n  ImageBasedReflections.rgb += SpecularIBL.rgb * brightness * DistanceAlpha * ImageBasedReflections.a;\n  ImageBasedReflections.a *= 1. - (pixelBrightness * DistanceAlpha);\n  CompositedAverageBrightness.x += AverageBrightness * DistanceAlpha * CompositedAverageBrightness.y;\n  CompositedAverageBrightness.y *= 1. - DistanceAlpha;\n}\nvoid EvalCluster (float clusterU, float clusterV, in FMaterialPixelParameters MaterialParameters, float mip, float IndirectIrradiance, inout vec4 ImageBasedReflections, vec2 CompositedAverageBrightness) {\n  #if CC_IBL_MaxPixelsPerCell\n    int calcedIblCount = 0;\n    for (float pixelIndex = 0.5; pixelIndex < float(CC_IBL_MaxPixelsPerCell); pixelIndex++) {\n      vec4 iblIndices = texture(cc_ibl_cluster_Texture, vec2(cc_ibl_cluster_TextureSize.y * (clusterU + pixelIndex), clusterV));\n      vec4 indices = iblIndices * 255.0;\n      for (int e = 0; e < 4; e++) {\n        float iblIndex = indices[e];\n        if (iblIndex <= 0.0)\n          break;\n          EvaluateClusterIBL(iblIndex, MaterialParameters, mip, IndirectIrradiance, ImageBasedReflections, CompositedAverageBrightness);\n      }\n    }\n  #endif\n}\nfloat GetSpecularOcclusion(float NoV, float RoughnessSq, float AO)\n{\n  return clamp(pow( NoV + AO, RoughnessSq ) - 1. + AO, 0.0, 1.0);\n}\nvec3 GetOffSpecularPeakReflectionDir(vec3 Normal, vec3 ReflectionVector, float Roughness)\n{\n  float a = Square(Roughness);\n  return mix( Normal, ReflectionVector, (1. - a) * ( sqrt(1. - a) + a ) );\n}\nuniform sampler2D cc_planar_reflection_Texture;\nvec4 GetPlanarReflection (FMaterialPixelParameters MaterialParameters, GlobalView View) {\n  vec4 planarReflection = vec4(0.);\n  float DistanceFade = 1. - clamp(abs(MaterialParameters.AbsoluteWorldPosition.y) / 0.1, 0.0, 1.0);\n  if (DistanceFade > 0.) {\n    vec3 CameraToPixel = -MaterialParameters.CameraVector;\n    vec3 MirroredCameraVector = reflect(CameraToPixel, -cc_view_pr_reflectionPlane.xyz);\n    vec3 MirroredNormal = (cc_view_inverse_transpose_mirror * vec4(MaterialParameters.WorldNormal, 0.)).xyz;\n    vec3 MirroredReflectionVectorOffNormal = reflect(MirroredCameraVector, MirroredNormal);\n    vec3 VirtualReflectionSpherePosition = MaterialParameters.AbsoluteWorldPosition + MirroredReflectionVectorOffNormal * cc_view_pr_parameters.y;\n    vec2 screenUV = posWS2screen(VirtualReflectionSpherePosition.rgb).xy;\n    planarReflection = texture(cc_planar_reflection_Texture, screenUV * cc_view_pr_parameters.x);\n    planarReflection.a *= DistanceFade;\n    planarReflection.rgb /= View.PreExposure;\n  }\n  return planarReflection;\n}\nvec3 GetImageBasedReflectionLighting(FMaterialPixelParameters MaterialParameters, FPixelMaterialInputs ShadingModelContext, float IndirectIrradiance, GlobalView View) {\n  float Roughness = ShadingModelContext.Roughness;\n  float RoughnessSq = Roughness * Roughness;\n  float NoV = max(dot(MaterialParameters.WorldNormal, MaterialParameters.CameraVector), 0.);\n  float AO = ShadingModelContext.AmbientOcclusion;\n  float SpecularOcclusion = GetSpecularOcclusion(NoV, RoughnessSq, AO);\n  vec2 CompositedAverageBrightness = vec2(0.0, 1.0);\n  vec4 ImageBasedReflections = vec4(vec3(0.), SpecularOcclusion);\n  vec3 ReflectionVector = 2. * dot( MaterialParameters.CameraVector, MaterialParameters.WorldNormal ) * MaterialParameters.WorldNormal - MaterialParameters.CameraVector;\n  ReflectionVector = GetOffSpecularPeakReflectionDir(MaterialParameters.WorldNormal, ReflectionVector, Roughness);\n  MaterialParameters.ReflectionVector = ReflectionVector;\n  if (ImageBasedReflections.a > 0.) {\n    vec4 planarReflection = GetPlanarReflection(MaterialParameters, View);\n    ImageBasedReflections.rgb += planarReflection.rgb * ImageBasedReflections.a;\n    ImageBasedReflections.a -= planarReflection.a;\n  }\n  vec3 cellCoords = floor((MaterialParameters.AbsoluteWorldPosition - cc_ibl_cluster_BoundsMin.xyz) * cc_ibl_cluster_CellsCountByBoundsSizeAndPixelsPerCell.xyz);\n  if (ImageBasedReflections.a <= 0. || (cellCoords.x < 0.) || (cellCoords.y < 0.) || (cellCoords.z < 0.) ||\n      (cellCoords.x > cc_ibl_cluster_CellsMax.x) || (cellCoords.y > cc_ibl_cluster_CellsMax.y) || (cellCoords.z > cc_ibl_cluster_CellsMax.z)) {\n  }\n  else {\n    float mip = ComputeReflectionCaptureMipFromRoughness(Roughness, 7.000001);\n    float cellIndex = dot(cc_ibl_cluster_CellsDot.xyz, cellCoords);\n    float clusterV = floor(cellIndex * cc_ibl_cluster_TextureSize.y);\n    float clusterU = floor(cellIndex - (clusterV * cc_ibl_cluster_TextureSize.x));\n    clusterV = (clusterV + 0.5) * cc_ibl_cluster_TextureSize.z;\n    EvalCluster(clusterU, clusterV, MaterialParameters, mip, IndirectIrradiance, ImageBasedReflections, CompositedAverageBrightness);\n  }\n  ImageBasedReflections.rgb *= View.IndirectLightingColorScale;\n  CompositedAverageBrightness.x *= Luminance( View.IndirectLightingColorScale );\n  if (ImageBasedReflections.a > 0.) {\n    float SkyAverageBrightness = 1.;\n    vec3 SkyLighting = GetSkyLightReflection(ReflectionVector, Roughness, SkyAverageBrightness);\n    ImageBasedReflections.rgb += ImageBasedReflections.a * SkyLighting;\n    CompositedAverageBrightness.x += SkyAverageBrightness * CompositedAverageBrightness.y;\n      ImageBasedReflections.rgb *= ComputeMixingWeight(IndirectIrradiance, CompositedAverageBrightness.x, Roughness);\n  }\n    vec3 brdf = EnvBRDF(preIntegratedGF, ShadingModelContext.SpecularColor, Roughness, NoV);\n  ImageBasedReflections.rgb *= brdf;\n  return ImageBasedReflections.rgb;\n}\n#if (CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD)\n    in vec3 v_luv;\n    uniform sampler2D cc_lightingMap;\n    #if USE_INSTANCING\n      in vec4 v_lightingMapAdds0;\n      in vec4 v_lightingMapAdds1;\n      in vec4 v_lightingMapScales0;\n      in vec4 v_lightingMapScales1;\n    #endif\n#endif\nvec4 lightingBase (FPixelMaterialInputs ShadingModelContext, FMaterialPixelParameters MaterialParameters, GlobalView View, vec4 shadowPos) {\n  vec3 Color = vec3(0);\n  #if CC_Lighting_Heavily\n    Color += vec3(0.1, 0, 0);\n  #else\n    vec3 direction = normalize(-cc_mainLitDir.xyz);\n    vec3 lightColor = cc_mainLitColor.rgb * cc_mainLitColor.w;\n    lightColor /= 3.14159265359;\n    float NoL = max(0., dot(MaterialParameters.WorldNormal, direction));\n    vec3 H = normalize(MaterialParameters.CameraVector + direction);\n    float NoH = max(0., dot(MaterialParameters.WorldNormal, H));\n    float Shadow = 1.;\n    #if CC_RECEIVE_SHADOW\n      if (cc_global_parameters.y != 0.) {\n          {\n            vec4 pos = ApplyShadowDepthBias_FaceNormal(shadowPos, MaterialParameters.WorldNormal);\n            float pcf = cc_shadowWHPBInfo.z;\n            if (pcf > 1.9) Shadow = CCGetShadowFactorSoft2X(pos);\n            else if (pcf > 0.9) Shadow = CCGetShadowFactorSoft(pos);\n            else Shadow = CCGetShadowFactorHard(pos);\n            Shadow = mix(Shadow, 1.0, cc_shadowNFLSInfo.w);\n          }\n      }\n    #endif\n    FDirectLighting Lighting = MobileIntegrateBxDF(ShadingModelContext, MaterialParameters.WorldNormal, H, NoH);\n    Color += (Shadow * NoL) * lightColor * (Lighting.Diffuse + Lighting.Specular );\n    float IndirectIrradiance = MaterialParameters.IndirectIrradiance * Shadow;\n    #if CC_ENABLE_IBL\n      vec3 SpecularIBL = GetImageBasedReflectionLighting(MaterialParameters, ShadingModelContext, IndirectIrradiance, View);\n      SpecularIBL *= min(Shadow * 2., 1.);\n      Color += SpecularIBL;\n    #endif\n    Color += ShadingModelContext.EmissiveColor;\n  #endif\n  return vec4(Color, ShadingModelContext.Opacity);\n}\n#if CC_FORWARD_ADD\n#if CC_PIPELINE_TYPE == 0\n# define LIGHTS_PER_PASS 1\n#else\n# define LIGHTS_PER_PASS 10\n#endif\n#if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\nlayout(std140) uniform CCForwardLight {\n  highp vec4 cc_lightPos[LIGHTS_PER_PASS];\n  vec4 cc_lightColor[LIGHTS_PER_PASS];\n  vec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];\n  vec4 cc_lightDir[LIGHTS_PER_PASS];\n};\n#endif\n#endif\nfloat SpotAttenuationMask(vec3 L, vec3 SpotDirection, vec2 SpotAngles)\n{\n  return clamp((dot(L, -SpotDirection) - SpotAngles.x) * SpotAngles.y, 0.0, 1.0);\n}\nfloat SpotAttenuation(vec3 L, vec3 SpotDirection, vec2 SpotAngles)\n{\n  float ConeAngleFalloff = Square(SpotAttenuationMask(L, SpotDirection, SpotAngles));\n  return ConeAngleFalloff;\n}\nvoid lightingAddPerLight(\n  in FPixelMaterialInputs ShadingModelContext, in FMaterialPixelParameters MaterialParameters,\n  vec3 pos, bool isSpotLight,\n  vec3 lightColor, float intensity,\n  float range, float spotAngle,\n  vec3 dir,\n  vec4 shadowPos,\n  inout vec3 outColor) {\n  vec3 toLight = pos - MaterialParameters.AbsoluteWorldPosition;\n  float distanceSqr = dot(toLight, toLight);\n  vec3 L = toLight * rsqrt(distanceSqr);\n  vec3 PointH = normalize(MaterialParameters.CameraVector + L);\n  float PointNoL = max(0., dot(MaterialParameters.WorldNormal, L));\n  float PointNoH = max(0., dot(MaterialParameters.WorldNormal, PointH));\n  float Attenuation;\n  {\n    Attenuation = 1. / ( distanceSqr + 0.01 );\n    float InvRadius = 1.0 / max(range, 0.01);\n    float LightRadiusMask = Square(clamp(1. - Square(distanceSqr * (InvRadius * InvRadius)), 0.0, 1.0));\n    Attenuation *= LightRadiusMask;\n  }\n  if (isSpotLight) {\n    vec3 SL = normalize(toLight);\n    float cosInner = 1.;\n    float cosOuter = spotAngle;\n    float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\n    vec2 SpotAngles = vec2(cosOuter, litAngleScale);\n    Attenuation *= SpotAttenuation(L, dir, SpotAngles);\n    float shadow = 1.;\n    #if CC_RECEIVE_SHADOW\n        {\n          vec4 pos = ApplyShadowDepthBias_FaceNormal(shadowPos, MaterialParameters.WorldNormal);\n          float pcf = cc_shadowWHPBInfo.z;\n          if (pcf > 1.9) shadow = CCGetShadowFactorSoft2X(pos);\n          else if (pcf > 0.9) shadow = CCGetShadowFactorSoft(pos);\n          else shadow = CCGetShadowFactorHard(pos);\n          shadow = mix(shadow, 1.0, cc_shadowNFLSInfo.w);\n        }\n    #endif\n    lightColor *= shadow;\n  }\n  FDirectLighting Lighting = MobileIntegrateBxDF(ShadingModelContext, MaterialParameters.WorldNormal, PointH, PointNoH);\n  outColor += min(vec3(65000.0), (Attenuation * PointNoL) * lightColor * intensity / 3.14159265359 * (Lighting.Diffuse + Lighting.Specular));\n}\nuniform sampler2D cc_light_cluster_InfoTexture;\nuniform sampler2D cc_light_cluster_Texture;\nvoid lightingCluster(float clusterIndex, in FPixelMaterialInputs ShadingModelContext, in FMaterialPixelParameters MaterialParameters, vec4 shadowPos, inout vec3 outColor) {\n  #if CC_Lighting_Heavily\n    outColor += vec3(0.1, 0, 0);\n  #else\n    float iblV = (clusterIndex + 0.5) * cc_light_cluster_InfoTextureInvSize.y;\n    vec4 lightPos = texture(cc_light_cluster_InfoTexture, vec2(0.5 * cc_light_cluster_InfoTextureInvSize.x, iblV));\n    vec4 lightColor = texture(cc_light_cluster_InfoTexture, vec2(1.5 * cc_light_cluster_InfoTextureInvSize.x, iblV));\n    vec4 lightSizeRangeAngle = texture(cc_light_cluster_InfoTexture, vec2(2.5 * cc_light_cluster_InfoTextureInvSize.x, iblV));\n    vec4 lightDir = texture(cc_light_cluster_InfoTexture, vec2(3.5 * cc_light_cluster_InfoTextureInvSize.x, iblV));\n    lightingAddPerLight(\n      ShadingModelContext, MaterialParameters,\n      lightPos.xyz, lightPos.w > 0.0,\n      lightColor.rgb, lightColor.w,\n      lightSizeRangeAngle.y, lightSizeRangeAngle.z,\n      lightDir.xyz,\n      shadowPos,\n      outColor\n    );\n  #endif\n}\n#if CC_ENABLE_CLUSTERED_LIGHT_CULLING && CC_ENABLE_Builtin_CLUSTERED_LIGHT_CULLING\n  float SmoothDistAtt (float distSqr, float invSqrAttRadius) {\n    float factor = distSqr * invSqrAttRadius;\n    float smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\n    return smoothFactor * smoothFactor;\n  }\n  float GetDistAtt (float distSqr, float invSqrAttRadius) {\n    float attenuation = 1.0 / max(distSqr, 0.01*0.01);\n    attenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\n    return attenuation;\n  }\n  float GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\n    float cd = dot(litDir, L);\n    float attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\n    return (attenuation * attenuation);\n  }\n  #if CC_USE_IBL\n    uniform samplerCube cc_environment;\n    #if CC_USE_DIFFUSEMAP\n      uniform samplerCube cc_diffuseMap;\n    #endif\n  #endif\n  float GGXMobile (float roughness, float NoH, vec3 H, vec3 N) {\n    vec3 NxH = cross(N, H);\n    float OneMinusNoHSqr = dot(NxH, NxH);\n    float a = roughness * roughness;\n    float n = NoH * a;\n    float p = a / (OneMinusNoHSqr + n * n);\n    return p * p;\n  }\n  float CalcSpecular (float roughness, float NoH, vec3 H, vec3 N) {\n    return (roughness * 0.25 + 0.25) * GGXMobile(roughness, NoH, H, N);\n  }\n  vec3 BRDFApprox (vec3 specular, float roughness, float NoV) {\n    const vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);\n    const vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);\n    vec4 r = roughness * c0 + c1;\n    float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\n    vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\n    AB.y *= clamp(50.0 * specular.g, 0.0, 1.0);\n    return specular * AB.x + AB.y;\n  }\n  #if USE_REFLECTION_DENOISE\n  #endif\n  struct StandardSurface {\n    vec4 albedo;\n    vec3 position;\n    vec3 normal;\n    vec3 emissive;\n    vec3 lightmap;\n    float lightmap_test;\n    float roughness;\n    float metallic;\n    float occlusion;\n  };\n  layout(std430, binding = 4) readonly buffer b_ccLightsBuffer { vec4 b_ccLights[]; };\n  layout(std430, binding = 5) readonly buffer b_clusterLightIndicesBuffer { uint b_clusterLightIndices[]; };\n  layout(std430, binding = 6) readonly buffer b_clusterLightGridBuffer { uvec4 b_clusterLightGrid[]; };\n  struct CCLight\n  {\n    vec4 cc_lightPos;\n    vec4 cc_lightColor;\n    vec4 cc_lightSizeRangeAngle;\n    vec4 cc_lightDir;\n  };\n  struct Cluster\n  {\n    vec3 minBounds;\n    vec3 maxBounds;\n  };\n  struct LightGrid\n  {\n    uint offset;\n    uint ccLights;\n  };\n  CCLight getCCLight(uint i)\n  {\n    CCLight light;\n    light.cc_lightPos = b_ccLights[4u * i + 0u];\n    light.cc_lightColor = b_ccLights[4u * i + 1u];\n    light.cc_lightSizeRangeAngle = b_ccLights[4u * i + 2u];\n    light.cc_lightDir = b_ccLights[4u * i + 3u];\n    return light;\n  }\n  LightGrid getLightGrid(uint cluster)\n  {\n    uvec4 gridvec = b_clusterLightGrid[cluster];\n    LightGrid grid;\n    grid.offset = gridvec.x;\n    grid.ccLights = gridvec.y;\n    return grid;\n  }\n  uint getGridLightIndex(uint start, uint offset)\n  {\n    return b_clusterLightIndices[start + offset];\n  }\n  uint getClusterZIndex(vec4 worldPos)\n  {\n    float scale = float(24) / log(cc_nearFar.y / cc_nearFar.x);\n    float bias = -(float(24) * log(cc_nearFar.x) / log(cc_nearFar.y / cc_nearFar.x));\n    float eyeDepth = -(cc_matView * worldPos).z;\n    uint zIndex = uint(max(log(eyeDepth) * scale + bias, 0.0));\n    return zIndex;\n  }\n  uint getClusterIndex(vec4 fragCoord, vec4 worldPos)\n  {\n    uint zIndex = getClusterZIndex(worldPos);\n    float clusterSizeX = ceil(cc_nativeSize.x / float(16));\n    float clusterSizeY = ceil(cc_nativeSize.y / float(8));\n    uvec3 indices = uvec3(uvec2(fragCoord.xy / vec2(clusterSizeX, clusterSizeY)), zIndex);\n    uint cluster = (16u * 8u) * indices.z + 16u * indices.y + indices.x;\n    return cluster;\n  }\n  vec4 CCClusterShadingAdditive (StandardSurface s, vec4 shadowPos) {\n    vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n    vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n    vec3 diffuseContrib = diffuse / 3.14159265359;\n    vec3 N = normalize(s.normal);\n    vec3 V = normalize(cc_cameraPos.xyz - s.position);\n    float NV = max(abs(dot(N, V)), 0.001);\n    specular = BRDFApprox(specular, s.roughness, NV);\n    vec3 finalColor = vec3(0.0);\n    uint cluster = getClusterIndex(gl_FragCoord, vec4(s.position, 1.0));\n    LightGrid grid = getLightGrid(cluster);\n    uint numLights = grid.ccLights;\n    for (uint i = 0u; i < 100u; i++) {\n      if (i >= numLights) break;\n      uint lightIndex = getGridLightIndex(grid.offset, i);\n      CCLight light = getCCLight(lightIndex);\n      vec3 SLU = light.cc_lightPos.xyz - s.position;\n      vec3 SL = normalize(SLU);\n      vec3 SH = normalize(SL + V);\n      float SNL = max(dot(N, SL), 0.001);\n      float SNH = max(dot(N, SH), 0.0);\n      float distSqr = dot(SLU, SLU);\n      float litRadius = light.cc_lightSizeRangeAngle.x;\n      float litRadiusSqr = litRadius * litRadius;\n      float illum = 3.14159265359 * (litRadiusSqr / max(litRadiusSqr , distSqr));\n      float attRadiusSqrInv = 1.0 / max(light.cc_lightSizeRangeAngle.y, 0.01);\n      attRadiusSqrInv *= attRadiusSqrInv;\n      float att = GetDistAtt(distSqr, attRadiusSqrInv);\n      vec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\n      if (light.cc_lightPos.w > 0.0) {\n        float cosInner = max(dot(-light.cc_lightDir.xyz, SL), 0.01);\n        float cosOuter = light.cc_lightSizeRangeAngle.z;\n        float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\n        float litAngleOffset = -cosOuter * litAngleScale;\n        att *= GetAngleAtt(SL, -light.cc_lightDir.xyz, litAngleScale, litAngleOffset);\n      }\n      vec3 lightColor = light.cc_lightColor.rgb;\n      float shadow = 1.0;\n      #if CC_RECEIVE_SHADOW\n        if (light.cc_lightPos.w > 0.0) {\n            {\n              float pcf = cc_shadowWHPBInfo.z;\n              if (pcf > 1.9) shadow = CCGetSpotLightShadowFactorSoft2X(shadowPos, s.position);\n              else if (pcf > 0.9) shadow = CCGetSpotLightShadowFactorSoft(shadowPos, s.position);\n              else shadow = CCGetSpotLightShadowFactorHard(shadowPos, s.position);\n            }\n        }\n      #endif\n      lightColor *= shadow;\n      finalColor += SNL * lightColor * light.cc_lightColor.w * illum * att * (diffuseContrib + lspec);\n    }\n    return vec4(finalColor, 0.0);\n  }\n#endif\nvec4 lightingAdd (in FPixelMaterialInputs ShadingModelContext, in FMaterialPixelParameters MaterialParameters, vec4 shadowPos) {\n  vec3 color = vec3(0.);\n  #if CC_ENABLE_CLUSTERED_LIGHT_CULLING && CC_ENABLE_Builtin_CLUSTERED_LIGHT_CULLING\n    StandardSurface s;\n    s.albedo.xyz = ShadingModelContext.BaseColor;\n    s.albedo.w = ShadingModelContext.Opacity;\n    s.metallic = ShadingModelContext.Metallic;\n    s.roughness = ShadingModelContext.Roughness;\n    s.normal = MaterialParameters.WorldNormal;\n    s.position = MaterialParameters.AbsoluteWorldPosition;\n    color = CCClusterShadingAdditive(s, shadowPos).rgb;\n  #else\n  vec3 cellCoords = floor((MaterialParameters.AbsoluteWorldPosition - cc_light_cluster_BoundsMin.xyz) * cc_light_cluster_CellsCountByBoundsSizeAndPixelsPerCell.xyz);\n  if ((cellCoords.x < 0.) || (cellCoords.y < 0.) || (cellCoords.z < 0.) ||\n      (cellCoords.x > cc_light_cluster_CellsMax.x) ||\n      (cellCoords.y > cc_light_cluster_CellsMax.y) ||\n      (cellCoords.z > cc_light_cluster_CellsMax.z)) {\n  }\n  else {\n    float cellIndex = dot(cc_light_cluster_CellsDot.xyz, cellCoords);\n    float clusterV = floor(cellIndex * cc_light_cluster_TextureSize.y);\n    float clusterU = cellIndex - (clusterV * cc_light_cluster_TextureSize.x);\n    clusterV = (clusterV + 0.5) * cc_light_cluster_TextureSize.z;\n    #if CC_LIGHT_MaxPixelsPerCell\n    for (float cellIndex = 0.5; cellIndex < float(CC_LIGHT_MaxPixelsPerCell); cellIndex++) {\n      vec4 lightIndices = texture(cc_light_cluster_Texture, vec2(cc_light_cluster_TextureSize.y * (clusterU + cellIndex), clusterV));\n      vec4 indices = lightIndices * 255.0;\n      for (int e = 0; e < 4; e++) {\n        if (indices[e] <= 0.0) {\n          break;\n        }\n        lightingCluster(indices[e], ShadingModelContext, MaterialParameters, shadowPos, color);\n      }\n      if (cellIndex > cc_light_cluster_CellsCountByBoundsSizeAndPixelsPerCell.w) {\n        break;\n      }\n    }\n    #endif\n  }\n  #endif\n  return vec4(color, ShadingModelContext.Opacity);\n}\nvoid InitShadingModelContext(inout FPixelMaterialInputs ShadingModelContext, FMaterialPixelParameters MaterialParameters) {\n  ShadingModelContext.RoughnessWithClamp = max(0.015625, ShadingModelContext.Roughness);\n  float NoV = max(dot(MaterialParameters.WorldNormal, MaterialParameters.CameraVector), 0.);\n  float DielectricSpecular = 0.08 * ShadingModelContext.Specular;\n  ShadingModelContext.DiffuseColor = ShadingModelContext.BaseColor - ShadingModelContext.BaseColor * ShadingModelContext.Metallic;\n  ShadingModelContext.SpecularColor = mix(0.08 * vec3(ShadingModelContext.Specular), ShadingModelContext.BaseColor, ShadingModelContext.Metallic);\n}\nvec4 lighting (FPixelMaterialInputs ShadingModelContext, FMaterialPixelParameters MaterialParameters, GlobalView View, vec4 shadowPos) {\n  vec4 color = vec4(vec3(0.), 1.);\n    #if CC_ENABLE_LIGHTING_BASE\n      color = lightingBase(ShadingModelContext, MaterialParameters, View, shadowPos);\n    #endif\n    #if CC_ENABLE_LIGHTING_ADD && (1 || 1)\n      color += lightingAdd(ShadingModelContext, MaterialParameters, shadowPos);\n    #endif\n  color *= ShadingModelContext.AmbientOcclusion;\n  return color;\n}\nconst float FLT_EPSILON = 0.001;\nconst float FLT_EPSILON2 = 0.01;\nfloat CalculateLineIntegralShared(float FogHeightFalloff, float RayDirectionZ, float RayOriginTerms)\n{\n  float Falloff = max(-127.0, FogHeightFalloff * RayDirectionZ);\n  float LineIntegral = ( 1.0 - exp2(-Falloff) ) / Falloff;\n  float LineIntegralTaylor = log(2.0) - ( 0.5 * (pow(2., log(2.0))) ) * Falloff;\n  return RayOriginTerms * ( abs(Falloff) > FLT_EPSILON2 ? LineIntegral : LineIntegralTaylor );\n}\nvec3 ComputeInscatteringColor(vec3 CameraToReceiver, float CameraToReceiverLength)\n{\n  vec3 Inscattering = FogStruct_ExponentialFogColorParameter.xyz;\n  return Inscattering;\n}\nvec4 GetExponentialHeightFog(vec3 WorldPositionRelativeToCamera, float ExcludeDistance)\n{\n  float MinFogOpacity = FogStruct_ExponentialFogColorParameter.w;\n  float MaxWorldObserverHeight = FogStruct_ExponentialFogParameters.z;\n  vec3 View_WorldCameraOrigin = cc_cameraPos.xyz;\n  vec3 WorldObserverOrigin = vec3(View_WorldCameraOrigin.x, min(View_WorldCameraOrigin.y, MaxWorldObserverHeight), View_WorldCameraOrigin.z);\n  vec3 CameraToReceiver = WorldPositionRelativeToCamera;\n  CameraToReceiver.y += View_WorldCameraOrigin.y - WorldObserverOrigin.y;\n  float CameraToReceiverLengthSqr = dot(CameraToReceiver, CameraToReceiver);\n  float CameraToReceiverLengthInv = rsqrt(CameraToReceiverLengthSqr);\n  float CameraToReceiverLength = CameraToReceiverLengthSqr * CameraToReceiverLengthInv;\n  vec3 CameraToReceiverNormalized = CameraToReceiver * CameraToReceiverLengthInv;\n  float RayOriginTerms = FogStruct_ExponentialFogParameters.x;\n  float RayOriginTermsSecond = FogStruct_ExponentialFogParameters2.x;\n  float RayLength = CameraToReceiverLength;\n  float RayDirectionZ = CameraToReceiver.y;\n  ExcludeDistance = max(ExcludeDistance, FogStruct_ExponentialFogParameters.w);\n  if (ExcludeDistance > 0.)\n  {\n    float ExcludeIntersectionTime = ExcludeDistance * CameraToReceiverLengthInv;\n    float CameraToExclusionIntersectionZ = ExcludeIntersectionTime * CameraToReceiver.y;\n    float ExclusionIntersectionZ = WorldObserverOrigin.y + CameraToExclusionIntersectionZ;\n    float ExclusionIntersectionToReceiverZ = CameraToReceiver.y - CameraToExclusionIntersectionZ;\n    RayLength = (1.0 - ExcludeIntersectionTime) * CameraToReceiverLength;\n    RayDirectionZ = ExclusionIntersectionToReceiverZ;\n    float Exponent = max(-127.0, FogStruct_ExponentialFogParameters.y * (ExclusionIntersectionZ - FogStruct_ExponentialFogParameters3.y));\n    RayOriginTerms = FogStruct_ExponentialFogParameters3.x * exp2(-Exponent);\n    float ExponentSecond = max(-127.0, FogStruct_ExponentialFogParameters2.y * (ExclusionIntersectionZ - FogStruct_ExponentialFogParameters2.w));\n    RayOriginTermsSecond = FogStruct_ExponentialFogParameters2.z * exp2(-ExponentSecond);\n  }\n  float ExponentialHeightLineIntegralShared = CalculateLineIntegralShared(FogStruct_ExponentialFogParameters.y, RayDirectionZ, RayOriginTerms) + CalculateLineIntegralShared(FogStruct_ExponentialFogParameters2.y, RayDirectionZ, RayOriginTermsSecond);\n  float ExponentialHeightLineIntegral = ExponentialHeightLineIntegralShared * RayLength;\n  vec3 InscatteringColor = ComputeInscatteringColor(CameraToReceiver, CameraToReceiverLength);\n  vec3 DirectionalInscattering = vec3(0.);\n  float ExpFogFactor = max(clamp(exp2(-ExponentialHeightLineIntegral), 0.0, 1.0), MinFogOpacity);\n  if (FogStruct_ExponentialFogParameters3.w > 0. && CameraToReceiverLength > FogStruct_ExponentialFogParameters3.w)\n  {\n    ExpFogFactor = 1.;\n    DirectionalInscattering = vec3(0.);\n  }\n    vec3 FogColor = (InscatteringColor) * (1. - ExpFogFactor) + DirectionalInscattering;\n  return vec4(FogColor, ExpFogFactor);\n}\nvec4 CalculateHeightFog(vec3 WorldPositionRelativeToCamera)\n{\n  vec3 WorldPosition = WorldPositionRelativeToCamera;\n  float ExcludeDistance = 0.;\n  vec4 FogInscatteringAndOpacity = GetExponentialHeightFog(WorldPositionRelativeToCamera, ExcludeDistance);\n  return FogInscatteringAndOpacity;\n}\n  #if !CC_DEVICE_CAN_BENEFIT_FROM_INPUT_ATTACHMENT || __VERSION__ >= 450\n    layout(location = 0) out vec4 fragColor;\n  #endif\n  const mat3 kernel9 = mat3(\n    0.0625, 0.125, 0.0625,\n    0.125, 0.25, 0.125,\n    0.0625, 0.125, 0.0625\n  );\n  vec4 gaussianBlur9(sampler2D Tex, vec2 UV, float Intensity) {\n    vec3 sum = vec3(0.);\n    vec2 offset = vec2(0.0);\n    const int size = 3;\n    const float start = floor(float(size) / 2.);\n    vec2 normalizedSize = vec2(1.0 / vec2(cc_screenSize.xy));\n    for (int u = 0; u < size; u++) {\n      for (int v = 0; v < size; v++) {\n        offset = normalizedSize * (vec2(u, v) - start) * Intensity;\n        sum += texture(Tex, UV + offset).rgb * kernel9[v][u];\n      }\n    }\n    return vec4(sum, texture(Tex, UV).a);\n  }\n  void main () {\n    #if CC_DEVICE_CAN_BENEFIT_FROM_INPUT_ATTACHMENT\n        vec4 albedoMap = gbuffer_albedoMap;\n        vec4 positionMap = gbuffer_positionMap;\n        vec4 normalMap = gbuffer_normalMap;\n        vec4 emissiveMap = gbuffer_emissiveMap;\n    #else\n      vec4 albedoMap = texture(gbuffer_albedoMap,v_uv);\n      vec4 positionMap = texture(gbuffer_positionMap,v_uv);\n      vec4 normalMap = texture(gbuffer_normalMap,v_uv);\n      vec4 emissiveMap = texture(gbuffer_emissiveMap,v_uv);\n    #endif\n    FMaterialPixelParameters Parameters;\n    Parameters.AbsoluteWorldPosition = positionMap.xyz;\n    Parameters.WorldNormal = normalMap.xyz;\n    Parameters.CameraVector = normalize(cc_cameraPos.xyz - Parameters.AbsoluteWorldPosition);\n    Parameters.ReflectionVector = normalize(reflect(-Parameters.CameraVector, Parameters.WorldNormal));\n    FPixelMaterialInputs PixelMaterialInputs;\n    PixelMaterialInputs.BaseColor = albedoMap.xyz;\n    PixelMaterialInputs.Opacity = albedoMap.w;\n    PixelMaterialInputs.Roughness = positionMap.w;\n    PixelMaterialInputs.Metallic = normalMap.w;\n    PixelMaterialInputs.EmissiveColor = emissiveMap.xyz;\n    Parameters.IndirectIrradiance = emissiveMap.w;\n    PixelMaterialInputs.AmbientOcclusion = 1.;\n    PixelMaterialInputs.Specular = 0.5;\n    float ssao = 1.;\n    if (cc_global_parameters.x != 0.) {\n      ssao = gaussianBlur9(ssao_map, v_uv, 3.0).r;\n    }\n    PixelMaterialInputs.AmbientOcclusion *= ssao;\n    InitShadingModelContext(PixelMaterialInputs, Parameters);\n    GlobalView View;\n    getGlobalView(View);\n    vec4 shadowPos;\n      shadowPos = cc_matLightViewProj * vec4(Parameters.AbsoluteWorldPosition, 1);\n    #if CC_ENABLE_LIGHTING\n      vec4 color = lighting(PixelMaterialInputs, Parameters, View, shadowPos);\n    #else\n      vec4 color = vec4(vec3(0.), 1.);\n    #endif\n    #if !CC_Lighting_Heavily\n      vec4 fogColor = CalculateHeightFog(Parameters.AbsoluteWorldPosition.xyz - cc_cameraPos.xyz);\n      color.rgb = color.rgb * fogColor.a + fogColor.rgb;\n      color.rgb *= View.PreExposure;\n    #endif\n    color.a = 1.;\n    #if CC_DEVICE_CAN_BENEFIT_FROM_INPUT_ATTACHMENT\n        gbuffer_emissiveMap = color;\n    #else\n      fragColor = color;\n    #endif\n  }"},"glsl1":{"vert":"\nprecision highp float;\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\nattribute vec4 a_tangent;\nuniform highp vec4 cc_cameraPos;\nvarying vec2 v_uv;\nvoid main () {\n  vec4 position;\n    position = vec4(a_position, 1.0);\n  position.xy = cc_cameraPos.w == 0.0 ? vec2(position.xy.x, -position.xy.y) : position.xy;\n  gl_Position = vec4(position.x, position.y, 1.0, 1.0);\n  v_uv = a_texCoord;\n}","frag":"\n#ifdef GL_EXT_shader_texture_lod\n#extension GL_EXT_shader_texture_lod: enable\n#endif\n#ifdef GL_EXT_shader_framebuffer_fetch\n#extension GL_EXT_shader_framebuffer_fetch: enable\n#endif\n  precision highp float;\n  uniform mediump vec4 cc_screenSize;\n  uniform mediump vec4 cc_nativeSize;\n  uniform highp mat4 cc_matView;\n  uniform highp mat4 cc_matViewProj;\n  uniform highp vec4 cc_cameraPos;\n  uniform mediump vec4 cc_mainLitDir;\n  uniform mediump vec4 cc_mainLitColor;\n  uniform mediump vec4 cc_nearFar;\n  uniform highp mat4 cc_matLightView;\n  uniform highp mat4 cc_matLightViewProj;\n  uniform highp vec4 cc_shadowInvProjDepthInfo;\n  uniform highp vec4 cc_shadowProjDepthInfo;\n  uniform highp vec4 cc_shadowProjInfo;\n  uniform lowp vec4 cc_shadowNFLSInfo;\n  uniform lowp vec4 cc_shadowWHPBInfo;\n  uniform lowp vec4 cc_shadowLPNNInfo;\n  float CCGetLinearDepthFromViewSpace(vec3 viewPos) {\n    float dist = length(viewPos);\n    return (dist - cc_shadowNFLSInfo.x) / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x);\n  }\n  float CCGetLinearDepth(vec3 worldPos) {\n    vec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n    return CCGetLinearDepthFromViewSpace(viewStartPos.xyz);\n  }\n  #if CC_RECEIVE_SHADOW\n    uniform highp sampler2D cc_shadowMap;\n    uniform highp sampler2D cc_spotLightingMap;\n    vec4 ApplyShadowDepthBias_FaceNormal(vec4 shadowPos, vec3 worldNormal)\n    {\n      vec4 newShadowPos = shadowPos;\n      if(cc_shadowLPNNInfo.z > 0.0001)\n      {\n        vec4 viewNormal = cc_matLightView * vec4(worldNormal, 0.0);\n        if(viewNormal.z < 0.1)\n          newShadowPos.xy += viewNormal.xy * cc_shadowProjInfo.xy * cc_shadowLPNNInfo.z * clamp(viewNormal.z, 0.001, 0.1);\n      }\n      return newShadowPos;\n    }\n    vec4 ApplyShadowDepthBias_Perspective(vec4 shadowPos, float viewspaceDepthBias)\n    {\n      vec3 viewSpacePos;\n      viewSpacePos.xy = shadowPos.xy * cc_shadowProjInfo.zw;\n      viewSpacePos.z = shadowPos.z * cc_shadowInvProjDepthInfo.x + shadowPos.w * cc_shadowInvProjDepthInfo.y;\n      viewSpacePos.xyz += cc_shadowProjDepthInfo.z * normalize(viewSpacePos.xyz) * viewspaceDepthBias;\n      vec4 clipSpacePos;\n      clipSpacePos.xy = viewSpacePos.xy * cc_shadowProjInfo.xy;\n      clipSpacePos.zw = viewSpacePos.z * cc_shadowProjDepthInfo.xz + vec2(cc_shadowProjDepthInfo.y, 0.0);\n      if (cc_shadowNFLSInfo.z > 0.000001) {\n        clipSpacePos.z = CCGetLinearDepthFromViewSpace(viewSpacePos.xyz);\n        clipSpacePos.z = (clipSpacePos.z * 2.0 - 1.0) * clipSpacePos.w;\n      }\n      return clipSpacePos;\n    }\n    vec4 ApplyShadowDepthBias_Orthographic(vec4 shadowPos, float viewspaceDepthBias)\n    {\n      float coeffA = cc_shadowProjDepthInfo.x;\n      float coeffB = cc_shadowProjDepthInfo.y;\n      float viewSpacePos_z = (shadowPos.z - coeffB) / coeffA;\n      viewSpacePos_z += viewspaceDepthBias;\n      vec4 result = shadowPos;\n      result.z = viewSpacePos_z * coeffA + coeffB;\n      return result;\n    }\n    float CCGetShadowFactorHard (vec4 shadowPos) {\n      vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, cc_shadowWHPBInfo.w);\n      vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n      if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n          clipPos.y < 0.0 || clipPos.y > 1.0 ||\n          clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n      clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n      float shadow = 0.0;\n      float closestDepth = 0.0;\n      if (cc_shadowLPNNInfo.y > 0.000001) {\n        closestDepth = dot(texture2D(cc_shadowMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n      } else {\n        closestDepth = texture2D(cc_shadowMap, clipPos.xy).x;\n      }\n      shadow = step(clipPos.z, closestDepth);\n      return shadow;\n    }\n    float CCGetShadowFactorSoft (vec4 shadowPos) {\n      vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, cc_shadowWHPBInfo.w);\n      vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n      if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n          clipPos.y < 0.0 || clipPos.y > 1.0 ||\n          clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n      clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n      float offsetDepth = clipPos.z;\n      vec2 mapSize = cc_shadowWHPBInfo.xy;\n      vec2 oneTap = 1.0 / mapSize;\n      vec2 clipPos_offset = clipPos.xy + oneTap;\n      float block0, block1, block2, block3;\n      if (cc_shadowLPNNInfo.y > 0.000001) {\n        block0 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block1 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block2 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block3 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      } else {\n        block0 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\n        block1 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)).x);\n        block2 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)).x);\n        block3 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);\n      }\n      float coefX   = mod(clipPos.x, oneTap.x) * mapSize.x;\n      float resultX = mix(block0, block1, coefX);\n      float resultY = mix(block2, block3, coefX);\n      float coefY   = mod(clipPos.y, oneTap.y) * mapSize.y;\n      return mix(resultX, resultY, coefY);\n    }\n    float CCGetShadowFactorSoft2X (vec4 shadowPos) {\n      vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, cc_shadowWHPBInfo.w);\n      vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n      if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n          clipPos.y < 0.0 || clipPos.y > 1.0 ||\n          clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n      clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n      float offsetDepth = clipPos.z;\n      vec2 mapSize = cc_shadowWHPBInfo.xy;\n      vec2 oneTap = 1.0 / mapSize;\n      float clipPos_offset_L = clipPos.x - oneTap.x;\n      float clipPos_offset_R = clipPos.x + oneTap.x;\n      float clipPos_offset_U = clipPos.y - oneTap.y;\n      float clipPos_offset_D = clipPos.y + oneTap.y;\n      float block0, block1, block2, block3, block4, block5, block6, block7, block8;\n      if (cc_shadowLPNNInfo.y > 0.000001) {\n        block0 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block1 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block2 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block3 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block4 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block5 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block6 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block7 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block8 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      } else {\n        block0 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);\n        block1 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)).x);\n        block2 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);\n        block3 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)).x);\n        block4 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\n        block5 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)).x);\n        block6 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);\n        block7 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)).x);\n        block8 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);\n      }\n      float coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\n      float coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\n      float shadow = 0.0;\n      float resultX = mix(block0, block1, coefX);\n      float resultY = mix(block3, block4, coefX);\n      shadow += mix(resultX , resultY, coefY);\n      resultX = mix(block1, block2, coefX);\n      resultY = mix(block4, block5, coefX);\n      shadow += mix(resultX , resultY, coefY);\n      resultX = mix(block3, block4, coefX);\n      resultY = mix(block6, block7, coefX);\n      shadow += mix(resultX, resultY, coefY);\n      resultX = mix(block4, block5, coefX);\n      resultY = mix(block7, block8, coefX);\n      shadow += mix(resultX, resultY, coefY);\n      return shadow * 0.25;\n    }\n    float CCGetSpotLightShadowFactorHard (vec4 shadowPos, vec3 worldPos) {\n      vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, cc_shadowWHPBInfo.w);\n      vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n      if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n          clipPos.y < 0.0 || clipPos.y > 1.0 ||\n          clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n      clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n      float shadow = 0.0;\n      float closestDepth = 0.0;\n      float depth = clipPos.z;\n      if (cc_shadowLPNNInfo.y > 0.000001) {\n        closestDepth = dot(texture2D(cc_spotLightingMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n      } else {\n        closestDepth = texture2D(cc_spotLightingMap, clipPos.xy).x;\n      }\n      shadow = step(depth, closestDepth);\n      return shadow;\n    }\n    float CCGetSpotLightShadowFactorSoft (vec4 shadowPos, vec3 worldPos) {\n      vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, cc_shadowWHPBInfo.w);\n      vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n      if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n          clipPos.y < 0.0 || clipPos.y > 1.0 ||\n          clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n      clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n      float depth = 0.0;\n      if (cc_shadowNFLSInfo.z > 0.000001) {\n        depth = CCGetLinearDepth(worldPos);\n      } else {\n        depth = clipPos.z;\n      }\n      float bias = cc_shadowWHPBInfo.w;\n      vec2 oneTap = 1.0 / cc_shadowWHPBInfo.xy;\n      vec2 clipPos_offset = clipPos.xy + oneTap;\n      float block0, block1, block2, block3;\n      if (cc_shadowLPNNInfo.y > 0.000001) {\n        block0 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block1 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block2 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block3 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      } else {\n        block0 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x);\n        block1 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos.y)).x);\n        block2 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset.y)).x);\n        block3 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);\n      }\n      float coefX   = mod(clipPos.x, oneTap.x) * cc_shadowWHPBInfo.x;\n      float resultX = mix(block0, block1, coefX);\n      float resultY = mix(block2, block3, coefX);\n      float coefY   = mod(clipPos.y, oneTap.y) * cc_shadowWHPBInfo.y;\n      return mix(resultX, resultY, coefY);\n    }\n    float CCGetSpotLightShadowFactorSoft2X (vec4 shadowPos, vec3 worldPos) {\n      vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, cc_shadowWHPBInfo.w);\n      vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n      if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n          clipPos.y < 0.0 || clipPos.y > 1.0 ||\n          clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n      clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n      float depth = 0.0;\n      if (cc_shadowNFLSInfo.z > 0.000001) {\n        depth = CCGetLinearDepth(worldPos);\n      } else {\n        depth = clipPos.z;\n      }\n      float bias = cc_shadowWHPBInfo.w;\n      vec2 mapSize = cc_shadowWHPBInfo.xy;\n      vec2 oneTap = 1.0 / mapSize;\n      float clipPos_offset_L = clipPos.x - oneTap.x;\n      float clipPos_offset_R = clipPos.x + oneTap.x;\n      float clipPos_offset_U = clipPos.y - oneTap.y;\n      float clipPos_offset_D = clipPos.y + oneTap.y;\n      float block0, block1, block2, block3, block4, block5, block6, block7, block8;\n      if (cc_shadowLPNNInfo.y > 0.000001) {\n        block0 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block1 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block2 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block3 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block4 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block5 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block6 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block7 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block8 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      } else {\n        block0 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);\n        block1 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_U)).x);\n        block2 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);\n        block3 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos.y)).x);\n        block4 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x);\n        block5 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos.y)).x);\n        block6 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);\n        block7 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_D)).x);\n        block8 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);\n      }\n      float coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\n      float coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\n      float shadow = 0.0;\n      float resultX = mix(block0, block1, coefX);\n      float resultY = mix(block3, block4, coefX);\n      shadow += mix(resultX , resultY, coefY);\n      resultX = mix(block1, block2, coefX);\n      resultY = mix(block4, block5, coefX);\n      shadow += mix(resultX , resultY, coefY);\n      resultX = mix(block3, block4, coefX);\n      resultY = mix(block6, block7, coefX);\n      shadow += mix(resultX, resultY, coefY);\n      resultX = mix(block4, block5, coefX);\n      resultY = mix(block7, block8, coefX);\n      shadow += mix(resultX, resultY, coefY);\n      return shadow * 0.25;\n    }\n  #endif\n  varying vec2 v_uv;\n  #if CC_DEVICE_CAN_BENEFIT_FROM_INPUT_ATTACHMENT\n  #else\n    uniform sampler2D gbuffer_albedoMap;\n    uniform sampler2D gbuffer_positionMap;\n    uniform sampler2D gbuffer_normalMap;\n    uniform sampler2D gbuffer_emissiveMap;\n  #endif\n  uniform sampler2D preIntegratedGF;\n  uniform sampler2D ssao_map;\nvec3 CCRGBE2Linear (vec4 rgbe) {\n    return rgbe.rgb * pow(1.1, rgbe.a * 255.0 - 128.0);\n}\nvec4 decodeCCRGBE (vec4 color) {\n  color.rgb = CCRGBE2Linear(color);\n  color.a = 1.;\n  return color;\n}\nfloat rsqrt (float x) {\n  return 1. / sqrt(x);\n}\n  #ifdef GL_OES_standard_derivatives\n  #else\n  #endif\nfloat Square(float v)\n{\n    return v * v;\n}\nuniform mat4 cc_view_inverse_transpose_mirror;\n  uniform vec4 cc_view_pr_reflectionPlane;\n  uniform vec4 cc_view_pr_parameters;\n  uniform vec4 cc_view_SkyColor;\n  uniform vec4 cc_view_SkyLightParameters;\n  uniform vec4 cc_view_IndirectLightingColorScale_Intensity;\n  uniform vec4 cc_view_PreExposure;\n  uniform vec4 cc_ibl_cluster_BoundsMin;\n  uniform vec4 cc_ibl_cluster_CellsDot;\n  uniform vec4 cc_ibl_cluster_CellsMax;\n  uniform vec4 cc_ibl_cluster_TextureSize;\n  uniform vec4 cc_ibl_cluster_InfoTextureInvSize;\n  uniform vec4 cc_ibl_cluster_CellsCountByBoundsSizeAndPixelsPerCell;\n  uniform vec4 cc_light_cluster_BoundsMin;\n  uniform vec4 cc_light_cluster_CellsDot;\n  uniform vec4 cc_light_cluster_CellsMax;\n  uniform vec4 cc_light_cluster_TextureSize;\n  uniform vec4 cc_light_cluster_InfoTextureInvSize;\n  uniform vec4 cc_light_cluster_CellsCountByBoundsSizeAndPixelsPerCell;\n  uniform vec4 FogStruct_ExponentialFogParameters;\n  uniform vec4 FogStruct_ExponentialFogColorParameter;\n  uniform vec4 FogStruct_ExponentialFogParameters2;\n  uniform vec4 FogStruct_ExponentialFogParameters3;\n  uniform vec4 cc_global_parameters;\nstruct GlobalView {\n    vec3 IndirectLightingColorScale;\n    float PreExposure;\n};\nvoid getGlobalView (out GlobalView View) {\n    View.IndirectLightingColorScale = cc_view_IndirectLightingColorScale_Intensity.rgb * cc_view_IndirectLightingColorScale_Intensity.w;\n    View.PreExposure = cc_view_PreExposure.x;\n}\nvec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {\n    #ifdef GL_EXT_shader_texture_lod\n      return texture2DLodEXT(tex, coord, lod);\n    #else\n      return texture2D(tex, coord, lod);\n    #endif\n}\nvec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {\n    #ifdef GL_EXT_shader_texture_lod\n      return textureCubeLodEXT(tex, coord, lod);\n    #else\n      return textureCube(tex, coord, lod);\n    #endif\n}\nstruct Light {\n  vec3 color;\n  vec3 direction;\n};\nstruct FDirectLighting\n{\n  vec3 Diffuse;\n  vec3 Specular;\n};\nstruct FPixelMaterialInputs\n{\n  vec3 Normal;\n  vec3 EmissiveColor;\n  float Opacity;\n  float OpacityMask;\n  vec3 BaseColor;\n  float Metallic;\n  float Specular;\n  float Roughness;\n  float AmbientOcclusion;\n  float Anisotropy;\n  float Tangent;\n  float Refraction;\n  float PixelDepthOffset;\n  float ShadingModel;\n  float TwoSidedSign;\n  float RoughnessWithClamp;\n  vec3 DiffuseColor;\n  vec3 SpecularColor;\n  vec3 Subsurface;\n};\nstruct FMaterialPixelParameters {\n  float IndirectIrradiance;\n  vec2 TexCoords_0;\n  vec2 TexCoords_1;\n  vec4 VertexColor;\n  vec3 WorldNormal;\n  vec3 WorldTangent;\n  vec3 ReflectionVector;\n  vec3 CameraVector;\n  vec3 LightVector;\n  vec4 SvPosition;\n  vec4 ScreenPosition;\n  mat3 TangentToWorld;\n  vec3 AbsoluteWorldPosition;\n  vec3 ObjectWorldPosition;\n  vec2 LightmapUVs;\n  int PrimitiveId;\n};\nstruct FMaterialVertexParameters {\n  vec3 WorldPosition;\n  vec4 VertexColor;\n};\nfloat Luminance( vec3 LinearColor )\n{\n  return dot( LinearColor, vec3( 0.3, 0.59, 0.11 ) );\n}\nfloat ComputeReflectionCaptureMipFromRoughness(float Roughness, float CubemapMaxMip)\n{\n  float LevelFrom1x1 = 1.000001 - 1.2 * log2(Roughness);\n  return CubemapMaxMip - 1. - LevelFrom1x1;\n}\nuniform samplerCube cc_ibl_map_sky;\nvec3 GetSkyLightReflection(vec3 ReflectionVector, float Roughness, out float OutSkyAverageBrightness) {\n  float AbsoluteSpecularMip = ComputeReflectionCaptureMipFromRoughness(Roughness, cc_view_SkyLightParameters.x);\n  vec3 Reflection = decodeCCRGBE(fragTextureLod(cc_ibl_map_sky, ReflectionVector, AbsoluteSpecularMip)).rgb;\n  OutSkyAverageBrightness = cc_view_SkyColor.w * Luminance( cc_view_SkyColor.rgb );\n  return Reflection * cc_view_SkyColor.rgb;\n}\nvec3 posWS2screen (vec3 posWS) {\n  vec4 res = cc_matViewProj * vec4(posWS, 1.);\n  res.xyz /= res.w;\n  res.xyz = res.xyz * 0.5 + 0.5;\n  return res.xyz;\n}\nfloat GGX_Mobile(float Roughness, float NoH, vec3 H, vec3 N)\n{\n    vec3 NxH = cross(N, H);\n    float OneMinusNoHSqr = dot(NxH, NxH);\n    float a = Roughness * Roughness;\n    float n = NoH * a;\n    float p = a / (OneMinusNoHSqr + n * n);\n    return p * p;\n}\nfloat CalcSpecular(float Roughness, float RoughnessWithClamp, float NoH, vec3 H, vec3 N)\n{\n  return (Roughness*0.25 + 0.25) * GGX_Mobile(RoughnessWithClamp, NoH, H, N);\n}\nFDirectLighting MobileIntegrateBxDF(FPixelMaterialInputs ShadingModelContext, vec3 N, vec3 H, float NoH)\n{\n  FDirectLighting Lighting;\n  Lighting.Specular = ShadingModelContext.SpecularColor * CalcSpecular(ShadingModelContext.Roughness, ShadingModelContext.RoughnessWithClamp, NoH, H, N);\n  Lighting.Diffuse = ShadingModelContext.DiffuseColor;\n  return Lighting;\n}\nvec3 EnvBRDF(sampler2D PreIntegratedGF, vec3 SpecularColor, float Roughness, float NoV ) {\n  vec2 AB = texture2D(PreIntegratedGF, vec2( NoV, Roughness )).rg;\n  vec3 GF = SpecularColor * AB.x + clamp(50.0 * SpecularColor.g, 0.0, 1.0) * AB.y;\n  return GF;\n}\nuniform sampler2D cc_ibl_cluster_InfoTexture;\nuniform sampler2D cc_ibl_cluster_Texture;\nuniform sampler2D cc_ibl_cluster_CubemapAtlas;\nvec2 envMapEquirect(vec3 wcNormal) {\n  float phi = acos(-wcNormal.y);\n  float theta = atan(1. * wcNormal.x, wcNormal.z) + 3.14159265359;\n  vec2 uv = vec2(theta / 6.28318530718, 1. - phi / 3.14159265359);\n  return uv;\n}\nfloat ComputeMixingWeight(float IndirectIrradiance, float AverageBrightness, float Roughness)\n{\n  float MixingAlpha = smoothstep(0., 1., clamp(Roughness * 5.000001 + -0.5, 0.0, 1.0));\n  float MixingWeight = IndirectIrradiance / max(AverageBrightness, .0001);\n  MixingWeight = min(MixingWeight, 10000.000001);\n  return mix(1.0, MixingWeight, MixingAlpha);\n}\nvec3 GetLookupVectorForSphereCapture(vec3 ReflectionVector, vec3 WorldPosition, vec4 SphereCapturePositionAndRadius, float NormalizedDistanceToCapture, vec3 LocalCaptureOffset, inout float DistanceAlpha)\n{\n  vec3 ProjectedCaptureVector = ReflectionVector;\n  float ProjectionSphereRadius = SphereCapturePositionAndRadius.w;\n  float SphereRadiusSquared = ProjectionSphereRadius * ProjectionSphereRadius;\n  vec3 LocalPosition = WorldPosition - SphereCapturePositionAndRadius.xyz;\n  float LocalPositionSqr = dot(LocalPosition, LocalPosition);\n  vec3 QuadraticCoef;\n  QuadraticCoef.x = 1.;\n  QuadraticCoef.y = dot(ReflectionVector, LocalPosition);\n  QuadraticCoef.z = LocalPositionSqr - SphereRadiusSquared;\n  float Determinant = QuadraticCoef.y * QuadraticCoef.y - QuadraticCoef.z;\n  if (Determinant >= 0.)\n  {\n    float FarIntersection = sqrt(Determinant) - QuadraticCoef.y;\n    vec3 LocalIntersectionPosition = LocalPosition + FarIntersection * ReflectionVector;\n    ProjectedCaptureVector = normalize(LocalIntersectionPosition - LocalCaptureOffset);\n    float x = clamp(2.5 * NormalizedDistanceToCapture - 1.5, 0.0, 1.0);\n    DistanceAlpha = 1. - x*x*(3. - 2.*x);\n  }\n  return ProjectedCaptureVector;\n}\nvoid EvaluateClusterIBL(float iblIndex, FMaterialPixelParameters MaterialParameters, float mip, float IndirectIrradiance, inout vec4 ImageBasedReflections, inout vec2 CompositedAverageBrightness) {\n  float iblV = (iblIndex + 0.5) * cc_ibl_cluster_InfoTextureInvSize.y;\n  vec4 posRange = texture2D(cc_ibl_cluster_InfoTexture, vec2(0.5 * cc_ibl_cluster_InfoTextureInvSize.x, iblV));\n  float iblDistance = length(MaterialParameters.AbsoluteWorldPosition - posRange.xyz);\n  float DistanceAlpha = 0.;\n  vec3 ProjectedCaptureVector = MaterialParameters.ReflectionVector;\n  if (iblDistance < posRange.w) {\n    float NormalizedDistanceToCapture = clamp(iblDistance / posRange.w, 0.0, 1.0);\n    ProjectedCaptureVector = GetLookupVectorForSphereCapture(ProjectedCaptureVector, MaterialParameters.AbsoluteWorldPosition, posRange, NormalizedDistanceToCapture, vec3(0.0), DistanceAlpha);\n  }\n  vec4 data3 = texture2D(cc_ibl_cluster_InfoTexture, vec2(2.5 * cc_ibl_cluster_InfoTextureInvSize.x, iblV));\n  float AverageBrightness = data3.x;\n  float brightness = data3.y;\n  vec2 uv = envMapEquirect(ProjectedCaptureVector);\n  vec4 uvMapping = texture2D(cc_ibl_cluster_InfoTexture, vec2(1.5 * cc_ibl_cluster_InfoTextureInvSize.x, iblV));\n  vec2 scaleUV = vec2(uvMapping.z, uvMapping.w * 0.5);\n  vec2 rgbUV = uvMapping.xy + scaleUV * uv;\n  vec2 aUV = uvMapping.xy + scaleUV * vec2(uv.x, uv.y + 1.);\n  vec4 SpecularIBL = decodeCCRGBE(fragTextureLod(cc_ibl_cluster_CubemapAtlas, rgbUV, mip));\n  float pixelBrightness = decodeCCRGBE(fragTextureLod(cc_ibl_cluster_CubemapAtlas, aUV, mip)).r;\n  ImageBasedReflections.rgb += SpecularIBL.rgb * brightness * DistanceAlpha * ImageBasedReflections.a;\n  ImageBasedReflections.a *= 1. - (pixelBrightness * DistanceAlpha);\n  CompositedAverageBrightness.x += AverageBrightness * DistanceAlpha * CompositedAverageBrightness.y;\n  CompositedAverageBrightness.y *= 1. - DistanceAlpha;\n}\nvoid EvalCluster (float clusterU, float clusterV, in FMaterialPixelParameters MaterialParameters, float mip, float IndirectIrradiance, inout vec4 ImageBasedReflections, vec2 CompositedAverageBrightness) {\n  #if CC_IBL_MaxPixelsPerCell\n    int calcedIblCount = 0;\n    for (float pixelIndex = 0.5; pixelIndex < float(CC_IBL_MaxPixelsPerCell); pixelIndex++) {\n      vec4 iblIndices = texture2D(cc_ibl_cluster_Texture, vec2(cc_ibl_cluster_TextureSize.y * (clusterU + pixelIndex), clusterV));\n      vec4 indices = iblIndices * 255.0;\n      for (int e = 0; e < 4; e++) {\n        float iblIndex = indices[e];\n        if (iblIndex <= 0.0)\n          break;\n          EvaluateClusterIBL(iblIndex, MaterialParameters, mip, IndirectIrradiance, ImageBasedReflections, CompositedAverageBrightness);\n      }\n    }\n  #endif\n}\nfloat GetSpecularOcclusion(float NoV, float RoughnessSq, float AO)\n{\n  return clamp(pow( NoV + AO, RoughnessSq ) - 1. + AO, 0.0, 1.0);\n}\nvec3 GetOffSpecularPeakReflectionDir(vec3 Normal, vec3 ReflectionVector, float Roughness)\n{\n  float a = Square(Roughness);\n  return mix( Normal, ReflectionVector, (1. - a) * ( sqrt(1. - a) + a ) );\n}\nuniform sampler2D cc_planar_reflection_Texture;\nvec4 GetPlanarReflection (FMaterialPixelParameters MaterialParameters, GlobalView View) {\n  vec4 planarReflection = vec4(0.);\n  float DistanceFade = 1. - clamp(abs(MaterialParameters.AbsoluteWorldPosition.y) / 0.1, 0.0, 1.0);\n  if (DistanceFade > 0.) {\n    vec3 CameraToPixel = -MaterialParameters.CameraVector;\n    vec3 MirroredCameraVector = reflect(CameraToPixel, -cc_view_pr_reflectionPlane.xyz);\n    vec3 MirroredNormal = (cc_view_inverse_transpose_mirror * vec4(MaterialParameters.WorldNormal, 0.)).xyz;\n    vec3 MirroredReflectionVectorOffNormal = reflect(MirroredCameraVector, MirroredNormal);\n    vec3 VirtualReflectionSpherePosition = MaterialParameters.AbsoluteWorldPosition + MirroredReflectionVectorOffNormal * cc_view_pr_parameters.y;\n    vec2 screenUV = posWS2screen(VirtualReflectionSpherePosition.rgb).xy;\n    planarReflection = texture2D(cc_planar_reflection_Texture, screenUV * cc_view_pr_parameters.x);\n    planarReflection.a *= DistanceFade;\n    planarReflection.rgb /= View.PreExposure;\n  }\n  return planarReflection;\n}\nvec3 GetImageBasedReflectionLighting(FMaterialPixelParameters MaterialParameters, FPixelMaterialInputs ShadingModelContext, float IndirectIrradiance, GlobalView View) {\n  float Roughness = ShadingModelContext.Roughness;\n  float RoughnessSq = Roughness * Roughness;\n  float NoV = max(dot(MaterialParameters.WorldNormal, MaterialParameters.CameraVector), 0.);\n  float AO = ShadingModelContext.AmbientOcclusion;\n  float SpecularOcclusion = GetSpecularOcclusion(NoV, RoughnessSq, AO);\n  vec2 CompositedAverageBrightness = vec2(0.0, 1.0);\n  vec4 ImageBasedReflections = vec4(vec3(0.), SpecularOcclusion);\n  vec3 ReflectionVector = 2. * dot( MaterialParameters.CameraVector, MaterialParameters.WorldNormal ) * MaterialParameters.WorldNormal - MaterialParameters.CameraVector;\n  ReflectionVector = GetOffSpecularPeakReflectionDir(MaterialParameters.WorldNormal, ReflectionVector, Roughness);\n  MaterialParameters.ReflectionVector = ReflectionVector;\n  if (ImageBasedReflections.a > 0.) {\n    vec4 planarReflection = GetPlanarReflection(MaterialParameters, View);\n    ImageBasedReflections.rgb += planarReflection.rgb * ImageBasedReflections.a;\n    ImageBasedReflections.a -= planarReflection.a;\n  }\n  vec3 cellCoords = floor((MaterialParameters.AbsoluteWorldPosition - cc_ibl_cluster_BoundsMin.xyz) * cc_ibl_cluster_CellsCountByBoundsSizeAndPixelsPerCell.xyz);\n  if (ImageBasedReflections.a <= 0. || (cellCoords.x < 0.) || (cellCoords.y < 0.) || (cellCoords.z < 0.) ||\n      (cellCoords.x > cc_ibl_cluster_CellsMax.x) || (cellCoords.y > cc_ibl_cluster_CellsMax.y) || (cellCoords.z > cc_ibl_cluster_CellsMax.z)) {\n  }\n  else {\n    float mip = ComputeReflectionCaptureMipFromRoughness(Roughness, 7.000001);\n    float cellIndex = dot(cc_ibl_cluster_CellsDot.xyz, cellCoords);\n    float clusterV = floor(cellIndex * cc_ibl_cluster_TextureSize.y);\n    float clusterU = floor(cellIndex - (clusterV * cc_ibl_cluster_TextureSize.x));\n    clusterV = (clusterV + 0.5) * cc_ibl_cluster_TextureSize.z;\n    EvalCluster(clusterU, clusterV, MaterialParameters, mip, IndirectIrradiance, ImageBasedReflections, CompositedAverageBrightness);\n  }\n  ImageBasedReflections.rgb *= View.IndirectLightingColorScale;\n  CompositedAverageBrightness.x *= Luminance( View.IndirectLightingColorScale );\n  if (ImageBasedReflections.a > 0.) {\n    float SkyAverageBrightness = 1.;\n    vec3 SkyLighting = GetSkyLightReflection(ReflectionVector, Roughness, SkyAverageBrightness);\n    ImageBasedReflections.rgb += ImageBasedReflections.a * SkyLighting;\n    CompositedAverageBrightness.x += SkyAverageBrightness * CompositedAverageBrightness.y;\n      ImageBasedReflections.rgb *= ComputeMixingWeight(IndirectIrradiance, CompositedAverageBrightness.x, Roughness);\n  }\n    vec3 brdf = EnvBRDF(preIntegratedGF, ShadingModelContext.SpecularColor, Roughness, NoV);\n  ImageBasedReflections.rgb *= brdf;\n  return ImageBasedReflections.rgb;\n}\n#if (CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD)\n    varying vec3 v_luv;\n    uniform sampler2D cc_lightingMap;\n    #if USE_INSTANCING\n      varying vec4 v_lightingMapAdds0;\n      varying vec4 v_lightingMapAdds1;\n      varying vec4 v_lightingMapScales0;\n      varying vec4 v_lightingMapScales1;\n    #endif\n#endif\nvec4 lightingBase (FPixelMaterialInputs ShadingModelContext, FMaterialPixelParameters MaterialParameters, GlobalView View, vec4 shadowPos) {\n  vec3 Color = vec3(0);\n  #if CC_Lighting_Heavily\n    Color += vec3(0.1, 0, 0);\n  #else\n    vec3 direction = normalize(-cc_mainLitDir.xyz);\n    vec3 lightColor = cc_mainLitColor.rgb * cc_mainLitColor.w;\n    lightColor /= 3.14159265359;\n    float NoL = max(0., dot(MaterialParameters.WorldNormal, direction));\n    vec3 H = normalize(MaterialParameters.CameraVector + direction);\n    float NoH = max(0., dot(MaterialParameters.WorldNormal, H));\n    float Shadow = 1.;\n    #if CC_RECEIVE_SHADOW\n      if (cc_global_parameters.y != 0.) {\n          {\n            vec4 pos = ApplyShadowDepthBias_FaceNormal(shadowPos, MaterialParameters.WorldNormal);\n            float pcf = cc_shadowWHPBInfo.z;\n            if (pcf > 1.9) Shadow = CCGetShadowFactorSoft2X(pos);\n            else if (pcf > 0.9) Shadow = CCGetShadowFactorSoft(pos);\n            else Shadow = CCGetShadowFactorHard(pos);\n            Shadow = mix(Shadow, 1.0, cc_shadowNFLSInfo.w);\n          }\n      }\n    #endif\n    FDirectLighting Lighting = MobileIntegrateBxDF(ShadingModelContext, MaterialParameters.WorldNormal, H, NoH);\n    Color += (Shadow * NoL) * lightColor * (Lighting.Diffuse + Lighting.Specular );\n    float IndirectIrradiance = MaterialParameters.IndirectIrradiance * Shadow;\n    #if CC_ENABLE_IBL\n      vec3 SpecularIBL = GetImageBasedReflectionLighting(MaterialParameters, ShadingModelContext, IndirectIrradiance, View);\n      SpecularIBL *= min(Shadow * 2., 1.);\n      Color += SpecularIBL;\n    #endif\n    Color += ShadingModelContext.EmissiveColor;\n  #endif\n  return vec4(Color, ShadingModelContext.Opacity);\n}\n#if CC_FORWARD_ADD\n#if CC_PIPELINE_TYPE == 0\n# define LIGHTS_PER_PASS 1\n#else\n# define LIGHTS_PER_PASS 10\n#endif\n#if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\nuniform highp vec4 cc_lightPos[LIGHTS_PER_PASS];\n  uniform vec4 cc_lightColor[LIGHTS_PER_PASS];\n  uniform vec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];\n  uniform vec4 cc_lightDir[LIGHTS_PER_PASS];\n#endif\n#endif\nfloat SpotAttenuationMask(vec3 L, vec3 SpotDirection, vec2 SpotAngles)\n{\n  return clamp((dot(L, -SpotDirection) - SpotAngles.x) * SpotAngles.y, 0.0, 1.0);\n}\nfloat SpotAttenuation(vec3 L, vec3 SpotDirection, vec2 SpotAngles)\n{\n  float ConeAngleFalloff = Square(SpotAttenuationMask(L, SpotDirection, SpotAngles));\n  return ConeAngleFalloff;\n}\nvoid lightingAddPerLight(\n  in FPixelMaterialInputs ShadingModelContext, in FMaterialPixelParameters MaterialParameters,\n  vec3 pos, bool isSpotLight,\n  vec3 lightColor, float intensity,\n  float range, float spotAngle,\n  vec3 dir,\n  vec4 shadowPos,\n  inout vec3 outColor) {\n  vec3 toLight = pos - MaterialParameters.AbsoluteWorldPosition;\n  float distanceSqr = dot(toLight, toLight);\n  vec3 L = toLight * rsqrt(distanceSqr);\n  vec3 PointH = normalize(MaterialParameters.CameraVector + L);\n  float PointNoL = max(0., dot(MaterialParameters.WorldNormal, L));\n  float PointNoH = max(0., dot(MaterialParameters.WorldNormal, PointH));\n  float Attenuation;\n  {\n    Attenuation = 1. / ( distanceSqr + 0.01 );\n    float InvRadius = 1.0 / max(range, 0.01);\n    float LightRadiusMask = Square(clamp(1. - Square(distanceSqr * (InvRadius * InvRadius)), 0.0, 1.0));\n    Attenuation *= LightRadiusMask;\n  }\n  if (isSpotLight) {\n    vec3 SL = normalize(toLight);\n    float cosInner = 1.;\n    float cosOuter = spotAngle;\n    float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\n    vec2 SpotAngles = vec2(cosOuter, litAngleScale);\n    Attenuation *= SpotAttenuation(L, dir, SpotAngles);\n    float shadow = 1.;\n    #if CC_RECEIVE_SHADOW\n        {\n          vec4 pos = ApplyShadowDepthBias_FaceNormal(shadowPos, MaterialParameters.WorldNormal);\n          float pcf = cc_shadowWHPBInfo.z;\n          if (pcf > 1.9) shadow = CCGetShadowFactorSoft2X(pos);\n          else if (pcf > 0.9) shadow = CCGetShadowFactorSoft(pos);\n          else shadow = CCGetShadowFactorHard(pos);\n          shadow = mix(shadow, 1.0, cc_shadowNFLSInfo.w);\n        }\n    #endif\n    lightColor *= shadow;\n  }\n  FDirectLighting Lighting = MobileIntegrateBxDF(ShadingModelContext, MaterialParameters.WorldNormal, PointH, PointNoH);\n  outColor += min(vec3(65000.0), (Attenuation * PointNoL) * lightColor * intensity / 3.14159265359 * (Lighting.Diffuse + Lighting.Specular));\n}\nuniform sampler2D cc_light_cluster_InfoTexture;\nuniform sampler2D cc_light_cluster_Texture;\nvoid lightingCluster(float clusterIndex, in FPixelMaterialInputs ShadingModelContext, in FMaterialPixelParameters MaterialParameters, vec4 shadowPos, inout vec3 outColor) {\n  #if CC_Lighting_Heavily\n    outColor += vec3(0.1, 0, 0);\n  #else\n    float iblV = (clusterIndex + 0.5) * cc_light_cluster_InfoTextureInvSize.y;\n    vec4 lightPos = texture2D(cc_light_cluster_InfoTexture, vec2(0.5 * cc_light_cluster_InfoTextureInvSize.x, iblV));\n    vec4 lightColor = texture2D(cc_light_cluster_InfoTexture, vec2(1.5 * cc_light_cluster_InfoTextureInvSize.x, iblV));\n    vec4 lightSizeRangeAngle = texture2D(cc_light_cluster_InfoTexture, vec2(2.5 * cc_light_cluster_InfoTextureInvSize.x, iblV));\n    vec4 lightDir = texture2D(cc_light_cluster_InfoTexture, vec2(3.5 * cc_light_cluster_InfoTextureInvSize.x, iblV));\n    lightingAddPerLight(\n      ShadingModelContext, MaterialParameters,\n      lightPos.xyz, lightPos.w > 0.0,\n      lightColor.rgb, lightColor.w,\n      lightSizeRangeAngle.y, lightSizeRangeAngle.z,\n      lightDir.xyz,\n      shadowPos,\n      outColor\n    );\n  #endif\n}\n#if CC_ENABLE_CLUSTERED_LIGHT_CULLING && CC_ENABLE_Builtin_CLUSTERED_LIGHT_CULLING\n  float SmoothDistAtt (float distSqr, float invSqrAttRadius) {\n    float factor = distSqr * invSqrAttRadius;\n    float smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\n    return smoothFactor * smoothFactor;\n  }\n  float GetDistAtt (float distSqr, float invSqrAttRadius) {\n    float attenuation = 1.0 / max(distSqr, 0.01*0.01);\n    attenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\n    return attenuation;\n  }\n  float GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\n    float cd = dot(litDir, L);\n    float attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\n    return (attenuation * attenuation);\n  }\n  #if CC_USE_IBL\n    uniform samplerCube cc_environment;\n    #if CC_USE_DIFFUSEMAP\n      uniform samplerCube cc_diffuseMap;\n    #endif\n  #endif\n  float GGXMobile (float roughness, float NoH, vec3 H, vec3 N) {\n    vec3 NxH = cross(N, H);\n    float OneMinusNoHSqr = dot(NxH, NxH);\n    float a = roughness * roughness;\n    float n = NoH * a;\n    float p = a / (OneMinusNoHSqr + n * n);\n    return p * p;\n  }\n  float CalcSpecular (float roughness, float NoH, vec3 H, vec3 N) {\n    return (roughness * 0.25 + 0.25) * GGXMobile(roughness, NoH, H, N);\n  }\n  vec3 BRDFApprox (vec3 specular, float roughness, float NoV) {\n    const vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);\n    const vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);\n    vec4 r = roughness * c0 + c1;\n    float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\n    vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\n    AB.y *= clamp(50.0 * specular.g, 0.0, 1.0);\n    return specular * AB.x + AB.y;\n  }\n  #if USE_REFLECTION_DENOISE\n  #endif\n  struct StandardSurface {\n    vec4 albedo;\n    vec3 position;\n    vec3 normal;\n    vec3 emissive;\n    vec3 lightmap;\n    float lightmap_test;\n    float roughness;\n    float metallic;\n    float occlusion;\n  };\n  readonly buffer b_ccLightsBuffer { vec4 b_ccLights[]; };\n  readonly buffer b_clusterLightIndicesBuffer { uint b_clusterLightIndices[]; };\n  readonly buffer b_clusterLightGridBuffer { uvec4 b_clusterLightGrid[]; };\n  struct CCLight\n  {\n    vec4 cc_lightPos;\n    vec4 cc_lightColor;\n    vec4 cc_lightSizeRangeAngle;\n    vec4 cc_lightDir;\n  };\n  struct Cluster\n  {\n    vec3 minBounds;\n    vec3 maxBounds;\n  };\n  struct LightGrid\n  {\n    uint offset;\n    uint ccLights;\n  };\n  CCLight getCCLight(uint i)\n  {\n    CCLight light;\n    light.cc_lightPos = b_ccLights[4u * i + 0u];\n    light.cc_lightColor = b_ccLights[4u * i + 1u];\n    light.cc_lightSizeRangeAngle = b_ccLights[4u * i + 2u];\n    light.cc_lightDir = b_ccLights[4u * i + 3u];\n    return light;\n  }\n  LightGrid getLightGrid(uint cluster)\n  {\n    uvec4 gridvec = b_clusterLightGrid[cluster];\n    LightGrid grid;\n    grid.offset = gridvec.x;\n    grid.ccLights = gridvec.y;\n    return grid;\n  }\n  uint getGridLightIndex(uint start, uint offset)\n  {\n    return b_clusterLightIndices[start + offset];\n  }\n  uint getClusterZIndex(vec4 worldPos)\n  {\n    float scale = float(24) / log(cc_nearFar.y / cc_nearFar.x);\n    float bias = -(float(24) * log(cc_nearFar.x) / log(cc_nearFar.y / cc_nearFar.x));\n    float eyeDepth = -(cc_matView * worldPos).z;\n    uint zIndex = uint(max(log(eyeDepth) * scale + bias, 0.0));\n    return zIndex;\n  }\n  uint getClusterIndex(vec4 fragCoord, vec4 worldPos)\n  {\n    uint zIndex = getClusterZIndex(worldPos);\n    float clusterSizeX = ceil(cc_nativeSize.x / float(16));\n    float clusterSizeY = ceil(cc_nativeSize.y / float(8));\n    uvec3 indices = uvec3(uvec2(fragCoord.xy / vec2(clusterSizeX, clusterSizeY)), zIndex);\n    uint cluster = (16u * 8u) * indices.z + 16u * indices.y + indices.x;\n    return cluster;\n  }\n  vec4 CCClusterShadingAdditive (StandardSurface s, vec4 shadowPos) {\n    vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n    vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n    vec3 diffuseContrib = diffuse / 3.14159265359;\n    vec3 N = normalize(s.normal);\n    vec3 V = normalize(cc_cameraPos.xyz - s.position);\n    float NV = max(abs(dot(N, V)), 0.001);\n    specular = BRDFApprox(specular, s.roughness, NV);\n    vec3 finalColor = vec3(0.0);\n    uint cluster = getClusterIndex(gl_FragCoord, vec4(s.position, 1.0));\n    LightGrid grid = getLightGrid(cluster);\n    uint numLights = grid.ccLights;\n    for (uint i = 0u; i < 100u; i++) {\n      if (i >= numLights) break;\n      uint lightIndex = getGridLightIndex(grid.offset, i);\n      CCLight light = getCCLight(lightIndex);\n      vec3 SLU = light.cc_lightPos.xyz - s.position;\n      vec3 SL = normalize(SLU);\n      vec3 SH = normalize(SL + V);\n      float SNL = max(dot(N, SL), 0.001);\n      float SNH = max(dot(N, SH), 0.0);\n      float distSqr = dot(SLU, SLU);\n      float litRadius = light.cc_lightSizeRangeAngle.x;\n      float litRadiusSqr = litRadius * litRadius;\n      float illum = 3.14159265359 * (litRadiusSqr / max(litRadiusSqr , distSqr));\n      float attRadiusSqrInv = 1.0 / max(light.cc_lightSizeRangeAngle.y, 0.01);\n      attRadiusSqrInv *= attRadiusSqrInv;\n      float att = GetDistAtt(distSqr, attRadiusSqrInv);\n      vec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\n      if (light.cc_lightPos.w > 0.0) {\n        float cosInner = max(dot(-light.cc_lightDir.xyz, SL), 0.01);\n        float cosOuter = light.cc_lightSizeRangeAngle.z;\n        float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\n        float litAngleOffset = -cosOuter * litAngleScale;\n        att *= GetAngleAtt(SL, -light.cc_lightDir.xyz, litAngleScale, litAngleOffset);\n      }\n      vec3 lightColor = light.cc_lightColor.rgb;\n      float shadow = 1.0;\n      #if CC_RECEIVE_SHADOW\n        if (light.cc_lightPos.w > 0.0) {\n            {\n              float pcf = cc_shadowWHPBInfo.z;\n              if (pcf > 1.9) shadow = CCGetSpotLightShadowFactorSoft2X(shadowPos, s.position);\n              else if (pcf > 0.9) shadow = CCGetSpotLightShadowFactorSoft(shadowPos, s.position);\n              else shadow = CCGetSpotLightShadowFactorHard(shadowPos, s.position);\n            }\n        }\n      #endif\n      lightColor *= shadow;\n      finalColor += SNL * lightColor * light.cc_lightColor.w * illum * att * (diffuseContrib + lspec);\n    }\n    return vec4(finalColor, 0.0);\n  }\n#endif\nvec4 lightingAdd (in FPixelMaterialInputs ShadingModelContext, in FMaterialPixelParameters MaterialParameters, vec4 shadowPos) {\n  vec3 color = vec3(0.);\n  #if CC_ENABLE_CLUSTERED_LIGHT_CULLING && CC_ENABLE_Builtin_CLUSTERED_LIGHT_CULLING\n    StandardSurface s;\n    s.albedo.xyz = ShadingModelContext.BaseColor;\n    s.albedo.w = ShadingModelContext.Opacity;\n    s.metallic = ShadingModelContext.Metallic;\n    s.roughness = ShadingModelContext.Roughness;\n    s.normal = MaterialParameters.WorldNormal;\n    s.position = MaterialParameters.AbsoluteWorldPosition;\n    color = CCClusterShadingAdditive(s, shadowPos).rgb;\n  #else\n  vec3 cellCoords = floor((MaterialParameters.AbsoluteWorldPosition - cc_light_cluster_BoundsMin.xyz) * cc_light_cluster_CellsCountByBoundsSizeAndPixelsPerCell.xyz);\n  if ((cellCoords.x < 0.) || (cellCoords.y < 0.) || (cellCoords.z < 0.) ||\n      (cellCoords.x > cc_light_cluster_CellsMax.x) ||\n      (cellCoords.y > cc_light_cluster_CellsMax.y) ||\n      (cellCoords.z > cc_light_cluster_CellsMax.z)) {\n  }\n  else {\n    float cellIndex = dot(cc_light_cluster_CellsDot.xyz, cellCoords);\n    float clusterV = floor(cellIndex * cc_light_cluster_TextureSize.y);\n    float clusterU = cellIndex - (clusterV * cc_light_cluster_TextureSize.x);\n    clusterV = (clusterV + 0.5) * cc_light_cluster_TextureSize.z;\n    #if CC_LIGHT_MaxPixelsPerCell\n    for (float cellIndex = 0.5; cellIndex < float(CC_LIGHT_MaxPixelsPerCell); cellIndex++) {\n      vec4 lightIndices = texture2D(cc_light_cluster_Texture, vec2(cc_light_cluster_TextureSize.y * (clusterU + cellIndex), clusterV));\n      vec4 indices = lightIndices * 255.0;\n      for (int e = 0; e < 4; e++) {\n        if (indices[e] <= 0.0) {\n          break;\n        }\n        lightingCluster(indices[e], ShadingModelContext, MaterialParameters, shadowPos, color);\n      }\n      if (cellIndex > cc_light_cluster_CellsCountByBoundsSizeAndPixelsPerCell.w) {\n        break;\n      }\n    }\n    #endif\n  }\n  #endif\n  return vec4(color, ShadingModelContext.Opacity);\n}\nvoid InitShadingModelContext(inout FPixelMaterialInputs ShadingModelContext, FMaterialPixelParameters MaterialParameters) {\n  ShadingModelContext.RoughnessWithClamp = max(0.015625, ShadingModelContext.Roughness);\n  float NoV = max(dot(MaterialParameters.WorldNormal, MaterialParameters.CameraVector), 0.);\n  float DielectricSpecular = 0.08 * ShadingModelContext.Specular;\n  ShadingModelContext.DiffuseColor = ShadingModelContext.BaseColor - ShadingModelContext.BaseColor * ShadingModelContext.Metallic;\n  ShadingModelContext.SpecularColor = mix(0.08 * vec3(ShadingModelContext.Specular), ShadingModelContext.BaseColor, ShadingModelContext.Metallic);\n}\nvec4 lighting (FPixelMaterialInputs ShadingModelContext, FMaterialPixelParameters MaterialParameters, GlobalView View, vec4 shadowPos) {\n  vec4 color = vec4(vec3(0.), 1.);\n    #if CC_ENABLE_LIGHTING_BASE\n      color = lightingBase(ShadingModelContext, MaterialParameters, View, shadowPos);\n    #endif\n    #if CC_ENABLE_LIGHTING_ADD && (1 || 1)\n      color += lightingAdd(ShadingModelContext, MaterialParameters, shadowPos);\n    #endif\n  color *= ShadingModelContext.AmbientOcclusion;\n  return color;\n}\nconst float FLT_EPSILON = 0.001;\nconst float FLT_EPSILON2 = 0.01;\nfloat CalculateLineIntegralShared(float FogHeightFalloff, float RayDirectionZ, float RayOriginTerms)\n{\n  float Falloff = max(-127.0, FogHeightFalloff * RayDirectionZ);\n  float LineIntegral = ( 1.0 - exp2(-Falloff) ) / Falloff;\n  float LineIntegralTaylor = log(2.0) - ( 0.5 * (pow(2., log(2.0))) ) * Falloff;\n  return RayOriginTerms * ( abs(Falloff) > FLT_EPSILON2 ? LineIntegral : LineIntegralTaylor );\n}\nvec3 ComputeInscatteringColor(vec3 CameraToReceiver, float CameraToReceiverLength)\n{\n  vec3 Inscattering = FogStruct_ExponentialFogColorParameter.xyz;\n  return Inscattering;\n}\nvec4 GetExponentialHeightFog(vec3 WorldPositionRelativeToCamera, float ExcludeDistance)\n{\n  float MinFogOpacity = FogStruct_ExponentialFogColorParameter.w;\n  float MaxWorldObserverHeight = FogStruct_ExponentialFogParameters.z;\n  vec3 View_WorldCameraOrigin = cc_cameraPos.xyz;\n  vec3 WorldObserverOrigin = vec3(View_WorldCameraOrigin.x, min(View_WorldCameraOrigin.y, MaxWorldObserverHeight), View_WorldCameraOrigin.z);\n  vec3 CameraToReceiver = WorldPositionRelativeToCamera;\n  CameraToReceiver.y += View_WorldCameraOrigin.y - WorldObserverOrigin.y;\n  float CameraToReceiverLengthSqr = dot(CameraToReceiver, CameraToReceiver);\n  float CameraToReceiverLengthInv = rsqrt(CameraToReceiverLengthSqr);\n  float CameraToReceiverLength = CameraToReceiverLengthSqr * CameraToReceiverLengthInv;\n  vec3 CameraToReceiverNormalized = CameraToReceiver * CameraToReceiverLengthInv;\n  float RayOriginTerms = FogStruct_ExponentialFogParameters.x;\n  float RayOriginTermsSecond = FogStruct_ExponentialFogParameters2.x;\n  float RayLength = CameraToReceiverLength;\n  float RayDirectionZ = CameraToReceiver.y;\n  ExcludeDistance = max(ExcludeDistance, FogStruct_ExponentialFogParameters.w);\n  if (ExcludeDistance > 0.)\n  {\n    float ExcludeIntersectionTime = ExcludeDistance * CameraToReceiverLengthInv;\n    float CameraToExclusionIntersectionZ = ExcludeIntersectionTime * CameraToReceiver.y;\n    float ExclusionIntersectionZ = WorldObserverOrigin.y + CameraToExclusionIntersectionZ;\n    float ExclusionIntersectionToReceiverZ = CameraToReceiver.y - CameraToExclusionIntersectionZ;\n    RayLength = (1.0 - ExcludeIntersectionTime) * CameraToReceiverLength;\n    RayDirectionZ = ExclusionIntersectionToReceiverZ;\n    float Exponent = max(-127.0, FogStruct_ExponentialFogParameters.y * (ExclusionIntersectionZ - FogStruct_ExponentialFogParameters3.y));\n    RayOriginTerms = FogStruct_ExponentialFogParameters3.x * exp2(-Exponent);\n    float ExponentSecond = max(-127.0, FogStruct_ExponentialFogParameters2.y * (ExclusionIntersectionZ - FogStruct_ExponentialFogParameters2.w));\n    RayOriginTermsSecond = FogStruct_ExponentialFogParameters2.z * exp2(-ExponentSecond);\n  }\n  float ExponentialHeightLineIntegralShared = CalculateLineIntegralShared(FogStruct_ExponentialFogParameters.y, RayDirectionZ, RayOriginTerms) + CalculateLineIntegralShared(FogStruct_ExponentialFogParameters2.y, RayDirectionZ, RayOriginTermsSecond);\n  float ExponentialHeightLineIntegral = ExponentialHeightLineIntegralShared * RayLength;\n  vec3 InscatteringColor = ComputeInscatteringColor(CameraToReceiver, CameraToReceiverLength);\n  vec3 DirectionalInscattering = vec3(0.);\n  float ExpFogFactor = max(clamp(exp2(-ExponentialHeightLineIntegral), 0.0, 1.0), MinFogOpacity);\n  if (FogStruct_ExponentialFogParameters3.w > 0. && CameraToReceiverLength > FogStruct_ExponentialFogParameters3.w)\n  {\n    ExpFogFactor = 1.;\n    DirectionalInscattering = vec3(0.);\n  }\n    vec3 FogColor = (InscatteringColor) * (1. - ExpFogFactor) + DirectionalInscattering;\n  return vec4(FogColor, ExpFogFactor);\n}\nvec4 CalculateHeightFog(vec3 WorldPositionRelativeToCamera)\n{\n  vec3 WorldPosition = WorldPositionRelativeToCamera;\n  float ExcludeDistance = 0.;\n  vec4 FogInscatteringAndOpacity = GetExponentialHeightFog(WorldPositionRelativeToCamera, ExcludeDistance);\n  return FogInscatteringAndOpacity;\n}\n  #if !CC_DEVICE_CAN_BENEFIT_FROM_INPUT_ATTACHMENT || __VERSION__ >= 450\n  #endif\n  const mat3 kernel9 = mat3(\n    0.0625, 0.125, 0.0625,\n    0.125, 0.25, 0.125,\n    0.0625, 0.125, 0.0625\n  );\n  vec4 gaussianBlur9(sampler2D Tex, vec2 UV, float Intensity) {\n    vec3 sum = vec3(0.);\n    vec2 offset = vec2(0.0);\n    const int size = 3;\n    const float start = floor(float(size) / 2.);\n    vec2 normalizedSize = vec2(1.0 / vec2(cc_screenSize.xy));\n    for (int u = 0; u < size; u++) {\n      for (int v = 0; v < size; v++) {\n        offset = normalizedSize * (vec2(u, v) - start) * Intensity;\n        sum += texture2D(Tex, UV + offset).rgb * kernel9[v][u];\n      }\n    }\n    return vec4(sum, texture2D(Tex, UV).a);\n  }\n  void main () {\n    #if CC_DEVICE_CAN_BENEFIT_FROM_INPUT_ATTACHMENT\n        vec4 albedoMap = gl_LastFragData[0];\n        vec4 positionMap = gl_LastFragData[1];\n        vec4 normalMap = gl_LastFragData[2];\n        vec4 emissiveMap = gl_LastFragData[3];\n    #else\n      vec4 albedoMap = texture2D(gbuffer_albedoMap,v_uv);\n      vec4 positionMap = texture2D(gbuffer_positionMap,v_uv);\n      vec4 normalMap = texture2D(gbuffer_normalMap,v_uv);\n      vec4 emissiveMap = texture2D(gbuffer_emissiveMap,v_uv);\n    #endif\n    FMaterialPixelParameters Parameters;\n    Parameters.AbsoluteWorldPosition = positionMap.xyz;\n    Parameters.WorldNormal = normalMap.xyz;\n    Parameters.CameraVector = normalize(cc_cameraPos.xyz - Parameters.AbsoluteWorldPosition);\n    Parameters.ReflectionVector = normalize(reflect(-Parameters.CameraVector, Parameters.WorldNormal));\n    FPixelMaterialInputs PixelMaterialInputs;\n    PixelMaterialInputs.BaseColor = albedoMap.xyz;\n    PixelMaterialInputs.Opacity = albedoMap.w;\n    PixelMaterialInputs.Roughness = positionMap.w;\n    PixelMaterialInputs.Metallic = normalMap.w;\n    PixelMaterialInputs.EmissiveColor = emissiveMap.xyz;\n    Parameters.IndirectIrradiance = emissiveMap.w;\n    PixelMaterialInputs.AmbientOcclusion = 1.;\n    PixelMaterialInputs.Specular = 0.5;\n    float ssao = 1.;\n    if (cc_global_parameters.x != 0.) {\n      ssao = gaussianBlur9(ssao_map, v_uv, 3.0).r;\n    }\n    PixelMaterialInputs.AmbientOcclusion *= ssao;\n    InitShadingModelContext(PixelMaterialInputs, Parameters);\n    GlobalView View;\n    getGlobalView(View);\n    vec4 shadowPos;\n      shadowPos = cc_matLightViewProj * vec4(Parameters.AbsoluteWorldPosition, 1);\n    #if CC_ENABLE_LIGHTING\n      vec4 color = lighting(PixelMaterialInputs, Parameters, View, shadowPos);\n    #else\n      vec4 color = vec4(vec3(0.), 1.);\n    #endif\n    #if !CC_Lighting_Heavily\n      vec4 fogColor = CalculateHeightFog(Parameters.AbsoluteWorldPosition.xyz - cc_cameraPos.xyz);\n      color.rgb = color.rgb * fogColor.a + fogColor.rgb;\n      color.rgb *= View.PreExposure;\n    #endif\n    color.a = 1.;\n    #if CC_DEVICE_CAN_BENEFIT_FROM_INPUT_ATTACHMENT\n        gl_FragData[3] = color;\n    #else\n      gl_FragColor = color;\n    #endif\n  }"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]},{"name":"CCCamera","defines":[]},{"name":"CCShadow","defines":[]},{"name":"CCCustomView","defines":[]}],"samplerTextures":[{"name":"cc_shadowMap","defines":["CC_RECEIVE_SHADOW"]},{"name":"cc_spotLightingMap","defines":["CC_RECEIVE_SHADOW"]},{"name":"cc_ibl_map_sky","defines":[]},{"name":"cc_ibl_cluster_InfoTexture","defines":[]},{"name":"cc_ibl_cluster_Texture","defines":[]},{"name":"cc_ibl_cluster_CubemapAtlas","defines":[]},{"name":"cc_planar_reflection_Texture","defines":[]},{"name":"cc_light_cluster_InfoTexture","defines":[]},{"name":"cc_light_cluster_Texture","defines":[]},{"name":"cc_environment","defines":["CC_ENABLE_CLUSTERED_LIGHT_CULLING","CC_ENABLE_Builtin_CLUSTERED_LIGHT_CULLING","CC_USE_IBL"]},{"name":"cc_diffuseMap","defines":["CC_ENABLE_CLUSTERED_LIGHT_CULLING","CC_ENABLE_Builtin_CLUSTERED_LIGHT_CULLING","CC_USE_IBL","CC_USE_DIFFUSEMAP"]}],"buffers":[],"images":[]},"locals":{"blocks":[{"name":"CCForwardLight","defines":["CC_FORWARD_ADD","CC_ENABLE_CLUSTERED_LIGHT_CULLING"]}],"samplerTextures":[{"name":"cc_lightingMap","defines":["CC_USE_LIGHTMAP","!USE_BATCHING","!CC_FORWARD_ADD"]}],"buffers":[],"images":[]},"statistics":{"CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS":39,"CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS":101}},"defines":[{"name":"CC_RECEIVE_SHADOW","type":"boolean","defines":[]},{"name":"CC_IBL_MaxPixelsPerCell","type":"boolean","defines":[]},{"name":"CC_USE_LIGHTMAP","type":"boolean","defines":[]},{"name":"USE_BATCHING","type":"boolean","defines":["CC_USE_LIGHTMAP"]},{"name":"CC_FORWARD_ADD","type":"boolean","defines":[]},{"name":"USE_INSTANCING","type":"boolean","defines":["CC_USE_LIGHTMAP","!USE_BATCHING","!CC_FORWARD_ADD"]},{"name":"CC_Lighting_Heavily","type":"boolean","defines":[]},{"name":"CC_ENABLE_IBL","type":"boolean","defines":["!CC_Lighting_Heavily"]},{"name":"CC_PIPELINE_TYPE","type":"number","defines":["CC_FORWARD_ADD"],"range":[0,1]},{"name":"CC_FORCE_FORWARD_SHADING","type":"boolean","defines":["CC_FORWARD_ADD"]},{"name":"CC_ENABLE_Builtin_CLUSTERED_LIGHT_CULLING","type":"boolean","defines":["CC_ENABLE_CLUSTERED_LIGHT_CULLING"]},{"name":"CC_USE_IBL","type":"number","defines":["CC_ENABLE_CLUSTERED_LIGHT_CULLING","CC_ENABLE_Builtin_CLUSTERED_LIGHT_CULLING"],"range":[0,2]},{"name":"CC_USE_DIFFUSEMAP","type":"number","defines":["CC_ENABLE_CLUSTERED_LIGHT_CULLING","CC_ENABLE_Builtin_CLUSTERED_LIGHT_CULLING","CC_USE_IBL"],"range":[0,2]},{"name":"USE_REFLECTION_DENOISE","type":"boolean","defines":["CC_ENABLE_CLUSTERED_LIGHT_CULLING","CC_ENABLE_Builtin_CLUSTERED_LIGHT_CULLING"]},{"name":"CC_LIGHT_MaxPixelsPerCell","type":"boolean","defines":["!CC_ENABLE_CLUSTERED_LIGHT_CULLING","!CC_ENABLE_Builtin_CLUSTERED_LIGHT_CULLING"]},{"name":"CC_ENABLE_LIGHTING_BASE","type":"boolean","defines":[]},{"name":"CC_ENABLE_LIGHTING_ADD","type":"boolean","defines":[]},{"name":"CC_ENABLE_LIGHTING","type":"boolean","defines":[]}]}],[{"passes":[{"phase":"deferred-lighting","program":"../resources/Exported/__builtin__/custom-deferred-lighting|lighting-vs|lighting-fs","embeddedMacros":{"CC_IBL_MaxPixelsPerCell":0,"CC_LIGHT_MaxPixelsPerCell":0,"CC_REFLECTIONS_TYPE":1,"CC_ENABLE_IBL":1,"CC_ENABLE_LIGHTING":1,"CC_ENABLE_LIGHTING_ADD":1,"CC_ENABLE_LIGHTING_BASE":1},"rasterizerState":{"cullMode":0},"depthStencilState":{"depthFunc":4,"depthTest":true,"depthWrite":false},"properties":{"preIntegratedGF":{"value":"white","type":28},"ssao_map":{"value":"white","type":28}}}]}]]],0,0,[],[],[]]
