[1,0,0,[["cc.EffectAsset",["_name","shaders","techniques"],0]],[[0,0,1,2,4]],[[0,"../resources/Exported/LakeWoodenHouse/Maps/Demonstrationlight.Demonstrationlight_PersistentLevel.BP_LightStage.MaterialInstanceDynamic_2",[{"hash":1683046047,"name":"../resources/Exported/LakeWoodenHouse/Maps/Demonstrationlight.Demonstrationlight_PersistentLevel.BP_LightStage.MaterialInstanceDynamic_2|unlit-vs|unlit-fs","blocks":[{"name":"SharedUBOs_Properties","stageFlags":17,"binding":0,"members":[{"name":"VectorParameter_0","type":16,"count":1},{"name":"ScalarParameter_0","type":16,"count":1},{"name":"ScalarParameter_1","type":16,"count":1},{"name":"ScalarParameter_2","type":16,"count":1}],"defines":[]}],"samplerTextures":[{"name":"Material_TextureCube_0","type":31,"count":1,"stageFlags":17,"binding":1,"defines":[]}],"samplers":[],"textures":[],"buffers":[{"name":"b_ccLightsBuffer","memoryAccess":1,"stageFlags":16,"binding":2,"defines":["CC_ENABLE_CLUSTERED_LIGHT_CULLING","CC_ENABLE_Builtin_CLUSTERED_LIGHT_CULLING"]},{"name":"b_clusterLightIndicesBuffer","memoryAccess":1,"stageFlags":16,"binding":3,"defines":["CC_ENABLE_CLUSTERED_LIGHT_CULLING","CC_ENABLE_Builtin_CLUSTERED_LIGHT_CULLING"]},{"name":"b_clusterLightGridBuffer","memoryAccess":1,"stageFlags":16,"binding":4,"defines":["CC_ENABLE_CLUSTERED_LIGHT_CULLING","CC_ENABLE_Builtin_CLUSTERED_LIGHT_CULLING"]}],"images":[],"subpassInputs":[],"attributes":[{"name":"a_position","format":32,"location":0,"defines":[]},{"name":"a_normal","format":32,"location":1,"defines":[]},{"name":"a_texCoord","format":21,"location":2,"defines":[]},{"name":"a_tangent","format":44,"location":3,"defines":[]},{"name":"a_vertexId","format":11,"location":6,"defines":["CC_USE_MORPH"]},{"name":"a_joints","location":4,"defines":["CC_USE_SKINNING"]},{"name":"a_weights","format":44,"location":5,"defines":["CC_USE_SKINNING"]},{"name":"a_jointAnimInfo","format":44,"isInstanced":true,"location":7,"defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION","USE_INSTANCING"]},{"name":"a_matWorld0","format":44,"isInstanced":true,"location":8,"defines":["USE_INSTANCING"]},{"name":"a_matWorld1","format":44,"isInstanced":true,"location":9,"defines":["USE_INSTANCING"]},{"name":"a_matWorld2","format":44,"isInstanced":true,"location":10,"defines":["USE_INSTANCING"]},{"name":"a_lightingMapUVParam","format":44,"isInstanced":true,"location":11,"defines":["USE_INSTANCING","CC_USE_LIGHTMAP"]},{"name":"a_dyn_batch_id","format":11,"location":12,"defines":["!USE_INSTANCING","USE_BATCHING"]},{"name":"a_color","format":44,"location":13,"defines":["CC_USE_ATTR_COLOR"]},{"name":"a_texCoord1","format":21,"location":14,"defines":[]},{"name":"a_lightingMapAdds0","format":44,"isInstanced":true,"location":15,"defines":["CC_USE_LIGHTMAP","!USE_BATCHING","!CC_FORWARD_ADD","USE_INSTANCING"]},{"name":"a_lightingMapAdds1","format":44,"isInstanced":true,"location":16,"defines":["CC_USE_LIGHTMAP","!USE_BATCHING","!CC_FORWARD_ADD","USE_INSTANCING"]},{"name":"a_lightingMapScales0","format":44,"isInstanced":true,"location":17,"defines":["CC_USE_LIGHTMAP","!USE_BATCHING","!CC_FORWARD_ADD","USE_INSTANCING"]},{"name":"a_lightingMapScales1","format":44,"isInstanced":true,"location":18,"defines":["CC_USE_LIGHTMAP","!USE_BATCHING","!CC_FORWARD_ADD","USE_INSTANCING"]}],"varyings":[{"name":"v_shadowPos","type":16,"count":1,"stageFlags":1,"location":0,"defines":[]},{"name":"v_color","type":16,"count":1,"stageFlags":17,"location":1,"defines":["CC_USE_ATTR_COLOR"]},{"name":"v_obj_position","type":15,"count":1,"stageFlags":17,"location":2,"defines":[]},{"name":"v_position","type":15,"count":1,"stageFlags":17,"location":3,"defines":[]},{"name":"v_normal","type":15,"count":1,"stageFlags":17,"location":4,"defines":[]},{"name":"v_uv","type":14,"count":1,"stageFlags":17,"location":5,"defines":[]},{"name":"v_tangent","type":15,"count":1,"stageFlags":17,"location":6,"defines":[]},{"name":"v_bitangent","type":15,"count":1,"stageFlags":17,"location":7,"defines":[]},{"name":"v_uv1","type":14,"count":1,"stageFlags":17,"location":8,"defines":[]},{"name":"v_lightingMapAdds0","type":16,"count":1,"stageFlags":17,"location":9,"defines":["CC_USE_LIGHTMAP","!USE_BATCHING","!CC_FORWARD_ADD","USE_INSTANCING"]},{"name":"v_lightingMapAdds1","type":16,"count":1,"stageFlags":17,"location":10,"defines":["CC_USE_LIGHTMAP","!USE_BATCHING","!CC_FORWARD_ADD","USE_INSTANCING"]},{"name":"v_lightingMapScales0","type":16,"count":1,"stageFlags":17,"location":11,"defines":["CC_USE_LIGHTMAP","!USE_BATCHING","!CC_FORWARD_ADD","USE_INSTANCING"]},{"name":"v_lightingMapScales1","type":16,"count":1,"stageFlags":17,"location":12,"defines":["CC_USE_LIGHTMAP","!USE_BATCHING","!CC_FORWARD_ADD","USE_INSTANCING"]},{"name":"v_luv","type":15,"count":1,"stageFlags":17,"location":13,"defines":["CC_USE_LIGHTMAP","!USE_BATCHING","!CC_FORWARD_ADD"]}],"fragColors":[{"name":"fragColor0","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":0,"tags":[],"defines":[]},{"name":"fragColor1","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":1,"defines":["CC_PIPELINE_TYPE"]},{"name":"fragColor2","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":2,"defines":["CC_PIPELINE_TYPE"]},{"name":"fragColor3","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":3,"defines":["CC_PIPELINE_TYPE"]}],"glsl4":{"vert":"#extension GL_EXT_shader_explicit_arithmetic_types_int32: require\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec3 a_normal;\nlayout(location = 2) in vec2 a_texCoord;\nlayout(location = 3) in vec4 a_tangent;\n#if CC_USE_MORPH\n    int getVertexId() {\n      return gl_VertexIndex;\n    }\n  layout(set = 2, binding = 4) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n  };\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n        ivec2 texSize = textureSize(tex, 0);\n        return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture(tex, x)),\n        decode32(texture(tex, y)),\n        decode32(texture(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    layout(set = 2, binding = 7) uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    layout(set = 2, binding = 8) uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    layout(set = 2, binding = 9) uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout StandardVertInput attr) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    attr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    attr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    attr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n    layout(location = 4) in u32vec4 a_joints;\n  layout(location = 5) in vec4 a_weights;\n  #if CC_USE_BAKED_ANIMATION\n    #if USE_INSTANCING\n      layout(location = 7) in highp vec4 a_jointAnimInfo;\n    #endif\n    layout(set = 2, binding = 3) uniform CCSkinningTexture {\n      highp vec4 cc_jointTextureInfo;\n    };\n    layout(set = 2, binding = 2) uniform CCSkinningAnimation {\n      highp vec4 cc_jointAnimInfo;\n    };\n    layout(set = 2, binding = 6) uniform highp sampler2D cc_jointTexture;\n      #else\n    layout(set = 2, binding = 3) uniform CCSkinning {\n      highp vec4 cc_joints[30 * 3];\n    };\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout StandardVertInput attr) {\n    mat4 m = skinMatrix();\n    attr.position = m * attr.position;\n    attr.normal = (m * vec4(attr.normal, 0.0)).xyz;\n    attr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n  }\n#endif\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\n#if USE_INSTANCING\n  layout(location = 8) in vec4 a_matWorld0;\n  layout(location = 9) in vec4 a_matWorld1;\n  layout(location = 10) in vec4 a_matWorld2;\n  #if CC_USE_LIGHTMAP\n    layout(location = 11) in vec4 a_lightingMapUVParam;\n  #endif\n#elif USE_BATCHING\n  layout(location = 12) in float a_dyn_batch_id;\n  layout(set = 2, binding = 0) uniform CCLocalBatched {\n    highp mat4 cc_matWorlds[10];\n  };\n#else\n  layout(set = 2, binding = 0) uniform CCLocal {\n    highp mat4 cc_matWorld;\n    highp mat4 cc_matWorldIT;\n    highp vec4 cc_lightingMapUVParam;\n  };\n#endif\nlayout(location = 0) out highp vec4 v_shadowPos;\nlayout(set = 0, binding = 2) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  lowp  vec4 cc_shadowNFLSInfo;\n  lowp  vec4 cc_shadowWHPBInfo;\n  lowp  vec4 cc_shadowLPNNInfo;\n  lowp  vec4 cc_shadowColor;\n};\n#if CC_RECEIVE_SHADOW\n  layout(set = 0, binding = 3) uniform highp sampler2D cc_shadowMap;\n  layout(set = 0, binding = 5) uniform highp sampler2D cc_spotLightingMap;\n#endif\n#if CC_USE_ATTR_COLOR\nlayout(location = 13) in vec4 a_color;\nlayout(location = 1) out vec4 v_color;\n#endif\nlayout(location = 2) out vec3 v_obj_position;\nlayout(location = 3) out vec3 v_position;\nlayout(location = 4) out vec3 v_normal;\nlayout(location = 5) out vec2 v_uv;\nlayout(location = 6) out vec3 v_tangent;\nlayout(location = 7) out vec3 v_bitangent;\nlayout(location = 14) in vec2 a_texCoord1;\nlayout(location = 8) out vec2 v_uv1;\n#if (CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD)\n    #if USE_INSTANCING\n      layout(location = 15) in vec4 a_lightingMapAdds0;\n      layout(location = 16) in vec4 a_lightingMapAdds1;\n      layout(location = 17) in vec4 a_lightingMapScales0;\n      layout(location = 18) in vec4 a_lightingMapScales1;\n      layout(location = 9) out vec4 v_lightingMapAdds0;\n      layout(location = 10) out vec4 v_lightingMapAdds1;\n      layout(location = 11) out vec4 v_lightingMapScales0;\n      layout(location = 12) out vec4 v_lightingMapScales1;\n      void getLightingMapVectors () {\n        v_lightingMapAdds0 = a_lightingMapAdds0;\n        v_lightingMapAdds1 = a_lightingMapAdds1;\n        v_lightingMapScales0 = a_lightingMapScales0;\n        v_lightingMapScales1 = a_lightingMapScales1;\n      }\n    #endif\n    layout(location = 13) out vec3 v_luv;\n    void CCLightingMapCaclUV()\n    {\n    #if !USE_INSTANCING\n      v_luv.xy = cc_lightingMapUVParam.xy + a_texCoord1 * cc_lightingMapUVParam.zw;\n      v_luv.z = cc_lightingMapUVParam.z;\n    #else\n      v_luv.xy = a_lightingMapUVParam.xy + a_texCoord1 * a_lightingMapUVParam.zw;\n      v_luv.z = a_lightingMapUVParam.z;\n    #endif\n    }\n#endif\nlayout(set = 0, binding = 7) uniform CCCustomView {\n    mat4 cc_view_taa_prev_viewProj;\n    mat4 cc_view_inverse_transpose_mirror;\n    vec4 cc_view_pr_reflectionPlane;\n    vec4 cc_view_pr_parameters;\n    vec4 cc_view_SkyIrradianceEnvironmentMap[7];\n    vec4 cc_view_SkyColor;\n    vec4 cc_view_SkyLightParameters;\n    vec4 cc_view_IndirectLightingColorScale_Intensity;\n    vec4 cc_view_PreExposure;\n    vec4 cc_view_taa_params1;\n    vec4 cc_view_taa_params2;\n    vec4 cc_view_final_screen_params;\n    vec4 cc_ibl_cluster_BoundsMin;\n    vec4 cc_ibl_cluster_BoundsDelta;\n    vec4 cc_ibl_cluster_CellsDot;\n    vec4 cc_ibl_cluster_CellsMax;\n    vec4 cc_ibl_cluster_TextureSize;\n    vec4 cc_ibl_cluster_InfoTextureInvSize;\n    vec4 cc_ibl_cluster_CellsCountByBoundsSizeAndPixelsPerCell;\n    vec4 cc_light_cluster_BoundsMin;\n    vec4 cc_light_cluster_BoundsDelta;\n    vec4 cc_light_cluster_CellsDot;\n    vec4 cc_light_cluster_CellsMax;\n    vec4 cc_light_cluster_TextureSize;\n    vec4 cc_light_cluster_InfoTextureInvSize;\n    vec4 cc_light_cluster_CellsCountByBoundsSizeAndPixelsPerCell;\n    vec4 FogStruct_ExponentialFogParameters;\n    vec4 FogStruct_ExponentialFogColorParameter;\n    vec4 FogStruct_ExponentialFogParameters2;\n    vec4 FogStruct_ExponentialFogParameters3;\n    vec4 cc_global_parameters;\n};\nstruct GlobalView {\n    vec3 IndirectLightingColorScale;\n    float PreExposure;\n};\nstruct Light {\n  vec3 color;\n  vec3 direction;\n};\nstruct FDirectLighting\n{\n  vec3 Diffuse;\n  vec3 Specular;\n};\nstruct FPixelMaterialInputs\n{\n  vec3 Normal;\n  vec3 EmissiveColor;\n  float Opacity;\n  float OpacityMask;\n  vec3 BaseColor;\n  float Metallic;\n  float Specular;\n  float Roughness;\n  float AmbientOcclusion;\n  float Anisotropy;\n  float Tangent;\n  float Refraction;\n  float PixelDepthOffset;\n  float ShadingModel;\n  float TwoSidedSign;\n  float RoughnessWithClamp;\n  vec3 DiffuseColor;\n  vec3 SpecularColor;\n  vec3 Subsurface;\n};\nstruct FMaterialPixelParameters {\n  float IndirectIrradiance;\n  vec2 TexCoords_0;\n  vec2 TexCoords_1;\n  vec4 VertexColor;\n  vec3 WorldNormal;\n  vec3 WorldTangent;\n  vec3 ReflectionVector;\n  vec3 CameraVector;\n  vec3 LightVector;\n  vec4 SvPosition;\n  vec4 ScreenPosition;\n  mat3 TangentToWorld;\n  vec3 AbsoluteWorldPosition;\n  vec3 ObjectWorldPosition;\n  vec2 LightmapUVs;\n  int PrimitiveId;\n};\nstruct FMaterialVertexParameters {\n  vec3 WorldPosition;\n  vec4 VertexColor;\n};\n  layout(set = 1, binding = 0) uniform SharedUBOs_Properties {\n    vec4 VectorParameter_0;\n    vec4 ScalarParameter_0;\n    vec4 ScalarParameter_1;\n    vec4 ScalarParameter_2;\n  };\n  layout(set = 1, binding = 1) uniform samplerCube Material_TextureCube_0;\n   vec4 F4_0101 = vec4(0, 1, 0, 1);\n  vec3 GetMaterialWorldPositionOffset(FMaterialVertexParameters Parameters) {\n    return vec3(0.000000, 0.000000, 0.000000);\n}\nvoid main () {\n  StandardVertInput In;\n      In.position = vec4(a_position, 1.0);\n      In.normal = a_normal;\n      In.tangent = a_tangent;\n    #if CC_USE_MORPH\n      applyMorph(In);\n    #endif\n    #if CC_USE_SKINNING\n      CCSkin(In);\n    #endif\n  mat4 matWorld, matWorldIT;\n    #if USE_INSTANCING\n      matWorld = mat4(\n        vec4(a_matWorld0.xyz, 0.0),\n        vec4(a_matWorld1.xyz, 0.0),\n        vec4(a_matWorld2.xyz, 0.0),\n        vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n      );\n      matWorldIT = matWorld;\n    #elif USE_BATCHING\n      matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n      matWorldIT = matWorld;\n    #else\n      matWorld = cc_matWorld;\n      matWorldIT = cc_matWorldIT;\n    #endif\n  vec4 pos = matWorld * In.position;\n  FMaterialVertexParameters Parameters;\n  Parameters.WorldPosition = pos.xzy * 100.;\n  #if CC_USE_ATTR_COLOR\n  Parameters.VertexColor = a_color;\n  #else\n  Parameters.VertexColor = vec4(1.);\n  #endif\n  pos.xyz += GetMaterialWorldPositionOffset(Parameters).xzy / 100.;\n  v_obj_position = matWorld[3].xyz;\n  v_position = pos.xyz;\n  v_normal = normalize((matWorldIT * vec4(In.normal, 0.0)).xyz);\n  v_tangent = normalize((matWorld * vec4(In.tangent.xyz, 0.0)).xyz);\n  v_bitangent = normalize(cross(v_normal, v_tangent) * In.tangent.w);\n  v_uv = a_texCoord;\n  #if SAMPLE_FROM_RT\n      v_uv = cc_cameraPos.w > 1.0 ? vec2(v_uv.x, 1.0 - v_uv.y) : v_uv;\n  #endif\n  v_uv1 = a_texCoord1;\n  #if SAMPLE_FROM_RT\n      v_uv1 = cc_cameraPos.w > 1.0 ? vec2(v_uv1.x, 1.0 - v_uv1.y) : v_uv1;\n  #endif\n  #if CC_USE_ATTR_COLOR\n  v_color = a_color;\n  #endif\n  #if (CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD)\n    CCLightingMapCaclUV();\n    #if USE_INSTANCING\n      getLightingMapVectors();\n    #endif\n  #endif\n  v_shadowPos = cc_matLightViewProj * pos;\n  mat4 matProj = cc_matProj;\n  matProj[2][0] += cc_view_taa_params1.x;\n  matProj[2][1] += cc_view_taa_params1.y;\n  gl_Position = matProj * cc_matView * pos;\n}","frag":"\n  precision highp float;\n  layout(set = 0, binding = 0) uniform CCGlobal {\n    highp   vec4 cc_time;\n    mediump vec4 cc_screenSize;\n    mediump vec4 cc_nativeSize;\n  };\n  layout(set = 0, binding = 1) uniform CCCamera {\n    highp   mat4 cc_matView;\n    highp   mat4 cc_matViewInv;\n    highp   mat4 cc_matProj;\n    highp   mat4 cc_matProjInv;\n    highp   mat4 cc_matViewProj;\n    highp   mat4 cc_matViewProjInv;\n    highp   vec4 cc_cameraPos;\n    mediump vec4 cc_screenScale;\n    mediump vec4 cc_exposure;\n    mediump vec4 cc_mainLitDir;\n    mediump vec4 cc_mainLitColor;\n    mediump vec4 cc_ambientSky;\n    mediump vec4 cc_ambientGround;\n    mediump vec4 cc_fogColor;\n    mediump vec4 cc_fogBase;\n    mediump vec4 cc_fogAdd;\n    mediump vec4 cc_nearFar;\n    mediump vec4 cc_viewPort;\n  };\n  layout(set = 2, binding = 0) uniform CCLocal {\n    highp mat4 cc_matWorld;\n    highp mat4 cc_matWorldIT;\n    highp vec4 cc_lightingMapUVParam;\n  };\n  layout(set = 1, binding = 0) uniform SharedUBOs_Properties {\n    vec4 VectorParameter_0;\n    vec4 ScalarParameter_0;\n    vec4 ScalarParameter_1;\n    vec4 ScalarParameter_2;\n  };\n  layout(set = 1, binding = 1) uniform samplerCube Material_TextureCube_0;\nvec3 CCRGBE2Linear (vec4 rgbe) {\n    return rgbe.rgb * pow(1.1, rgbe.a * 255.0 - 128.0);\n}\nvec4 decodeCCRGBE (vec4 color) {\n  color.rgb = CCRGBE2Linear(color);\n  color.a = 1.;\n  return color;\n}\nfloat rsqrt (float x) {\n  return 1. / sqrt(x);\n}\nvoid sincos0(float a, out float s, out float c)\n{\n  s = sin(a);\n  c = cos(a);\n}\nvec4 TextureCubeSampleX2(samplerCube tex, vec3 uv) {\n  vec4 color = texture(tex, uv);\n  if (color.a < 1.) {\n    color = decodeCCRGBE(color);\n    color.rgb = sqrt(color.rgb);\n  }\n  return color;\n}\nvec4 TextureCubeSampleX(samplerCube tex, vec3 uv) {\n  uv = uv.xzy;\n  float x = uv.x;\n  float z = uv.z;\n  float c = 0.;\n  float s = -1.;\n  uv.x = z * s + x * c;\n  uv.z = z * c - x * s;\n  return TextureCubeSampleX2(tex, uv);\n}\nstruct Light {\n  vec3 color;\n  vec3 direction;\n};\nstruct FDirectLighting\n{\n  vec3 Diffuse;\n  vec3 Specular;\n};\nstruct FPixelMaterialInputs\n{\n  vec3 Normal;\n  vec3 EmissiveColor;\n  float Opacity;\n  float OpacityMask;\n  vec3 BaseColor;\n  float Metallic;\n  float Specular;\n  float Roughness;\n  float AmbientOcclusion;\n  float Anisotropy;\n  float Tangent;\n  float Refraction;\n  float PixelDepthOffset;\n  float ShadingModel;\n  float TwoSidedSign;\n  float RoughnessWithClamp;\n  vec3 DiffuseColor;\n  vec3 SpecularColor;\n  vec3 Subsurface;\n};\nstruct FMaterialPixelParameters {\n  float IndirectIrradiance;\n  vec2 TexCoords_0;\n  vec2 TexCoords_1;\n  vec4 VertexColor;\n  vec3 WorldNormal;\n  vec3 WorldTangent;\n  vec3 ReflectionVector;\n  vec3 CameraVector;\n  vec3 LightVector;\n  vec4 SvPosition;\n  vec4 ScreenPosition;\n  mat3 TangentToWorld;\n  vec3 AbsoluteWorldPosition;\n  vec3 ObjectWorldPosition;\n  vec2 LightmapUVs;\n  int PrimitiveId;\n};\nstruct FMaterialVertexParameters {\n  vec3 WorldPosition;\n  vec4 VertexColor;\n};\n  vec3 RotateAboutAxis(vec4 NormalizedRotationAxisAndAngle, vec3 PositionOnAxis, vec3 Position) {\n      vec3 ClosestPointOnAxis = (PositionOnAxis + vec3 ((NormalizedRotationAxisAndAngle * dot(vec3 (NormalizedRotationAxisAndAngle), (Position - PositionOnAxis)))));\n      vec3 UAxis = (Position - ClosestPointOnAxis);\n      vec3 VAxis = cross(vec3 (NormalizedRotationAxisAndAngle), UAxis);\n      float CosAngle;\n      float SinAngle;\n      sincos0((NormalizedRotationAxisAndAngle).w, SinAngle, CosAngle);\n      vec3 R = ((UAxis * CosAngle) + (VAxis * SinAngle));\n      vec3 RotatedPosition = (ClosestPointOnAxis + R);\n      return (RotatedPosition - Position);\n  }\n  vec3 GetMaterialNormalRaw(FPixelMaterialInputs PixelMaterialInputs) {\n      return vec3 ((PixelMaterialInputs).Normal);\n  }\n  vec3 GetWorldPosition(FMaterialPixelParameters Parameters) {\n      return (Parameters).AbsoluteWorldPosition;\n  }\n  vec3 GetWorldPosition(FMaterialVertexParameters Parameters) {\n      return (Parameters).WorldPosition;\n  }\n  vec3 GetMaterialNormal(FMaterialPixelParameters Parameters, FPixelMaterialInputs PixelMaterialInputs) {\n      vec3 RetNormal = GetMaterialNormalRaw(PixelMaterialInputs);\n      return RetNormal;\n  }\n  vec3 TransformTangentNormalToWorld(mat3 TangentToWorld, vec3 normal) {\n      return normalize((TangentToWorld * normalize(normal)));\n  }\n  vec3 ReflectionAboutCustomWorldNormal(inout FMaterialPixelParameters Parameters, vec3 WorldNormal, bool bNormalizeInputNormal) {\n      ((Parameters).WorldNormal = (TransformTangentNormalToWorld((Parameters).TangentToWorld, (Parameters).WorldNormal)).xzy);\n      ((Parameters).ReflectionVector = normalize(reflect((-(Parameters).CameraVector), (Parameters).WorldNormal)));\n      return (Parameters).ReflectionVector;\n  }\n  vec4 SvPositionToResolvedScreenPosition(vec4 SvPosition) {\n      vec2 pixelPos = (SvPosition).xy;\n      vec3 ndc = vec3((((pixelPos * (cc_screenSize).zw) - vec2 (0.500000)) * 2.000000), (gl_FragCoord));\n      vec4 screenPos = (vec4(ndc, 1.000000) / (gl_FragCoord));\n      return screenPos;\n  }\n  vec4 ProcessMaterialColorTextureLookup(vec4 TextureValue) {\n      return vec4(pow((TextureValue).rgb, vec3 (2.200000)), (TextureValue).a);\n  }\n  float PositiveClampedPow(float X, float Y) {\n      return pow(max(X, 0.000001), Y);\n  }\n  vec2 PositiveClampedPow(vec2 X, vec2 Y) {\n      return pow(max(X, vec2 (0.000001)), Y);\n  }\n  vec3 PositiveClampedPow(vec3 X, vec3 Y) {\n      return pow(max(X, vec3 (0.000001)), Y);\n  }\n  vec4 PositiveClampedPow(vec4 X, vec4 Y) {\n      return pow(max(X, vec4 (0.000001)), Y);\n  }\n   vec4 F4_0101 = vec4(0, 1, 0, 1);\nvoid CalcPixelMaterialInputs(inout FMaterialPixelParameters Parameters, inout FPixelMaterialInputs PixelMaterialInputs) {\n  vec4 Material_ScalarExpressions_0;\n  {\n      vec4 v1;\n  vec4 v2;\n  v1 = vec4(ScalarParameter_0.x);\n  v2 = vec4(6.283185, 6.283185, 6.283185, 6.283185);\n  v1 = v1 * v2;\n  Material_ScalarExpressions_0.y = v1.x;\n  }\n  {\n      vec4 v1;\n  v1 = vec4(ScalarParameter_0.y);\n  Material_ScalarExpressions_0.z = v1.x;\n  }\n  {\n      vec4 v1;\n  v1 = vec4(ScalarParameter_0.z);\n  Material_ScalarExpressions_0.w = v1.x;\n  }\n  vec4 Material_VectorExpressions_1;\n  {\n      vec4 v1;\n  v1 = VectorParameter_0;\n  v1 = VectorParameter_0;v1.b = v1[2];\n  v1.g = v1[1];\n  v1.r = v1[0];\n  Material_VectorExpressions_1 = v1;\n  }\n    ((PixelMaterialInputs).Normal = vec3(0.000000, 0.000000, 1.000000));\n    vec3 MaterialNormal = vec3 (GetMaterialNormal(Parameters, PixelMaterialInputs));\n    ((Parameters).WorldNormal = normalize(MaterialNormal));\n    ((Parameters).ReflectionVector = ReflectionAboutCustomWorldNormal(Parameters, (Parameters).WorldNormal, false));\n    vec3 Local0 = RotateAboutAxis(vec4(vec3(0.000000, 0.000000, 1.000000), Material_ScalarExpressions_0.y), vec3(0.000000, 0.000000, 0.000000), GetWorldPosition(Parameters));\n    vec3 Local1 = (Local0 + GetWorldPosition(Parameters));\n    float Local2 = dot(Local1, Local1);\n    float Local3 = sqrt(Local2);\n    vec3 Local4 = (Local1 / Local3);\n    vec4 Local5 = ProcessMaterialColorTextureLookup(TextureCubeSampleX(Material_TextureCube_0, Local4));\n    vec3 Local6 = PositiveClampedPow((Local5).rgb, vec3 (Material_ScalarExpressions_0.z));\n    vec3 Local7 = (Local6 * Material_ScalarExpressions_0.w);\n    vec3 Local8 = (Local7 * (Material_VectorExpressions_1).rgb);\n    ((PixelMaterialInputs).EmissiveColor = Local8);\n    ((PixelMaterialInputs).Opacity = 1.000000);\n    ((PixelMaterialInputs).OpacityMask = 1.000000);\n    ((PixelMaterialInputs).BaseColor = vec3(0.000000, 0.000000, 0.000000));\n    ((PixelMaterialInputs).Metallic = 0.000000);\n    ((PixelMaterialInputs).Specular = 0.500000);\n    ((PixelMaterialInputs).Roughness = 0.500000);\n    ((PixelMaterialInputs).Anisotropy = 0.000000);\n    ((PixelMaterialInputs).Tangent = float (vec3(1.000000, 0.000000, 0.000000)));\n    ((PixelMaterialInputs).Subsurface = vec3 (0));\n    ((PixelMaterialInputs).AmbientOcclusion = 1.000000);\n    ((Parameters).WorldTangent = vec3 (0));\n}\nlayout(set = 0, binding = 7) uniform CCCustomView {\n    mat4 cc_view_taa_prev_viewProj;\n    mat4 cc_view_inverse_transpose_mirror;\n    vec4 cc_view_pr_reflectionPlane;\n    vec4 cc_view_pr_parameters;\n    vec4 cc_view_SkyIrradianceEnvironmentMap[7];\n    vec4 cc_view_SkyColor;\n    vec4 cc_view_SkyLightParameters;\n    vec4 cc_view_IndirectLightingColorScale_Intensity;\n    vec4 cc_view_PreExposure;\n    vec4 cc_view_taa_params1;\n    vec4 cc_view_taa_params2;\n    vec4 cc_view_final_screen_params;\n    vec4 cc_ibl_cluster_BoundsMin;\n    vec4 cc_ibl_cluster_BoundsDelta;\n    vec4 cc_ibl_cluster_CellsDot;\n    vec4 cc_ibl_cluster_CellsMax;\n    vec4 cc_ibl_cluster_TextureSize;\n    vec4 cc_ibl_cluster_InfoTextureInvSize;\n    vec4 cc_ibl_cluster_CellsCountByBoundsSizeAndPixelsPerCell;\n    vec4 cc_light_cluster_BoundsMin;\n    vec4 cc_light_cluster_BoundsDelta;\n    vec4 cc_light_cluster_CellsDot;\n    vec4 cc_light_cluster_CellsMax;\n    vec4 cc_light_cluster_TextureSize;\n    vec4 cc_light_cluster_InfoTextureInvSize;\n    vec4 cc_light_cluster_CellsCountByBoundsSizeAndPixelsPerCell;\n    vec4 FogStruct_ExponentialFogParameters;\n    vec4 FogStruct_ExponentialFogColorParameter;\n    vec4 FogStruct_ExponentialFogParameters2;\n    vec4 FogStruct_ExponentialFogParameters3;\n    vec4 cc_global_parameters;\n};\nstruct GlobalView {\n    vec3 IndirectLightingColorScale;\n    float PreExposure;\n};\nvoid getGlobalView (out GlobalView View) {\n    View.IndirectLightingColorScale = cc_view_IndirectLightingColorScale_Intensity.rgb * cc_view_IndirectLightingColorScale_Intensity.w;\n    View.PreExposure = cc_view_PreExposure.x;\n}\n#if CC_USE_ATTR_COLOR\nlayout(location = 1) in vec4 v_color;\n#endif\nlayout(location = 2) in vec3 v_obj_position;\nlayout(location = 3) in vec3 v_position;\nlayout(location = 4) in vec3 v_normal;\nlayout(location = 5) in vec2 v_uv;\nlayout(location = 8) in vec2 v_uv1;\nlayout(location = 6) in vec3 v_tangent;\nlayout(location = 7) in vec3 v_bitangent;\nvoid getPixelParameters (out FMaterialPixelParameters Parameters) {\n  Parameters.TexCoords_0 = v_uv;\n  Parameters.TexCoords_1 = v_uv1;\n  #if CC_USE_ATTR_COLOR\n    Parameters.VertexColor = v_color;\n  #else\n    Parameters.VertexColor = vec4(1.);\n  #endif\n  Parameters.WorldNormal = v_normal;\n  Parameters.AbsoluteWorldPosition = v_position;\n  Parameters.ObjectWorldPosition = v_obj_position;\n  Parameters.CameraVector = normalize(cc_cameraPos.xyz - v_position);\n  Parameters.SvPosition = gl_FragCoord;\n  Parameters.ScreenPosition = SvPositionToResolvedScreenPosition(gl_FragCoord);\n  Parameters.TangentToWorld = mat3(\n    v_tangent,\n    v_bitangent,\n    v_normal\n  );\n  Parameters.LightmapUVs = v_uv1;\n  Parameters.IndirectIrradiance = 0.;\n}\nvoid surf (out FPixelMaterialInputs PixelMaterialInputs, out FMaterialPixelParameters Parameters, out GlobalView View) {\n  getPixelParameters(Parameters);\n  getGlobalView(View);\n  Parameters.AbsoluteWorldPosition = Parameters.AbsoluteWorldPosition.xzy * 100.;\n  Parameters.ObjectWorldPosition = Parameters.ObjectWorldPosition.xzy * 100.;\n  Parameters.CameraVector = Parameters.CameraVector.xzy;\n  CalcPixelMaterialInputs(Parameters, PixelMaterialInputs);\n  float TwoSidedSign = 1.;\n  if (!gl_FrontFacing) {\n    TwoSidedSign = -1.;\n  }\n  Parameters.AbsoluteWorldPosition = Parameters.AbsoluteWorldPosition.xzy / 100.;\n  Parameters.ObjectWorldPosition = Parameters.ObjectWorldPosition.xzy / 100.;\n  Parameters.CameraVector = Parameters.CameraVector.xzy;\n  Parameters.WorldNormal = Parameters.WorldNormal.xzy * TwoSidedSign;\n  Parameters.ReflectionVector = Parameters.ReflectionVector.xzy;\n  if (PixelMaterialInputs.OpacityMask < 0.33330) {\n    discard;\n  }\n  PixelMaterialInputs.Metallic = clamp(PixelMaterialInputs.Metallic, 0.0, 1.0);\n  PixelMaterialInputs.Specular = clamp(PixelMaterialInputs.Specular, 0.0, 1.0);\n  PixelMaterialInputs.Roughness = clamp(PixelMaterialInputs.Roughness, 0.0, 1.0);\n  PixelMaterialInputs.TwoSidedSign = TwoSidedSign;\n}\nlayout(set = 0, binding = 2) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  lowp  vec4 cc_shadowNFLSInfo;\n  lowp  vec4 cc_shadowWHPBInfo;\n  lowp  vec4 cc_shadowLPNNInfo;\n  lowp  vec4 cc_shadowColor;\n};\n#if CC_RECEIVE_SHADOW\n  layout(set = 0, binding = 3) uniform highp sampler2D cc_shadowMap;\n  layout(set = 0, binding = 5) uniform highp sampler2D cc_spotLightingMap;\n#endif\nfloat D_GGX( float a2, float NoH )\n{\n  float d = ( NoH * a2 - NoH ) * NoH + 1.;\n  return a2 / ( 3.14159265359*d*d );\n}\n#if (CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD)\n    layout(location = 13) in vec3 v_luv;\n    layout(set = 2, binding = 10) uniform sampler2D cc_lightingMap;\n    #if USE_INSTANCING\n      layout(location = 9) in vec4 v_lightingMapAdds0;\n      layout(location = 10) in vec4 v_lightingMapAdds1;\n      layout(location = 11) in vec4 v_lightingMapScales0;\n      layout(location = 12) in vec4 v_lightingMapScales1;\n    #endif\n#endif\nvec3 GetSkySHDiffuseSimple(vec3 Normal)\n{\n  vec4 NormalVector = vec4(Normal.xzy, 1);\n  vec3 Intermediate0;\n  Intermediate0.x = dot(cc_view_SkyIrradianceEnvironmentMap[0], NormalVector);\n  Intermediate0.y = dot(cc_view_SkyIrradianceEnvironmentMap[1], NormalVector);\n  Intermediate0.z = dot(cc_view_SkyIrradianceEnvironmentMap[2], NormalVector);\n  return max(vec3(0.), Intermediate0);\n}\nlayout(set = 0, binding = 9) uniform samplerCube cc_ibl_map_sky;\nvec3 transmission (vec3 N, vec3 V, vec3 L, float Falloff, vec3 SubsurfaceColor) {\n    float Wrap = 0.5;\n    float WrapAddOne = ( 1. + Wrap );\n    float WrapNoL = clamp(( -dot(N, L) + Wrap ) / ( WrapAddOne * WrapAddOne ), 0.0, 1.0);\n    float VoL = dot(V, L);\n    float Scatter = D_GGX( 0.6*0.6, clamp(-VoL, 0.0, 1.0) );\n    return SubsurfaceColor * WrapNoL * Scatter * cc_mainLitColor.rgb * cc_mainLitColor.w;\n}\nvoid lightingPerObject (inout FMaterialPixelParameters Parameters, inout FPixelMaterialInputs PixelMaterialInputs) {\n    PixelMaterialInputs.EmissiveColor += transmission(\n      Parameters.WorldNormal,\n      Parameters.CameraVector,\n      normalize(-cc_mainLitDir.xyz), 1.,\n      PixelMaterialInputs.Subsurface\n    );\n  #if !(CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD)\n    vec3 DiffuseLookup = GetSkySHDiffuseSimple(Parameters.WorldNormal) * cc_view_SkyColor.rgb;\n    vec3 DiffuseColor = PixelMaterialInputs.BaseColor - PixelMaterialInputs.BaseColor * PixelMaterialInputs.Metallic;\n    PixelMaterialInputs.EmissiveColor += DiffuseLookup * PixelMaterialInputs.AmbientOcclusion * DiffuseColor;\n    if (PixelMaterialInputs.TwoSidedSign < 0.) {\n      vec3 BackfaceDiffuseLookup = GetSkySHDiffuseSimple(Parameters.WorldNormal * PixelMaterialInputs.TwoSidedSign);\n      PixelMaterialInputs.EmissiveColor += BackfaceDiffuseLookup * PixelMaterialInputs.Subsurface;\n    }\n  #endif\n}\n#if CC_FORWARD_ADD\n#if CC_PIPELINE_TYPE == 0\n# define LIGHTS_PER_PASS 1\n#else\n# define LIGHTS_PER_PASS 10\n#endif\n#if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\nlayout(set = 2, binding = 1) uniform CCForwardLight {\n  highp vec4 cc_lightPos[LIGHTS_PER_PASS];\n  vec4 cc_lightColor[LIGHTS_PER_PASS];\n  vec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];\n  vec4 cc_lightDir[LIGHTS_PER_PASS];\n};\n#endif\n#endif\nlayout(set = 0, binding = 13) uniform sampler2D cc_light_cluster_InfoTexture;\nlayout(set = 0, binding = 14) uniform sampler2D cc_light_cluster_Texture;\n#if CC_ENABLE_CLUSTERED_LIGHT_CULLING && CC_ENABLE_Builtin_CLUSTERED_LIGHT_CULLING\n  #if CC_USE_IBL\n    layout(set = 0, binding = 4) uniform samplerCube cc_environment;\n    #if CC_USE_DIFFUSEMAP\n      layout(set = 0, binding = 6) uniform samplerCube cc_diffuseMap;\n    #endif\n  #endif\n  #if USE_REFLECTION_DENOISE\n  #endif\n  struct StandardSurface {\n    vec4 albedo;\n    vec3 position;\n    vec3 normal;\n    vec3 emissive;\n    vec3 lightmap;\n    float lightmap_test;\n    float roughness;\n    float metallic;\n    float occlusion;\n  };\n  layout(set = 1, binding = 2) readonly buffer b_ccLightsBuffer { vec4 b_ccLights[]; };\n  layout(set = 1, binding = 3) readonly buffer b_clusterLightIndicesBuffer { uint b_clusterLightIndices[]; };\n  layout(set = 1, binding = 4) readonly buffer b_clusterLightGridBuffer { uvec4 b_clusterLightGrid[]; };\n  struct CCLight\n  {\n    vec4 cc_lightPos;\n    vec4 cc_lightColor;\n    vec4 cc_lightSizeRangeAngle;\n    vec4 cc_lightDir;\n  };\n  struct Cluster\n  {\n    vec3 minBounds;\n    vec3 maxBounds;\n  };\n  struct LightGrid\n  {\n    uint offset;\n    uint ccLights;\n  };\n#endif\nconst float FLT_EPSILON = 0.001;\nconst float FLT_EPSILON2 = 0.01;\nfloat CalculateLineIntegralShared(float FogHeightFalloff, float RayDirectionZ, float RayOriginTerms)\n{\n  float Falloff = max(-127.0, FogHeightFalloff * RayDirectionZ);\n  float LineIntegral = ( 1.0 - exp2(-Falloff) ) / Falloff;\n  float LineIntegralTaylor = log(2.0) - ( 0.5 * (pow(2., log(2.0))) ) * Falloff;\n  return RayOriginTerms * ( abs(Falloff) > FLT_EPSILON2 ? LineIntegral : LineIntegralTaylor );\n}\nvec3 ComputeInscatteringColor(vec3 CameraToReceiver, float CameraToReceiverLength)\n{\n  vec3 Inscattering = FogStruct_ExponentialFogColorParameter.xyz;\n  return Inscattering;\n}\nvec4 GetExponentialHeightFog(vec3 WorldPositionRelativeToCamera, float ExcludeDistance)\n{\n  float MinFogOpacity = FogStruct_ExponentialFogColorParameter.w;\n  float MaxWorldObserverHeight = FogStruct_ExponentialFogParameters.z;\n  vec3 View_WorldCameraOrigin = cc_cameraPos.xyz;\n  vec3 WorldObserverOrigin = vec3(View_WorldCameraOrigin.x, min(View_WorldCameraOrigin.y, MaxWorldObserverHeight), View_WorldCameraOrigin.z);\n  vec3 CameraToReceiver = WorldPositionRelativeToCamera;\n  CameraToReceiver.y += View_WorldCameraOrigin.y - WorldObserverOrigin.y;\n  float CameraToReceiverLengthSqr = dot(CameraToReceiver, CameraToReceiver);\n  float CameraToReceiverLengthInv = rsqrt(CameraToReceiverLengthSqr);\n  float CameraToReceiverLength = CameraToReceiverLengthSqr * CameraToReceiverLengthInv;\n  vec3 CameraToReceiverNormalized = CameraToReceiver * CameraToReceiverLengthInv;\n  float RayOriginTerms = FogStruct_ExponentialFogParameters.x;\n  float RayOriginTermsSecond = FogStruct_ExponentialFogParameters2.x;\n  float RayLength = CameraToReceiverLength;\n  float RayDirectionZ = CameraToReceiver.y;\n  ExcludeDistance = max(ExcludeDistance, FogStruct_ExponentialFogParameters.w);\n  if (ExcludeDistance > 0.)\n  {\n    float ExcludeIntersectionTime = ExcludeDistance * CameraToReceiverLengthInv;\n    float CameraToExclusionIntersectionZ = ExcludeIntersectionTime * CameraToReceiver.y;\n    float ExclusionIntersectionZ = WorldObserverOrigin.y + CameraToExclusionIntersectionZ;\n    float ExclusionIntersectionToReceiverZ = CameraToReceiver.y - CameraToExclusionIntersectionZ;\n    RayLength = (1.0 - ExcludeIntersectionTime) * CameraToReceiverLength;\n    RayDirectionZ = ExclusionIntersectionToReceiverZ;\n    float Exponent = max(-127.0, FogStruct_ExponentialFogParameters.y * (ExclusionIntersectionZ - FogStruct_ExponentialFogParameters3.y));\n    RayOriginTerms = FogStruct_ExponentialFogParameters3.x * exp2(-Exponent);\n    float ExponentSecond = max(-127.0, FogStruct_ExponentialFogParameters2.y * (ExclusionIntersectionZ - FogStruct_ExponentialFogParameters2.w));\n    RayOriginTermsSecond = FogStruct_ExponentialFogParameters2.z * exp2(-ExponentSecond);\n  }\n  float ExponentialHeightLineIntegralShared = CalculateLineIntegralShared(FogStruct_ExponentialFogParameters.y, RayDirectionZ, RayOriginTerms) + CalculateLineIntegralShared(FogStruct_ExponentialFogParameters2.y, RayDirectionZ, RayOriginTermsSecond);\n  float ExponentialHeightLineIntegral = ExponentialHeightLineIntegralShared * RayLength;\n  vec3 InscatteringColor = ComputeInscatteringColor(CameraToReceiver, CameraToReceiverLength);\n  vec3 DirectionalInscattering = vec3(0.);\n  float ExpFogFactor = max(clamp(exp2(-ExponentialHeightLineIntegral), 0.0, 1.0), MinFogOpacity);\n  if (FogStruct_ExponentialFogParameters3.w > 0. && CameraToReceiverLength > FogStruct_ExponentialFogParameters3.w)\n  {\n    ExpFogFactor = 1.;\n    DirectionalInscattering = vec3(0.);\n  }\n    vec3 FogColor = (InscatteringColor) * (1. - ExpFogFactor) + DirectionalInscattering;\n  return vec4(FogColor, ExpFogFactor);\n}\nvec4 CalculateHeightFog(vec3 WorldPositionRelativeToCamera)\n{\n  vec3 WorldPosition = WorldPositionRelativeToCamera;\n  float ExcludeDistance = 0.;\n  vec4 FogInscatteringAndOpacity = GetExponentialHeightFog(WorldPositionRelativeToCamera, ExcludeDistance);\n  return FogInscatteringAndOpacity;\n}\n  #if CC_FORWARD_ADD\n  #endif\n  vec4 forward () {\n    FMaterialPixelParameters Parameters;\n    FPixelMaterialInputs PixelMaterialInputs;\n    GlobalView View;\n    surf(PixelMaterialInputs, Parameters, View);\n    lightingPerObject(Parameters, PixelMaterialInputs);\n    vec4 color = vec4(PixelMaterialInputs.EmissiveColor, PixelMaterialInputs.Opacity);\n    vec4 fogColor = CalculateHeightFog(Parameters.AbsoluteWorldPosition.xyz - cc_cameraPos.xyz);\n    color.rgb = color.rgb * fogColor.a + fogColor.rgb;\n    color.rgb *= View.PreExposure;\n    return color;\n  }\n  void deferred (out vec4 color0, out vec4 color1, out vec4 color2, out vec4 color3) {\n    FMaterialPixelParameters Parameters;\n    FPixelMaterialInputs PixelMaterialInputs;\n    GlobalView View;\n    surf(PixelMaterialInputs, Parameters, View);\n    lightingPerObject(Parameters, PixelMaterialInputs);\n    color0 = vec4(vec3(0.), 1.);\n    color1 = vec4(Parameters.AbsoluteWorldPosition, 1.);\n    color2 = vec4(Parameters.WorldNormal, 0.);\n    color3 = vec4(PixelMaterialInputs.EmissiveColor, 0.);\n  }\n  #if CC_TRANSPARENT || (CC_PIPELINE_TYPE == 0)\n    layout(location = 0) out vec4 fragColor0;\n    void main () {\n      fragColor0 = forward();\n    }\n  #elif CC_PIPELINE_TYPE == 1\n    layout(location = 0) out vec4 fragColor0;\n    layout(location = 1) out vec4 fragColor1;\n    layout(location = 2) out vec4 fragColor2;\n    layout(location = 3) out vec4 fragColor3;\n    void main () {\n      deferred(fragColor0, fragColor1, fragColor2, fragColor3);\n    }\n  #endif"},"glsl3":{"vert":"\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\nin vec4 a_tangent;\n#if CC_USE_MORPH\n    in float a_vertexId;\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n  layout(std140) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n  };\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n        ivec2 texSize = textureSize(tex, 0);\n        return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture(tex, x)),\n        decode32(texture(tex, y)),\n        decode32(texture(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout StandardVertInput attr) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    attr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    attr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    attr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n    in vec4 a_joints;\n  in vec4 a_weights;\n  #if CC_USE_BAKED_ANIMATION\n    #if USE_INSTANCING\n      in highp vec4 a_jointAnimInfo;\n    #endif\n    layout(std140) uniform CCSkinningTexture {\n      highp vec4 cc_jointTextureInfo;\n    };\n    layout(std140) uniform CCSkinningAnimation {\n      highp vec4 cc_jointAnimInfo;\n    };\n    uniform highp sampler2D cc_jointTexture;\n      #else\n    layout(std140) uniform CCSkinning {\n      highp vec4 cc_joints[30 * 3];\n    };\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout StandardVertInput attr) {\n    mat4 m = skinMatrix();\n    attr.position = m * attr.position;\n    attr.normal = (m * vec4(attr.normal, 0.0)).xyz;\n    attr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n  }\n#endif\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\n#if USE_INSTANCING\n  in vec4 a_matWorld0;\n  in vec4 a_matWorld1;\n  in vec4 a_matWorld2;\n  #if CC_USE_LIGHTMAP\n    in vec4 a_lightingMapUVParam;\n  #endif\n#elif USE_BATCHING\n  in float a_dyn_batch_id;\n  layout(std140) uniform CCLocalBatched {\n    highp mat4 cc_matWorlds[10];\n  };\n#else\n  layout(std140) uniform CCLocal {\n    highp mat4 cc_matWorld;\n    highp mat4 cc_matWorldIT;\n    highp vec4 cc_lightingMapUVParam;\n  };\n#endif\nout highp vec4 v_shadowPos;\nlayout(std140) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  lowp  vec4 cc_shadowNFLSInfo;\n  lowp  vec4 cc_shadowWHPBInfo;\n  lowp  vec4 cc_shadowLPNNInfo;\n  lowp  vec4 cc_shadowColor;\n};\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotLightingMap;\n#endif\n#if CC_USE_ATTR_COLOR\nin vec4 a_color;\nout vec4 v_color;\n#endif\nout vec3 v_obj_position;\nout vec3 v_position;\nout vec3 v_normal;\nout vec2 v_uv;\nout vec3 v_tangent;\nout vec3 v_bitangent;\nin vec2 a_texCoord1;\nout vec2 v_uv1;\n#if (CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD)\n    #if USE_INSTANCING\n      in vec4 a_lightingMapAdds0;\n      in vec4 a_lightingMapAdds1;\n      in vec4 a_lightingMapScales0;\n      in vec4 a_lightingMapScales1;\n      out vec4 v_lightingMapAdds0;\n      out vec4 v_lightingMapAdds1;\n      out vec4 v_lightingMapScales0;\n      out vec4 v_lightingMapScales1;\n      void getLightingMapVectors () {\n        v_lightingMapAdds0 = a_lightingMapAdds0;\n        v_lightingMapAdds1 = a_lightingMapAdds1;\n        v_lightingMapScales0 = a_lightingMapScales0;\n        v_lightingMapScales1 = a_lightingMapScales1;\n      }\n    #endif\n    out vec3 v_luv;\n    void CCLightingMapCaclUV()\n    {\n    #if !USE_INSTANCING\n      v_luv.xy = cc_lightingMapUVParam.xy + a_texCoord1 * cc_lightingMapUVParam.zw;\n      v_luv.z = cc_lightingMapUVParam.z;\n    #else\n      v_luv.xy = a_lightingMapUVParam.xy + a_texCoord1 * a_lightingMapUVParam.zw;\n      v_luv.z = a_lightingMapUVParam.z;\n    #endif\n    }\n#endif\nlayout(std140) uniform CCCustomView {\n    mat4 cc_view_taa_prev_viewProj;\n    mat4 cc_view_inverse_transpose_mirror;\n    vec4 cc_view_pr_reflectionPlane;\n    vec4 cc_view_pr_parameters;\n    vec4 cc_view_SkyIrradianceEnvironmentMap[7];\n    vec4 cc_view_SkyColor;\n    vec4 cc_view_SkyLightParameters;\n    vec4 cc_view_IndirectLightingColorScale_Intensity;\n    vec4 cc_view_PreExposure;\n    vec4 cc_view_taa_params1;\n    vec4 cc_view_taa_params2;\n    vec4 cc_view_final_screen_params;\n    vec4 cc_ibl_cluster_BoundsMin;\n    vec4 cc_ibl_cluster_BoundsDelta;\n    vec4 cc_ibl_cluster_CellsDot;\n    vec4 cc_ibl_cluster_CellsMax;\n    vec4 cc_ibl_cluster_TextureSize;\n    vec4 cc_ibl_cluster_InfoTextureInvSize;\n    vec4 cc_ibl_cluster_CellsCountByBoundsSizeAndPixelsPerCell;\n    vec4 cc_light_cluster_BoundsMin;\n    vec4 cc_light_cluster_BoundsDelta;\n    vec4 cc_light_cluster_CellsDot;\n    vec4 cc_light_cluster_CellsMax;\n    vec4 cc_light_cluster_TextureSize;\n    vec4 cc_light_cluster_InfoTextureInvSize;\n    vec4 cc_light_cluster_CellsCountByBoundsSizeAndPixelsPerCell;\n    vec4 FogStruct_ExponentialFogParameters;\n    vec4 FogStruct_ExponentialFogColorParameter;\n    vec4 FogStruct_ExponentialFogParameters2;\n    vec4 FogStruct_ExponentialFogParameters3;\n    vec4 cc_global_parameters;\n};\nstruct GlobalView {\n    vec3 IndirectLightingColorScale;\n    float PreExposure;\n};\nstruct Light {\n  vec3 color;\n  vec3 direction;\n};\nstruct FDirectLighting\n{\n  vec3 Diffuse;\n  vec3 Specular;\n};\nstruct FPixelMaterialInputs\n{\n  vec3 Normal;\n  vec3 EmissiveColor;\n  float Opacity;\n  float OpacityMask;\n  vec3 BaseColor;\n  float Metallic;\n  float Specular;\n  float Roughness;\n  float AmbientOcclusion;\n  float Anisotropy;\n  float Tangent;\n  float Refraction;\n  float PixelDepthOffset;\n  float ShadingModel;\n  float TwoSidedSign;\n  float RoughnessWithClamp;\n  vec3 DiffuseColor;\n  vec3 SpecularColor;\n  vec3 Subsurface;\n};\nstruct FMaterialPixelParameters {\n  float IndirectIrradiance;\n  vec2 TexCoords_0;\n  vec2 TexCoords_1;\n  vec4 VertexColor;\n  vec3 WorldNormal;\n  vec3 WorldTangent;\n  vec3 ReflectionVector;\n  vec3 CameraVector;\n  vec3 LightVector;\n  vec4 SvPosition;\n  vec4 ScreenPosition;\n  mat3 TangentToWorld;\n  vec3 AbsoluteWorldPosition;\n  vec3 ObjectWorldPosition;\n  vec2 LightmapUVs;\n  int PrimitiveId;\n};\nstruct FMaterialVertexParameters {\n  vec3 WorldPosition;\n  vec4 VertexColor;\n};\n  layout(std140) uniform SharedUBOs_Properties {\n    vec4 VectorParameter_0;\n    vec4 ScalarParameter_0;\n    vec4 ScalarParameter_1;\n    vec4 ScalarParameter_2;\n  };\n  uniform samplerCube Material_TextureCube_0;\n   vec4 F4_0101 = vec4(0, 1, 0, 1);\n  vec3 GetMaterialWorldPositionOffset(FMaterialVertexParameters Parameters) {\n    return vec3(0.000000, 0.000000, 0.000000);\n}\nvoid main () {\n  StandardVertInput In;\n      In.position = vec4(a_position, 1.0);\n      In.normal = a_normal;\n      In.tangent = a_tangent;\n    #if CC_USE_MORPH\n      applyMorph(In);\n    #endif\n    #if CC_USE_SKINNING\n      CCSkin(In);\n    #endif\n  mat4 matWorld, matWorldIT;\n    #if USE_INSTANCING\n      matWorld = mat4(\n        vec4(a_matWorld0.xyz, 0.0),\n        vec4(a_matWorld1.xyz, 0.0),\n        vec4(a_matWorld2.xyz, 0.0),\n        vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n      );\n      matWorldIT = matWorld;\n    #elif USE_BATCHING\n      matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n      matWorldIT = matWorld;\n    #else\n      matWorld = cc_matWorld;\n      matWorldIT = cc_matWorldIT;\n    #endif\n  vec4 pos = matWorld * In.position;\n  FMaterialVertexParameters Parameters;\n  Parameters.WorldPosition = pos.xzy * 100.;\n  #if CC_USE_ATTR_COLOR\n  Parameters.VertexColor = a_color;\n  #else\n  Parameters.VertexColor = vec4(1.);\n  #endif\n  pos.xyz += GetMaterialWorldPositionOffset(Parameters).xzy / 100.;\n  v_obj_position = matWorld[3].xyz;\n  v_position = pos.xyz;\n  v_normal = normalize((matWorldIT * vec4(In.normal, 0.0)).xyz);\n  v_tangent = normalize((matWorld * vec4(In.tangent.xyz, 0.0)).xyz);\n  v_bitangent = normalize(cross(v_normal, v_tangent) * In.tangent.w);\n  v_uv = a_texCoord;\n  #if SAMPLE_FROM_RT\n      v_uv = cc_cameraPos.w > 1.0 ? vec2(v_uv.x, 1.0 - v_uv.y) : v_uv;\n  #endif\n  v_uv1 = a_texCoord1;\n  #if SAMPLE_FROM_RT\n      v_uv1 = cc_cameraPos.w > 1.0 ? vec2(v_uv1.x, 1.0 - v_uv1.y) : v_uv1;\n  #endif\n  #if CC_USE_ATTR_COLOR\n  v_color = a_color;\n  #endif\n  #if (CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD)\n    CCLightingMapCaclUV();\n    #if USE_INSTANCING\n      getLightingMapVectors();\n    #endif\n  #endif\n  v_shadowPos = cc_matLightViewProj * pos;\n  mat4 matProj = cc_matProj;\n  matProj[2][0] += cc_view_taa_params1.x;\n  matProj[2][1] += cc_view_taa_params1.y;\n  gl_Position = matProj * cc_matView * pos;\n}","frag":"\n  precision highp float;\n  layout(std140) uniform CCGlobal {\n    highp   vec4 cc_time;\n    mediump vec4 cc_screenSize;\n    mediump vec4 cc_nativeSize;\n  };\n  layout(std140) uniform CCCamera {\n    highp   mat4 cc_matView;\n    highp   mat4 cc_matViewInv;\n    highp   mat4 cc_matProj;\n    highp   mat4 cc_matProjInv;\n    highp   mat4 cc_matViewProj;\n    highp   mat4 cc_matViewProjInv;\n    highp   vec4 cc_cameraPos;\n    mediump vec4 cc_screenScale;\n    mediump vec4 cc_exposure;\n    mediump vec4 cc_mainLitDir;\n    mediump vec4 cc_mainLitColor;\n    mediump vec4 cc_ambientSky;\n    mediump vec4 cc_ambientGround;\n    mediump vec4 cc_fogColor;\n    mediump vec4 cc_fogBase;\n    mediump vec4 cc_fogAdd;\n    mediump vec4 cc_nearFar;\n    mediump vec4 cc_viewPort;\n  };\n  layout(std140) uniform CCLocal {\n    highp mat4 cc_matWorld;\n    highp mat4 cc_matWorldIT;\n    highp vec4 cc_lightingMapUVParam;\n  };\n  layout(std140) uniform SharedUBOs_Properties {\n    vec4 VectorParameter_0;\n    vec4 ScalarParameter_0;\n    vec4 ScalarParameter_1;\n    vec4 ScalarParameter_2;\n  };\n  uniform samplerCube Material_TextureCube_0;\nvec3 CCRGBE2Linear (vec4 rgbe) {\n    return rgbe.rgb * pow(1.1, rgbe.a * 255.0 - 128.0);\n}\nvec4 decodeCCRGBE (vec4 color) {\n  color.rgb = CCRGBE2Linear(color);\n  color.a = 1.;\n  return color;\n}\nfloat rsqrt (float x) {\n  return 1. / sqrt(x);\n}\nvoid sincos0(float a, out float s, out float c)\n{\n  s = sin(a);\n  c = cos(a);\n}\nvec4 TextureCubeSampleX2(samplerCube tex, vec3 uv) {\n  vec4 color = texture(tex, uv);\n  if (color.a < 1.) {\n    color = decodeCCRGBE(color);\n    color.rgb = sqrt(color.rgb);\n  }\n  return color;\n}\nvec4 TextureCubeSampleX(samplerCube tex, vec3 uv) {\n  uv = uv.xzy;\n  float x = uv.x;\n  float z = uv.z;\n  float c = 0.;\n  float s = -1.;\n  uv.x = z * s + x * c;\n  uv.z = z * c - x * s;\n  return TextureCubeSampleX2(tex, uv);\n}\nstruct Light {\n  vec3 color;\n  vec3 direction;\n};\nstruct FDirectLighting\n{\n  vec3 Diffuse;\n  vec3 Specular;\n};\nstruct FPixelMaterialInputs\n{\n  vec3 Normal;\n  vec3 EmissiveColor;\n  float Opacity;\n  float OpacityMask;\n  vec3 BaseColor;\n  float Metallic;\n  float Specular;\n  float Roughness;\n  float AmbientOcclusion;\n  float Anisotropy;\n  float Tangent;\n  float Refraction;\n  float PixelDepthOffset;\n  float ShadingModel;\n  float TwoSidedSign;\n  float RoughnessWithClamp;\n  vec3 DiffuseColor;\n  vec3 SpecularColor;\n  vec3 Subsurface;\n};\nstruct FMaterialPixelParameters {\n  float IndirectIrradiance;\n  vec2 TexCoords_0;\n  vec2 TexCoords_1;\n  vec4 VertexColor;\n  vec3 WorldNormal;\n  vec3 WorldTangent;\n  vec3 ReflectionVector;\n  vec3 CameraVector;\n  vec3 LightVector;\n  vec4 SvPosition;\n  vec4 ScreenPosition;\n  mat3 TangentToWorld;\n  vec3 AbsoluteWorldPosition;\n  vec3 ObjectWorldPosition;\n  vec2 LightmapUVs;\n  int PrimitiveId;\n};\nstruct FMaterialVertexParameters {\n  vec3 WorldPosition;\n  vec4 VertexColor;\n};\n  vec3 RotateAboutAxis(vec4 NormalizedRotationAxisAndAngle, vec3 PositionOnAxis, vec3 Position) {\n      vec3 ClosestPointOnAxis = (PositionOnAxis + vec3 ((NormalizedRotationAxisAndAngle * dot(vec3 (NormalizedRotationAxisAndAngle), (Position - PositionOnAxis)))));\n      vec3 UAxis = (Position - ClosestPointOnAxis);\n      vec3 VAxis = cross(vec3 (NormalizedRotationAxisAndAngle), UAxis);\n      float CosAngle;\n      float SinAngle;\n      sincos0((NormalizedRotationAxisAndAngle).w, SinAngle, CosAngle);\n      vec3 R = ((UAxis * CosAngle) + (VAxis * SinAngle));\n      vec3 RotatedPosition = (ClosestPointOnAxis + R);\n      return (RotatedPosition - Position);\n  }\n  vec3 GetMaterialNormalRaw(FPixelMaterialInputs PixelMaterialInputs) {\n      return vec3 ((PixelMaterialInputs).Normal);\n  }\n  vec3 GetWorldPosition(FMaterialPixelParameters Parameters) {\n      return (Parameters).AbsoluteWorldPosition;\n  }\n  vec3 GetWorldPosition(FMaterialVertexParameters Parameters) {\n      return (Parameters).WorldPosition;\n  }\n  vec3 GetMaterialNormal(FMaterialPixelParameters Parameters, FPixelMaterialInputs PixelMaterialInputs) {\n      vec3 RetNormal = GetMaterialNormalRaw(PixelMaterialInputs);\n      return RetNormal;\n  }\n  vec3 TransformTangentNormalToWorld(mat3 TangentToWorld, vec3 normal) {\n      return normalize((TangentToWorld * normalize(normal)));\n  }\n  vec3 ReflectionAboutCustomWorldNormal(inout FMaterialPixelParameters Parameters, vec3 WorldNormal, bool bNormalizeInputNormal) {\n      ((Parameters).WorldNormal = (TransformTangentNormalToWorld((Parameters).TangentToWorld, (Parameters).WorldNormal)).xzy);\n      ((Parameters).ReflectionVector = normalize(reflect((-(Parameters).CameraVector), (Parameters).WorldNormal)));\n      return (Parameters).ReflectionVector;\n  }\n  vec4 SvPositionToResolvedScreenPosition(vec4 SvPosition) {\n      vec2 pixelPos = (SvPosition).xy;\n      vec3 ndc = vec3((((pixelPos * (cc_screenSize).zw) - vec2 (0.500000)) * 2.000000), (gl_FragCoord));\n      vec4 screenPos = (vec4(ndc, 1.000000) / (gl_FragCoord));\n      return screenPos;\n  }\n  vec4 ProcessMaterialColorTextureLookup(vec4 TextureValue) {\n      return vec4(pow((TextureValue).rgb, vec3 (2.200000)), (TextureValue).a);\n  }\n  float PositiveClampedPow(float X, float Y) {\n      return pow(max(X, 0.000001), Y);\n  }\n  vec2 PositiveClampedPow(vec2 X, vec2 Y) {\n      return pow(max(X, vec2 (0.000001)), Y);\n  }\n  vec3 PositiveClampedPow(vec3 X, vec3 Y) {\n      return pow(max(X, vec3 (0.000001)), Y);\n  }\n  vec4 PositiveClampedPow(vec4 X, vec4 Y) {\n      return pow(max(X, vec4 (0.000001)), Y);\n  }\n   vec4 F4_0101 = vec4(0, 1, 0, 1);\nvoid CalcPixelMaterialInputs(inout FMaterialPixelParameters Parameters, inout FPixelMaterialInputs PixelMaterialInputs) {\n  vec4 Material_ScalarExpressions_0;\n  {\n      vec4 v1;\n  vec4 v2;\n  v1 = vec4(ScalarParameter_0.x);\n  v2 = vec4(6.283185, 6.283185, 6.283185, 6.283185);\n  v1 = v1 * v2;\n  Material_ScalarExpressions_0.y = v1.x;\n  }\n  {\n      vec4 v1;\n  v1 = vec4(ScalarParameter_0.y);\n  Material_ScalarExpressions_0.z = v1.x;\n  }\n  {\n      vec4 v1;\n  v1 = vec4(ScalarParameter_0.z);\n  Material_ScalarExpressions_0.w = v1.x;\n  }\n  vec4 Material_VectorExpressions_1;\n  {\n      vec4 v1;\n  v1 = VectorParameter_0;\n  v1 = VectorParameter_0;v1.b = v1[2];\n  v1.g = v1[1];\n  v1.r = v1[0];\n  Material_VectorExpressions_1 = v1;\n  }\n    ((PixelMaterialInputs).Normal = vec3(0.000000, 0.000000, 1.000000));\n    vec3 MaterialNormal = vec3 (GetMaterialNormal(Parameters, PixelMaterialInputs));\n    ((Parameters).WorldNormal = normalize(MaterialNormal));\n    ((Parameters).ReflectionVector = ReflectionAboutCustomWorldNormal(Parameters, (Parameters).WorldNormal, false));\n    vec3 Local0 = RotateAboutAxis(vec4(vec3(0.000000, 0.000000, 1.000000), Material_ScalarExpressions_0.y), vec3(0.000000, 0.000000, 0.000000), GetWorldPosition(Parameters));\n    vec3 Local1 = (Local0 + GetWorldPosition(Parameters));\n    float Local2 = dot(Local1, Local1);\n    float Local3 = sqrt(Local2);\n    vec3 Local4 = (Local1 / Local3);\n    vec4 Local5 = ProcessMaterialColorTextureLookup(TextureCubeSampleX(Material_TextureCube_0, Local4));\n    vec3 Local6 = PositiveClampedPow((Local5).rgb, vec3 (Material_ScalarExpressions_0.z));\n    vec3 Local7 = (Local6 * Material_ScalarExpressions_0.w);\n    vec3 Local8 = (Local7 * (Material_VectorExpressions_1).rgb);\n    ((PixelMaterialInputs).EmissiveColor = Local8);\n    ((PixelMaterialInputs).Opacity = 1.000000);\n    ((PixelMaterialInputs).OpacityMask = 1.000000);\n    ((PixelMaterialInputs).BaseColor = vec3(0.000000, 0.000000, 0.000000));\n    ((PixelMaterialInputs).Metallic = 0.000000);\n    ((PixelMaterialInputs).Specular = 0.500000);\n    ((PixelMaterialInputs).Roughness = 0.500000);\n    ((PixelMaterialInputs).Anisotropy = 0.000000);\n    ((PixelMaterialInputs).Tangent = float (vec3(1.000000, 0.000000, 0.000000)));\n    ((PixelMaterialInputs).Subsurface = vec3 (0));\n    ((PixelMaterialInputs).AmbientOcclusion = 1.000000);\n    ((Parameters).WorldTangent = vec3 (0));\n}\nlayout(std140) uniform CCCustomView {\n    mat4 cc_view_taa_prev_viewProj;\n    mat4 cc_view_inverse_transpose_mirror;\n    vec4 cc_view_pr_reflectionPlane;\n    vec4 cc_view_pr_parameters;\n    vec4 cc_view_SkyIrradianceEnvironmentMap[7];\n    vec4 cc_view_SkyColor;\n    vec4 cc_view_SkyLightParameters;\n    vec4 cc_view_IndirectLightingColorScale_Intensity;\n    vec4 cc_view_PreExposure;\n    vec4 cc_view_taa_params1;\n    vec4 cc_view_taa_params2;\n    vec4 cc_view_final_screen_params;\n    vec4 cc_ibl_cluster_BoundsMin;\n    vec4 cc_ibl_cluster_BoundsDelta;\n    vec4 cc_ibl_cluster_CellsDot;\n    vec4 cc_ibl_cluster_CellsMax;\n    vec4 cc_ibl_cluster_TextureSize;\n    vec4 cc_ibl_cluster_InfoTextureInvSize;\n    vec4 cc_ibl_cluster_CellsCountByBoundsSizeAndPixelsPerCell;\n    vec4 cc_light_cluster_BoundsMin;\n    vec4 cc_light_cluster_BoundsDelta;\n    vec4 cc_light_cluster_CellsDot;\n    vec4 cc_light_cluster_CellsMax;\n    vec4 cc_light_cluster_TextureSize;\n    vec4 cc_light_cluster_InfoTextureInvSize;\n    vec4 cc_light_cluster_CellsCountByBoundsSizeAndPixelsPerCell;\n    vec4 FogStruct_ExponentialFogParameters;\n    vec4 FogStruct_ExponentialFogColorParameter;\n    vec4 FogStruct_ExponentialFogParameters2;\n    vec4 FogStruct_ExponentialFogParameters3;\n    vec4 cc_global_parameters;\n};\nstruct GlobalView {\n    vec3 IndirectLightingColorScale;\n    float PreExposure;\n};\nvoid getGlobalView (out GlobalView View) {\n    View.IndirectLightingColorScale = cc_view_IndirectLightingColorScale_Intensity.rgb * cc_view_IndirectLightingColorScale_Intensity.w;\n    View.PreExposure = cc_view_PreExposure.x;\n}\n#if CC_USE_ATTR_COLOR\nin vec4 v_color;\n#endif\nin vec3 v_obj_position;\nin vec3 v_position;\nin vec3 v_normal;\nin vec2 v_uv;\nin vec2 v_uv1;\nin vec3 v_tangent;\nin vec3 v_bitangent;\nvoid getPixelParameters (out FMaterialPixelParameters Parameters) {\n  Parameters.TexCoords_0 = v_uv;\n  Parameters.TexCoords_1 = v_uv1;\n  #if CC_USE_ATTR_COLOR\n    Parameters.VertexColor = v_color;\n  #else\n    Parameters.VertexColor = vec4(1.);\n  #endif\n  Parameters.WorldNormal = v_normal;\n  Parameters.AbsoluteWorldPosition = v_position;\n  Parameters.ObjectWorldPosition = v_obj_position;\n  Parameters.CameraVector = normalize(cc_cameraPos.xyz - v_position);\n  Parameters.SvPosition = gl_FragCoord;\n  Parameters.ScreenPosition = SvPositionToResolvedScreenPosition(gl_FragCoord);\n  Parameters.TangentToWorld = mat3(\n    v_tangent,\n    v_bitangent,\n    v_normal\n  );\n  Parameters.LightmapUVs = v_uv1;\n  Parameters.IndirectIrradiance = 0.;\n}\nvoid surf (out FPixelMaterialInputs PixelMaterialInputs, out FMaterialPixelParameters Parameters, out GlobalView View) {\n  getPixelParameters(Parameters);\n  getGlobalView(View);\n  Parameters.AbsoluteWorldPosition = Parameters.AbsoluteWorldPosition.xzy * 100.;\n  Parameters.ObjectWorldPosition = Parameters.ObjectWorldPosition.xzy * 100.;\n  Parameters.CameraVector = Parameters.CameraVector.xzy;\n  CalcPixelMaterialInputs(Parameters, PixelMaterialInputs);\n  float TwoSidedSign = 1.;\n  if (!gl_FrontFacing) {\n    TwoSidedSign = -1.;\n  }\n  Parameters.AbsoluteWorldPosition = Parameters.AbsoluteWorldPosition.xzy / 100.;\n  Parameters.ObjectWorldPosition = Parameters.ObjectWorldPosition.xzy / 100.;\n  Parameters.CameraVector = Parameters.CameraVector.xzy;\n  Parameters.WorldNormal = Parameters.WorldNormal.xzy * TwoSidedSign;\n  Parameters.ReflectionVector = Parameters.ReflectionVector.xzy;\n  if (PixelMaterialInputs.OpacityMask < 0.33330) {\n    discard;\n  }\n  PixelMaterialInputs.Metallic = clamp(PixelMaterialInputs.Metallic, 0.0, 1.0);\n  PixelMaterialInputs.Specular = clamp(PixelMaterialInputs.Specular, 0.0, 1.0);\n  PixelMaterialInputs.Roughness = clamp(PixelMaterialInputs.Roughness, 0.0, 1.0);\n  PixelMaterialInputs.TwoSidedSign = TwoSidedSign;\n}\nlayout(std140) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  lowp  vec4 cc_shadowNFLSInfo;\n  lowp  vec4 cc_shadowWHPBInfo;\n  lowp  vec4 cc_shadowLPNNInfo;\n  lowp  vec4 cc_shadowColor;\n};\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotLightingMap;\n#endif\nfloat D_GGX( float a2, float NoH )\n{\n  float d = ( NoH * a2 - NoH ) * NoH + 1.;\n  return a2 / ( 3.14159265359*d*d );\n}\n#if (CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD)\n    in vec3 v_luv;\n    uniform sampler2D cc_lightingMap;\n    #if USE_INSTANCING\n      in vec4 v_lightingMapAdds0;\n      in vec4 v_lightingMapAdds1;\n      in vec4 v_lightingMapScales0;\n      in vec4 v_lightingMapScales1;\n    #endif\n#endif\nvec3 GetSkySHDiffuseSimple(vec3 Normal)\n{\n  vec4 NormalVector = vec4(Normal.xzy, 1);\n  vec3 Intermediate0;\n  Intermediate0.x = dot(cc_view_SkyIrradianceEnvironmentMap[0], NormalVector);\n  Intermediate0.y = dot(cc_view_SkyIrradianceEnvironmentMap[1], NormalVector);\n  Intermediate0.z = dot(cc_view_SkyIrradianceEnvironmentMap[2], NormalVector);\n  return max(vec3(0.), Intermediate0);\n}\nuniform samplerCube cc_ibl_map_sky;\nvec3 transmission (vec3 N, vec3 V, vec3 L, float Falloff, vec3 SubsurfaceColor) {\n    float Wrap = 0.5;\n    float WrapAddOne = ( 1. + Wrap );\n    float WrapNoL = clamp(( -dot(N, L) + Wrap ) / ( WrapAddOne * WrapAddOne ), 0.0, 1.0);\n    float VoL = dot(V, L);\n    float Scatter = D_GGX( 0.6*0.6, clamp(-VoL, 0.0, 1.0) );\n    return SubsurfaceColor * WrapNoL * Scatter * cc_mainLitColor.rgb * cc_mainLitColor.w;\n}\nvoid lightingPerObject (inout FMaterialPixelParameters Parameters, inout FPixelMaterialInputs PixelMaterialInputs) {\n    PixelMaterialInputs.EmissiveColor += transmission(\n      Parameters.WorldNormal,\n      Parameters.CameraVector,\n      normalize(-cc_mainLitDir.xyz), 1.,\n      PixelMaterialInputs.Subsurface\n    );\n  #if !(CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD)\n    vec3 DiffuseLookup = GetSkySHDiffuseSimple(Parameters.WorldNormal) * cc_view_SkyColor.rgb;\n    vec3 DiffuseColor = PixelMaterialInputs.BaseColor - PixelMaterialInputs.BaseColor * PixelMaterialInputs.Metallic;\n    PixelMaterialInputs.EmissiveColor += DiffuseLookup * PixelMaterialInputs.AmbientOcclusion * DiffuseColor;\n    if (PixelMaterialInputs.TwoSidedSign < 0.) {\n      vec3 BackfaceDiffuseLookup = GetSkySHDiffuseSimple(Parameters.WorldNormal * PixelMaterialInputs.TwoSidedSign);\n      PixelMaterialInputs.EmissiveColor += BackfaceDiffuseLookup * PixelMaterialInputs.Subsurface;\n    }\n  #endif\n}\n#if CC_FORWARD_ADD\n#if CC_PIPELINE_TYPE == 0\n# define LIGHTS_PER_PASS 1\n#else\n# define LIGHTS_PER_PASS 10\n#endif\n#if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\nlayout(std140) uniform CCForwardLight {\n  highp vec4 cc_lightPos[LIGHTS_PER_PASS];\n  vec4 cc_lightColor[LIGHTS_PER_PASS];\n  vec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];\n  vec4 cc_lightDir[LIGHTS_PER_PASS];\n};\n#endif\n#endif\nuniform sampler2D cc_light_cluster_InfoTexture;\nuniform sampler2D cc_light_cluster_Texture;\n#if CC_ENABLE_CLUSTERED_LIGHT_CULLING && CC_ENABLE_Builtin_CLUSTERED_LIGHT_CULLING\n  #if CC_USE_IBL\n    uniform samplerCube cc_environment;\n    #if CC_USE_DIFFUSEMAP\n      uniform samplerCube cc_diffuseMap;\n    #endif\n  #endif\n  #if USE_REFLECTION_DENOISE\n  #endif\n  struct StandardSurface {\n    vec4 albedo;\n    vec3 position;\n    vec3 normal;\n    vec3 emissive;\n    vec3 lightmap;\n    float lightmap_test;\n    float roughness;\n    float metallic;\n    float occlusion;\n  };\n  layout(std430, binding = 4) readonly buffer b_ccLightsBuffer { vec4 b_ccLights[]; };\n  layout(std430, binding = 5) readonly buffer b_clusterLightIndicesBuffer { uint b_clusterLightIndices[]; };\n  layout(std430, binding = 6) readonly buffer b_clusterLightGridBuffer { uvec4 b_clusterLightGrid[]; };\n  struct CCLight\n  {\n    vec4 cc_lightPos;\n    vec4 cc_lightColor;\n    vec4 cc_lightSizeRangeAngle;\n    vec4 cc_lightDir;\n  };\n  struct Cluster\n  {\n    vec3 minBounds;\n    vec3 maxBounds;\n  };\n  struct LightGrid\n  {\n    uint offset;\n    uint ccLights;\n  };\n#endif\nconst float FLT_EPSILON = 0.001;\nconst float FLT_EPSILON2 = 0.01;\nfloat CalculateLineIntegralShared(float FogHeightFalloff, float RayDirectionZ, float RayOriginTerms)\n{\n  float Falloff = max(-127.0, FogHeightFalloff * RayDirectionZ);\n  float LineIntegral = ( 1.0 - exp2(-Falloff) ) / Falloff;\n  float LineIntegralTaylor = log(2.0) - ( 0.5 * (pow(2., log(2.0))) ) * Falloff;\n  return RayOriginTerms * ( abs(Falloff) > FLT_EPSILON2 ? LineIntegral : LineIntegralTaylor );\n}\nvec3 ComputeInscatteringColor(vec3 CameraToReceiver, float CameraToReceiverLength)\n{\n  vec3 Inscattering = FogStruct_ExponentialFogColorParameter.xyz;\n  return Inscattering;\n}\nvec4 GetExponentialHeightFog(vec3 WorldPositionRelativeToCamera, float ExcludeDistance)\n{\n  float MinFogOpacity = FogStruct_ExponentialFogColorParameter.w;\n  float MaxWorldObserverHeight = FogStruct_ExponentialFogParameters.z;\n  vec3 View_WorldCameraOrigin = cc_cameraPos.xyz;\n  vec3 WorldObserverOrigin = vec3(View_WorldCameraOrigin.x, min(View_WorldCameraOrigin.y, MaxWorldObserverHeight), View_WorldCameraOrigin.z);\n  vec3 CameraToReceiver = WorldPositionRelativeToCamera;\n  CameraToReceiver.y += View_WorldCameraOrigin.y - WorldObserverOrigin.y;\n  float CameraToReceiverLengthSqr = dot(CameraToReceiver, CameraToReceiver);\n  float CameraToReceiverLengthInv = rsqrt(CameraToReceiverLengthSqr);\n  float CameraToReceiverLength = CameraToReceiverLengthSqr * CameraToReceiverLengthInv;\n  vec3 CameraToReceiverNormalized = CameraToReceiver * CameraToReceiverLengthInv;\n  float RayOriginTerms = FogStruct_ExponentialFogParameters.x;\n  float RayOriginTermsSecond = FogStruct_ExponentialFogParameters2.x;\n  float RayLength = CameraToReceiverLength;\n  float RayDirectionZ = CameraToReceiver.y;\n  ExcludeDistance = max(ExcludeDistance, FogStruct_ExponentialFogParameters.w);\n  if (ExcludeDistance > 0.)\n  {\n    float ExcludeIntersectionTime = ExcludeDistance * CameraToReceiverLengthInv;\n    float CameraToExclusionIntersectionZ = ExcludeIntersectionTime * CameraToReceiver.y;\n    float ExclusionIntersectionZ = WorldObserverOrigin.y + CameraToExclusionIntersectionZ;\n    float ExclusionIntersectionToReceiverZ = CameraToReceiver.y - CameraToExclusionIntersectionZ;\n    RayLength = (1.0 - ExcludeIntersectionTime) * CameraToReceiverLength;\n    RayDirectionZ = ExclusionIntersectionToReceiverZ;\n    float Exponent = max(-127.0, FogStruct_ExponentialFogParameters.y * (ExclusionIntersectionZ - FogStruct_ExponentialFogParameters3.y));\n    RayOriginTerms = FogStruct_ExponentialFogParameters3.x * exp2(-Exponent);\n    float ExponentSecond = max(-127.0, FogStruct_ExponentialFogParameters2.y * (ExclusionIntersectionZ - FogStruct_ExponentialFogParameters2.w));\n    RayOriginTermsSecond = FogStruct_ExponentialFogParameters2.z * exp2(-ExponentSecond);\n  }\n  float ExponentialHeightLineIntegralShared = CalculateLineIntegralShared(FogStruct_ExponentialFogParameters.y, RayDirectionZ, RayOriginTerms) + CalculateLineIntegralShared(FogStruct_ExponentialFogParameters2.y, RayDirectionZ, RayOriginTermsSecond);\n  float ExponentialHeightLineIntegral = ExponentialHeightLineIntegralShared * RayLength;\n  vec3 InscatteringColor = ComputeInscatteringColor(CameraToReceiver, CameraToReceiverLength);\n  vec3 DirectionalInscattering = vec3(0.);\n  float ExpFogFactor = max(clamp(exp2(-ExponentialHeightLineIntegral), 0.0, 1.0), MinFogOpacity);\n  if (FogStruct_ExponentialFogParameters3.w > 0. && CameraToReceiverLength > FogStruct_ExponentialFogParameters3.w)\n  {\n    ExpFogFactor = 1.;\n    DirectionalInscattering = vec3(0.);\n  }\n    vec3 FogColor = (InscatteringColor) * (1. - ExpFogFactor) + DirectionalInscattering;\n  return vec4(FogColor, ExpFogFactor);\n}\nvec4 CalculateHeightFog(vec3 WorldPositionRelativeToCamera)\n{\n  vec3 WorldPosition = WorldPositionRelativeToCamera;\n  float ExcludeDistance = 0.;\n  vec4 FogInscatteringAndOpacity = GetExponentialHeightFog(WorldPositionRelativeToCamera, ExcludeDistance);\n  return FogInscatteringAndOpacity;\n}\n  #if CC_FORWARD_ADD\n  #endif\n  vec4 forward () {\n    FMaterialPixelParameters Parameters;\n    FPixelMaterialInputs PixelMaterialInputs;\n    GlobalView View;\n    surf(PixelMaterialInputs, Parameters, View);\n    lightingPerObject(Parameters, PixelMaterialInputs);\n    vec4 color = vec4(PixelMaterialInputs.EmissiveColor, PixelMaterialInputs.Opacity);\n    vec4 fogColor = CalculateHeightFog(Parameters.AbsoluteWorldPosition.xyz - cc_cameraPos.xyz);\n    color.rgb = color.rgb * fogColor.a + fogColor.rgb;\n    color.rgb *= View.PreExposure;\n    return color;\n  }\n  void deferred (out vec4 color0, out vec4 color1, out vec4 color2, out vec4 color3) {\n    FMaterialPixelParameters Parameters;\n    FPixelMaterialInputs PixelMaterialInputs;\n    GlobalView View;\n    surf(PixelMaterialInputs, Parameters, View);\n    lightingPerObject(Parameters, PixelMaterialInputs);\n    color0 = vec4(vec3(0.), 1.);\n    color1 = vec4(Parameters.AbsoluteWorldPosition, 1.);\n    color2 = vec4(Parameters.WorldNormal, 0.);\n    color3 = vec4(PixelMaterialInputs.EmissiveColor, 0.);\n  }\n  #if CC_TRANSPARENT || (CC_PIPELINE_TYPE == 0)\n    layout(location = 0) out vec4 fragColor0;\n    void main () {\n      fragColor0 = forward();\n    }\n  #elif CC_PIPELINE_TYPE == 1\n    layout(location = 0) out vec4 fragColor0;\n    layout(location = 1) out vec4 fragColor1;\n    layout(location = 2) out vec4 fragColor2;\n    layout(location = 3) out vec4 fragColor3;\n    void main () {\n      deferred(fragColor0, fragColor1, fragColor2, fragColor3);\n    }\n  #endif"},"glsl1":{"vert":"\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\nattribute vec4 a_tangent;\n#if CC_USE_MORPH\n    attribute float a_vertexId;\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n  uniform vec4 cc_displacementWeights[15];\n  uniform vec4 cc_displacementTextureInfo;\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n        int pixelIndex = elementIndex;\n        vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n        vec2 uv = getPixelCoordFromLocation(location, cc_displacementTextureInfo.xy);\n        return texture2D(tex, uv);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture2D(tex, x)),\n        decode32(texture2D(tex, y)),\n        decode32(texture2D(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout StandardVertInput attr) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    attr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    attr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    attr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n    attribute vec4 a_joints;\n  attribute vec4 a_weights;\n  #if CC_USE_BAKED_ANIMATION\n    #if USE_INSTANCING\n      attribute highp vec4 a_jointAnimInfo;\n    #endif\n    uniform highp vec4 cc_jointTextureInfo;\n    uniform highp vec4 cc_jointAnimInfo;\n    uniform highp sampler2D cc_jointTexture;\n      #else\n    uniform highp vec4 cc_joints[90];\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout StandardVertInput attr) {\n    mat4 m = skinMatrix();\n    attr.position = m * attr.position;\n    attr.normal = (m * vec4(attr.normal, 0.0)).xyz;\n    attr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n  }\n#endif\nuniform highp mat4 cc_matView;\n  uniform highp mat4 cc_matProj;\n  uniform highp vec4 cc_cameraPos;\n#if USE_INSTANCING\n  attribute vec4 a_matWorld0;\n  attribute vec4 a_matWorld1;\n  attribute vec4 a_matWorld2;\n  #if CC_USE_LIGHTMAP\n    attribute vec4 a_lightingMapUVParam;\n  #endif\n#elif USE_BATCHING\n  attribute float a_dyn_batch_id;\n  uniform highp mat4 cc_matWorlds[10];\n#else\n  uniform highp mat4 cc_matWorld;\n  uniform highp mat4 cc_matWorldIT;\n  uniform highp vec4 cc_lightingMapUVParam;\n#endif\nvarying highp vec4 v_shadowPos;\nuniform highp mat4 cc_matLightViewProj;\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotLightingMap;\n#endif\n#if CC_USE_ATTR_COLOR\nattribute vec4 a_color;\nvarying vec4 v_color;\n#endif\nvarying vec3 v_obj_position;\nvarying vec3 v_position;\nvarying vec3 v_normal;\nvarying vec2 v_uv;\nvarying vec3 v_tangent;\nvarying vec3 v_bitangent;\nattribute vec2 a_texCoord1;\nvarying vec2 v_uv1;\n#if (CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD)\n    #if USE_INSTANCING\n      attribute vec4 a_lightingMapAdds0;\n      attribute vec4 a_lightingMapAdds1;\n      attribute vec4 a_lightingMapScales0;\n      attribute vec4 a_lightingMapScales1;\n      varying vec4 v_lightingMapAdds0;\n      varying vec4 v_lightingMapAdds1;\n      varying vec4 v_lightingMapScales0;\n      varying vec4 v_lightingMapScales1;\n      void getLightingMapVectors () {\n        v_lightingMapAdds0 = a_lightingMapAdds0;\n        v_lightingMapAdds1 = a_lightingMapAdds1;\n        v_lightingMapScales0 = a_lightingMapScales0;\n        v_lightingMapScales1 = a_lightingMapScales1;\n      }\n    #endif\n    varying vec3 v_luv;\n    void CCLightingMapCaclUV()\n    {\n    #if !USE_INSTANCING\n      v_luv.xy = cc_lightingMapUVParam.xy + a_texCoord1 * cc_lightingMapUVParam.zw;\n      v_luv.z = cc_lightingMapUVParam.z;\n    #else\n      v_luv.xy = a_lightingMapUVParam.xy + a_texCoord1 * a_lightingMapUVParam.zw;\n      v_luv.z = a_lightingMapUVParam.z;\n    #endif\n    }\n#endif\nuniform vec4 cc_view_taa_params1;\nstruct GlobalView {\n    vec3 IndirectLightingColorScale;\n    float PreExposure;\n};\n  #ifdef GL_OES_standard_derivatives\n  #else\n  #endif\nstruct Light {\n  vec3 color;\n  vec3 direction;\n};\nstruct FDirectLighting\n{\n  vec3 Diffuse;\n  vec3 Specular;\n};\nstruct FPixelMaterialInputs\n{\n  vec3 Normal;\n  vec3 EmissiveColor;\n  float Opacity;\n  float OpacityMask;\n  vec3 BaseColor;\n  float Metallic;\n  float Specular;\n  float Roughness;\n  float AmbientOcclusion;\n  float Anisotropy;\n  float Tangent;\n  float Refraction;\n  float PixelDepthOffset;\n  float ShadingModel;\n  float TwoSidedSign;\n  float RoughnessWithClamp;\n  vec3 DiffuseColor;\n  vec3 SpecularColor;\n  vec3 Subsurface;\n};\nstruct FMaterialPixelParameters {\n  float IndirectIrradiance;\n  vec2 TexCoords_0;\n  vec2 TexCoords_1;\n  vec4 VertexColor;\n  vec3 WorldNormal;\n  vec3 WorldTangent;\n  vec3 ReflectionVector;\n  vec3 CameraVector;\n  vec3 LightVector;\n  vec4 SvPosition;\n  vec4 ScreenPosition;\n  mat3 TangentToWorld;\n  vec3 AbsoluteWorldPosition;\n  vec3 ObjectWorldPosition;\n  vec2 LightmapUVs;\n  int PrimitiveId;\n};\nstruct FMaterialVertexParameters {\n  vec3 WorldPosition;\n  vec4 VertexColor;\n};\n  uniform samplerCube Material_TextureCube_0;\n   vec4 F4_0101 = vec4(0, 1, 0, 1);\n  vec3 GetMaterialWorldPositionOffset(FMaterialVertexParameters Parameters) {\n    return vec3(0.000000, 0.000000, 0.000000);\n}\nvoid main () {\n  StandardVertInput In;\n      In.position = vec4(a_position, 1.0);\n      In.normal = a_normal;\n      In.tangent = a_tangent;\n    #if CC_USE_MORPH\n      applyMorph(In);\n    #endif\n    #if CC_USE_SKINNING\n      CCSkin(In);\n    #endif\n  mat4 matWorld, matWorldIT;\n    #if USE_INSTANCING\n      matWorld = mat4(\n        vec4(a_matWorld0.xyz, 0.0),\n        vec4(a_matWorld1.xyz, 0.0),\n        vec4(a_matWorld2.xyz, 0.0),\n        vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n      );\n      matWorldIT = matWorld;\n    #elif USE_BATCHING\n      matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n      matWorldIT = matWorld;\n    #else\n      matWorld = cc_matWorld;\n      matWorldIT = cc_matWorldIT;\n    #endif\n  vec4 pos = matWorld * In.position;\n  FMaterialVertexParameters Parameters;\n  Parameters.WorldPosition = pos.xzy * 100.;\n  #if CC_USE_ATTR_COLOR\n  Parameters.VertexColor = a_color;\n  #else\n  Parameters.VertexColor = vec4(1.);\n  #endif\n  pos.xyz += GetMaterialWorldPositionOffset(Parameters).xzy / 100.;\n  v_obj_position = matWorld[3].xyz;\n  v_position = pos.xyz;\n  v_normal = normalize((matWorldIT * vec4(In.normal, 0.0)).xyz);\n  v_tangent = normalize((matWorld * vec4(In.tangent.xyz, 0.0)).xyz);\n  v_bitangent = normalize(cross(v_normal, v_tangent) * In.tangent.w);\n  v_uv = a_texCoord;\n  #if SAMPLE_FROM_RT\n      v_uv = cc_cameraPos.w > 1.0 ? vec2(v_uv.x, 1.0 - v_uv.y) : v_uv;\n  #endif\n  v_uv1 = a_texCoord1;\n  #if SAMPLE_FROM_RT\n      v_uv1 = cc_cameraPos.w > 1.0 ? vec2(v_uv1.x, 1.0 - v_uv1.y) : v_uv1;\n  #endif\n  #if CC_USE_ATTR_COLOR\n  v_color = a_color;\n  #endif\n  #if (CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD)\n    CCLightingMapCaclUV();\n    #if USE_INSTANCING\n      getLightingMapVectors();\n    #endif\n  #endif\n  v_shadowPos = cc_matLightViewProj * pos;\n  mat4 matProj = cc_matProj;\n  matProj[2][0] += cc_view_taa_params1.x;\n  matProj[2][1] += cc_view_taa_params1.y;\n  gl_Position = matProj * cc_matView * pos;\n}","frag":"\n#ifdef GL_EXT_draw_buffers\n#extension GL_EXT_draw_buffers: enable\n#endif\n#ifdef GL_EXT_shader_texture_lod\n#extension GL_EXT_shader_texture_lod: enable\n#endif\n#ifdef GL_OES_standard_derivatives\n#extension GL_OES_standard_derivatives: enable\n#endif\n  precision highp float;\n  uniform mediump vec4 cc_screenSize;\n  uniform highp vec4 cc_cameraPos;\n  uniform mediump vec4 cc_mainLitDir;\n  uniform mediump vec4 cc_mainLitColor;\n  uniform vec4 VectorParameter_0;\n                 uniform vec4 ScalarParameter_0;\n  uniform samplerCube Material_TextureCube_0;\nvec3 CCRGBE2Linear (vec4 rgbe) {\n    return rgbe.rgb * pow(1.1, rgbe.a * 255.0 - 128.0);\n}\nvec4 decodeCCRGBE (vec4 color) {\n  color.rgb = CCRGBE2Linear(color);\n  color.a = 1.;\n  return color;\n}\nfloat rsqrt (float x) {\n  return 1. / sqrt(x);\n}\n  #ifdef GL_OES_standard_derivatives\n  #else\n  #endif\nvoid sincos0(float a, out float s, out float c)\n{\n  s = sin(a);\n  c = cos(a);\n}\nvec4 TextureCubeSampleX2(samplerCube tex, vec3 uv) {\n  vec4 color = textureCube(tex, uv);\n  if (color.a < 1.) {\n    color = decodeCCRGBE(color);\n    color.rgb = sqrt(color.rgb);\n  }\n  return color;\n}\nvec4 TextureCubeSampleX(samplerCube tex, vec3 uv) {\n  uv = uv.xzy;\n  float x = uv.x;\n  float z = uv.z;\n  float c = 0.;\n  float s = -1.;\n  uv.x = z * s + x * c;\n  uv.z = z * c - x * s;\n  return TextureCubeSampleX2(tex, uv);\n}\nstruct Light {\n  vec3 color;\n  vec3 direction;\n};\nstruct FDirectLighting\n{\n  vec3 Diffuse;\n  vec3 Specular;\n};\nstruct FPixelMaterialInputs\n{\n  vec3 Normal;\n  vec3 EmissiveColor;\n  float Opacity;\n  float OpacityMask;\n  vec3 BaseColor;\n  float Metallic;\n  float Specular;\n  float Roughness;\n  float AmbientOcclusion;\n  float Anisotropy;\n  float Tangent;\n  float Refraction;\n  float PixelDepthOffset;\n  float ShadingModel;\n  float TwoSidedSign;\n  float RoughnessWithClamp;\n  vec3 DiffuseColor;\n  vec3 SpecularColor;\n  vec3 Subsurface;\n};\nstruct FMaterialPixelParameters {\n  float IndirectIrradiance;\n  vec2 TexCoords_0;\n  vec2 TexCoords_1;\n  vec4 VertexColor;\n  vec3 WorldNormal;\n  vec3 WorldTangent;\n  vec3 ReflectionVector;\n  vec3 CameraVector;\n  vec3 LightVector;\n  vec4 SvPosition;\n  vec4 ScreenPosition;\n  mat3 TangentToWorld;\n  vec3 AbsoluteWorldPosition;\n  vec3 ObjectWorldPosition;\n  vec2 LightmapUVs;\n  int PrimitiveId;\n};\nstruct FMaterialVertexParameters {\n  vec3 WorldPosition;\n  vec4 VertexColor;\n};\n  vec3 RotateAboutAxis(vec4 NormalizedRotationAxisAndAngle, vec3 PositionOnAxis, vec3 Position) {\n      vec3 ClosestPointOnAxis = (PositionOnAxis + vec3 ((NormalizedRotationAxisAndAngle * dot(vec3 (NormalizedRotationAxisAndAngle), (Position - PositionOnAxis)))));\n      vec3 UAxis = (Position - ClosestPointOnAxis);\n      vec3 VAxis = cross(vec3 (NormalizedRotationAxisAndAngle), UAxis);\n      float CosAngle;\n      float SinAngle;\n      sincos0((NormalizedRotationAxisAndAngle).w, SinAngle, CosAngle);\n      vec3 R = ((UAxis * CosAngle) + (VAxis * SinAngle));\n      vec3 RotatedPosition = (ClosestPointOnAxis + R);\n      return (RotatedPosition - Position);\n  }\n  vec3 GetMaterialNormalRaw(FPixelMaterialInputs PixelMaterialInputs) {\n      return vec3 ((PixelMaterialInputs).Normal);\n  }\n  vec3 GetWorldPosition(FMaterialPixelParameters Parameters) {\n      return (Parameters).AbsoluteWorldPosition;\n  }\n  vec3 GetWorldPosition(FMaterialVertexParameters Parameters) {\n      return (Parameters).WorldPosition;\n  }\n  vec3 GetMaterialNormal(FMaterialPixelParameters Parameters, FPixelMaterialInputs PixelMaterialInputs) {\n      vec3 RetNormal = GetMaterialNormalRaw(PixelMaterialInputs);\n      return RetNormal;\n  }\n  vec3 TransformTangentNormalToWorld(mat3 TangentToWorld, vec3 normal) {\n      return normalize((TangentToWorld * normalize(normal)));\n  }\n  vec3 ReflectionAboutCustomWorldNormal(inout FMaterialPixelParameters Parameters, vec3 WorldNormal, bool bNormalizeInputNormal) {\n      ((Parameters).WorldNormal = (TransformTangentNormalToWorld((Parameters).TangentToWorld, (Parameters).WorldNormal)).xzy);\n      ((Parameters).ReflectionVector = normalize(reflect((-(Parameters).CameraVector), (Parameters).WorldNormal)));\n      return (Parameters).ReflectionVector;\n  }\n  vec4 SvPositionToResolvedScreenPosition(vec4 SvPosition) {\n      vec2 pixelPos = (SvPosition).xy;\n      vec3 ndc = vec3((((pixelPos * (cc_screenSize).zw) - vec2 (0.500000)) * 2.000000), (gl_FragCoord));\n      vec4 screenPos = (vec4(ndc, 1.000000) / (gl_FragCoord));\n      return screenPos;\n  }\n  vec4 ProcessMaterialColorTextureLookup(vec4 TextureValue) {\n      return vec4(pow((TextureValue).rgb, vec3 (2.200000)), (TextureValue).a);\n  }\n  float PositiveClampedPow(float X, float Y) {\n      return pow(max(X, 0.000001), Y);\n  }\n  vec2 PositiveClampedPow(vec2 X, vec2 Y) {\n      return pow(max(X, vec2 (0.000001)), Y);\n  }\n  vec3 PositiveClampedPow(vec3 X, vec3 Y) {\n      return pow(max(X, vec3 (0.000001)), Y);\n  }\n  vec4 PositiveClampedPow(vec4 X, vec4 Y) {\n      return pow(max(X, vec4 (0.000001)), Y);\n  }\n   vec4 F4_0101 = vec4(0, 1, 0, 1);\nvoid CalcPixelMaterialInputs(inout FMaterialPixelParameters Parameters, inout FPixelMaterialInputs PixelMaterialInputs) {\n  vec4 Material_ScalarExpressions_0;\n  {\n      vec4 v1;\n  vec4 v2;\n  v1 = vec4(ScalarParameter_0.x);\n  v2 = vec4(6.283185, 6.283185, 6.283185, 6.283185);\n  v1 = v1 * v2;\n  Material_ScalarExpressions_0.y = v1.x;\n  }\n  {\n      vec4 v1;\n  v1 = vec4(ScalarParameter_0.y);\n  Material_ScalarExpressions_0.z = v1.x;\n  }\n  {\n      vec4 v1;\n  v1 = vec4(ScalarParameter_0.z);\n  Material_ScalarExpressions_0.w = v1.x;\n  }\n  vec4 Material_VectorExpressions_1;\n  {\n      vec4 v1;\n  v1 = VectorParameter_0;\n  v1 = VectorParameter_0;v1.b = v1[2];\n  v1.g = v1[1];\n  v1.r = v1[0];\n  Material_VectorExpressions_1 = v1;\n  }\n    ((PixelMaterialInputs).Normal = vec3(0.000000, 0.000000, 1.000000));\n    vec3 MaterialNormal = vec3 (GetMaterialNormal(Parameters, PixelMaterialInputs));\n    ((Parameters).WorldNormal = normalize(MaterialNormal));\n    ((Parameters).ReflectionVector = ReflectionAboutCustomWorldNormal(Parameters, (Parameters).WorldNormal, false));\n    vec3 Local0 = RotateAboutAxis(vec4(vec3(0.000000, 0.000000, 1.000000), Material_ScalarExpressions_0.y), vec3(0.000000, 0.000000, 0.000000), GetWorldPosition(Parameters));\n    vec3 Local1 = (Local0 + GetWorldPosition(Parameters));\n    float Local2 = dot(Local1, Local1);\n    float Local3 = sqrt(Local2);\n    vec3 Local4 = (Local1 / Local3);\n    vec4 Local5 = ProcessMaterialColorTextureLookup(TextureCubeSampleX(Material_TextureCube_0, Local4));\n    vec3 Local6 = PositiveClampedPow((Local5).rgb, vec3 (Material_ScalarExpressions_0.z));\n    vec3 Local7 = (Local6 * Material_ScalarExpressions_0.w);\n    vec3 Local8 = (Local7 * (Material_VectorExpressions_1).rgb);\n    ((PixelMaterialInputs).EmissiveColor = Local8);\n    ((PixelMaterialInputs).Opacity = 1.000000);\n    ((PixelMaterialInputs).OpacityMask = 1.000000);\n    ((PixelMaterialInputs).BaseColor = vec3(0.000000, 0.000000, 0.000000));\n    ((PixelMaterialInputs).Metallic = 0.000000);\n    ((PixelMaterialInputs).Specular = 0.500000);\n    ((PixelMaterialInputs).Roughness = 0.500000);\n    ((PixelMaterialInputs).Anisotropy = 0.000000);\n    ((PixelMaterialInputs).Tangent = float (vec3(1.000000, 0.000000, 0.000000)));\n    ((PixelMaterialInputs).Subsurface = vec3 (0));\n    ((PixelMaterialInputs).AmbientOcclusion = 1.000000);\n    ((Parameters).WorldTangent = vec3 (0));\n}\nuniform vec4 cc_view_SkyIrradianceEnvironmentMap[7];\n  uniform vec4 cc_view_SkyColor;\n  uniform vec4 cc_view_IndirectLightingColorScale_Intensity;\n  uniform vec4 cc_view_PreExposure;\n  uniform vec4 FogStruct_ExponentialFogParameters;\n  uniform vec4 FogStruct_ExponentialFogColorParameter;\n  uniform vec4 FogStruct_ExponentialFogParameters2;\n  uniform vec4 FogStruct_ExponentialFogParameters3;\nstruct GlobalView {\n    vec3 IndirectLightingColorScale;\n    float PreExposure;\n};\nvoid getGlobalView (out GlobalView View) {\n    View.IndirectLightingColorScale = cc_view_IndirectLightingColorScale_Intensity.rgb * cc_view_IndirectLightingColorScale_Intensity.w;\n    View.PreExposure = cc_view_PreExposure.x;\n}\n#if CC_USE_ATTR_COLOR\nvarying vec4 v_color;\n#endif\nvarying vec3 v_obj_position;\nvarying vec3 v_position;\nvarying vec3 v_normal;\nvarying vec2 v_uv;\nvarying vec2 v_uv1;\nvarying vec3 v_tangent;\nvarying vec3 v_bitangent;\nvoid getPixelParameters (out FMaterialPixelParameters Parameters) {\n  Parameters.TexCoords_0 = v_uv;\n  Parameters.TexCoords_1 = v_uv1;\n  #if CC_USE_ATTR_COLOR\n    Parameters.VertexColor = v_color;\n  #else\n    Parameters.VertexColor = vec4(1.);\n  #endif\n  Parameters.WorldNormal = v_normal;\n  Parameters.AbsoluteWorldPosition = v_position;\n  Parameters.ObjectWorldPosition = v_obj_position;\n  Parameters.CameraVector = normalize(cc_cameraPos.xyz - v_position);\n  Parameters.SvPosition = gl_FragCoord;\n  Parameters.ScreenPosition = SvPositionToResolvedScreenPosition(gl_FragCoord);\n  Parameters.TangentToWorld = mat3(\n    v_tangent,\n    v_bitangent,\n    v_normal\n  );\n  Parameters.LightmapUVs = v_uv1;\n  Parameters.IndirectIrradiance = 0.;\n}\nvoid surf (out FPixelMaterialInputs PixelMaterialInputs, out FMaterialPixelParameters Parameters, out GlobalView View) {\n  getPixelParameters(Parameters);\n  getGlobalView(View);\n  Parameters.AbsoluteWorldPosition = Parameters.AbsoluteWorldPosition.xzy * 100.;\n  Parameters.ObjectWorldPosition = Parameters.ObjectWorldPosition.xzy * 100.;\n  Parameters.CameraVector = Parameters.CameraVector.xzy;\n  CalcPixelMaterialInputs(Parameters, PixelMaterialInputs);\n  float TwoSidedSign = 1.;\n  if (!gl_FrontFacing) {\n    TwoSidedSign = -1.;\n  }\n  Parameters.AbsoluteWorldPosition = Parameters.AbsoluteWorldPosition.xzy / 100.;\n  Parameters.ObjectWorldPosition = Parameters.ObjectWorldPosition.xzy / 100.;\n  Parameters.CameraVector = Parameters.CameraVector.xzy;\n  Parameters.WorldNormal = Parameters.WorldNormal.xzy * TwoSidedSign;\n  Parameters.ReflectionVector = Parameters.ReflectionVector.xzy;\n  if (PixelMaterialInputs.OpacityMask < 0.33330) {\n    discard;\n  }\n  PixelMaterialInputs.Metallic = clamp(PixelMaterialInputs.Metallic, 0.0, 1.0);\n  PixelMaterialInputs.Specular = clamp(PixelMaterialInputs.Specular, 0.0, 1.0);\n  PixelMaterialInputs.Roughness = clamp(PixelMaterialInputs.Roughness, 0.0, 1.0);\n  PixelMaterialInputs.TwoSidedSign = TwoSidedSign;\n}\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotLightingMap;\n#endif\nfloat D_GGX( float a2, float NoH )\n{\n  float d = ( NoH * a2 - NoH ) * NoH + 1.;\n  return a2 / ( 3.14159265359*d*d );\n}\n#if (CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD)\n    varying vec3 v_luv;\n    uniform sampler2D cc_lightingMap;\n    #if USE_INSTANCING\n      varying vec4 v_lightingMapAdds0;\n      varying vec4 v_lightingMapAdds1;\n      varying vec4 v_lightingMapScales0;\n      varying vec4 v_lightingMapScales1;\n    #endif\n#endif\nvec3 GetSkySHDiffuseSimple(vec3 Normal)\n{\n  vec4 NormalVector = vec4(Normal.xzy, 1);\n  vec3 Intermediate0;\n  Intermediate0.x = dot(cc_view_SkyIrradianceEnvironmentMap[0], NormalVector);\n  Intermediate0.y = dot(cc_view_SkyIrradianceEnvironmentMap[1], NormalVector);\n  Intermediate0.z = dot(cc_view_SkyIrradianceEnvironmentMap[2], NormalVector);\n  return max(vec3(0.), Intermediate0);\n}\nuniform samplerCube cc_ibl_map_sky;\nvec3 transmission (vec3 N, vec3 V, vec3 L, float Falloff, vec3 SubsurfaceColor) {\n    float Wrap = 0.5;\n    float WrapAddOne = ( 1. + Wrap );\n    float WrapNoL = clamp(( -dot(N, L) + Wrap ) / ( WrapAddOne * WrapAddOne ), 0.0, 1.0);\n    float VoL = dot(V, L);\n    float Scatter = D_GGX( 0.6*0.6, clamp(-VoL, 0.0, 1.0) );\n    return SubsurfaceColor * WrapNoL * Scatter * cc_mainLitColor.rgb * cc_mainLitColor.w;\n}\nvoid lightingPerObject (inout FMaterialPixelParameters Parameters, inout FPixelMaterialInputs PixelMaterialInputs) {\n    PixelMaterialInputs.EmissiveColor += transmission(\n      Parameters.WorldNormal,\n      Parameters.CameraVector,\n      normalize(-cc_mainLitDir.xyz), 1.,\n      PixelMaterialInputs.Subsurface\n    );\n  #if !(CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD)\n    vec3 DiffuseLookup = GetSkySHDiffuseSimple(Parameters.WorldNormal) * cc_view_SkyColor.rgb;\n    vec3 DiffuseColor = PixelMaterialInputs.BaseColor - PixelMaterialInputs.BaseColor * PixelMaterialInputs.Metallic;\n    PixelMaterialInputs.EmissiveColor += DiffuseLookup * PixelMaterialInputs.AmbientOcclusion * DiffuseColor;\n    if (PixelMaterialInputs.TwoSidedSign < 0.) {\n      vec3 BackfaceDiffuseLookup = GetSkySHDiffuseSimple(Parameters.WorldNormal * PixelMaterialInputs.TwoSidedSign);\n      PixelMaterialInputs.EmissiveColor += BackfaceDiffuseLookup * PixelMaterialInputs.Subsurface;\n    }\n  #endif\n}\n#if CC_FORWARD_ADD\n#if CC_PIPELINE_TYPE == 0\n# define LIGHTS_PER_PASS 1\n#else\n# define LIGHTS_PER_PASS 10\n#endif\n#if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\nuniform highp vec4 cc_lightPos[LIGHTS_PER_PASS];\n  uniform vec4 cc_lightColor[LIGHTS_PER_PASS];\n  uniform vec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];\n  uniform vec4 cc_lightDir[LIGHTS_PER_PASS];\n#endif\n#endif\nuniform sampler2D cc_light_cluster_InfoTexture;\nuniform sampler2D cc_light_cluster_Texture;\n#if CC_ENABLE_CLUSTERED_LIGHT_CULLING && CC_ENABLE_Builtin_CLUSTERED_LIGHT_CULLING\n  #if CC_USE_IBL\n    uniform samplerCube cc_environment;\n    #if CC_USE_DIFFUSEMAP\n      uniform samplerCube cc_diffuseMap;\n    #endif\n  #endif\n  #if USE_REFLECTION_DENOISE\n  #endif\n  struct StandardSurface {\n    vec4 albedo;\n    vec3 position;\n    vec3 normal;\n    vec3 emissive;\n    vec3 lightmap;\n    float lightmap_test;\n    float roughness;\n    float metallic;\n    float occlusion;\n  };\n  readonly buffer b_ccLightsBuffer { vec4 b_ccLights[]; };\n  readonly buffer b_clusterLightIndicesBuffer { uint b_clusterLightIndices[]; };\n  readonly buffer b_clusterLightGridBuffer { uvec4 b_clusterLightGrid[]; };\n  struct CCLight\n  {\n    vec4 cc_lightPos;\n    vec4 cc_lightColor;\n    vec4 cc_lightSizeRangeAngle;\n    vec4 cc_lightDir;\n  };\n  struct Cluster\n  {\n    vec3 minBounds;\n    vec3 maxBounds;\n  };\n  struct LightGrid\n  {\n    uint offset;\n    uint ccLights;\n  };\n#endif\nconst float FLT_EPSILON = 0.001;\nconst float FLT_EPSILON2 = 0.01;\nfloat CalculateLineIntegralShared(float FogHeightFalloff, float RayDirectionZ, float RayOriginTerms)\n{\n  float Falloff = max(-127.0, FogHeightFalloff * RayDirectionZ);\n  float LineIntegral = ( 1.0 - exp2(-Falloff) ) / Falloff;\n  float LineIntegralTaylor = log(2.0) - ( 0.5 * (pow(2., log(2.0))) ) * Falloff;\n  return RayOriginTerms * ( abs(Falloff) > FLT_EPSILON2 ? LineIntegral : LineIntegralTaylor );\n}\nvec3 ComputeInscatteringColor(vec3 CameraToReceiver, float CameraToReceiverLength)\n{\n  vec3 Inscattering = FogStruct_ExponentialFogColorParameter.xyz;\n  return Inscattering;\n}\nvec4 GetExponentialHeightFog(vec3 WorldPositionRelativeToCamera, float ExcludeDistance)\n{\n  float MinFogOpacity = FogStruct_ExponentialFogColorParameter.w;\n  float MaxWorldObserverHeight = FogStruct_ExponentialFogParameters.z;\n  vec3 View_WorldCameraOrigin = cc_cameraPos.xyz;\n  vec3 WorldObserverOrigin = vec3(View_WorldCameraOrigin.x, min(View_WorldCameraOrigin.y, MaxWorldObserverHeight), View_WorldCameraOrigin.z);\n  vec3 CameraToReceiver = WorldPositionRelativeToCamera;\n  CameraToReceiver.y += View_WorldCameraOrigin.y - WorldObserverOrigin.y;\n  float CameraToReceiverLengthSqr = dot(CameraToReceiver, CameraToReceiver);\n  float CameraToReceiverLengthInv = rsqrt(CameraToReceiverLengthSqr);\n  float CameraToReceiverLength = CameraToReceiverLengthSqr * CameraToReceiverLengthInv;\n  vec3 CameraToReceiverNormalized = CameraToReceiver * CameraToReceiverLengthInv;\n  float RayOriginTerms = FogStruct_ExponentialFogParameters.x;\n  float RayOriginTermsSecond = FogStruct_ExponentialFogParameters2.x;\n  float RayLength = CameraToReceiverLength;\n  float RayDirectionZ = CameraToReceiver.y;\n  ExcludeDistance = max(ExcludeDistance, FogStruct_ExponentialFogParameters.w);\n  if (ExcludeDistance > 0.)\n  {\n    float ExcludeIntersectionTime = ExcludeDistance * CameraToReceiverLengthInv;\n    float CameraToExclusionIntersectionZ = ExcludeIntersectionTime * CameraToReceiver.y;\n    float ExclusionIntersectionZ = WorldObserverOrigin.y + CameraToExclusionIntersectionZ;\n    float ExclusionIntersectionToReceiverZ = CameraToReceiver.y - CameraToExclusionIntersectionZ;\n    RayLength = (1.0 - ExcludeIntersectionTime) * CameraToReceiverLength;\n    RayDirectionZ = ExclusionIntersectionToReceiverZ;\n    float Exponent = max(-127.0, FogStruct_ExponentialFogParameters.y * (ExclusionIntersectionZ - FogStruct_ExponentialFogParameters3.y));\n    RayOriginTerms = FogStruct_ExponentialFogParameters3.x * exp2(-Exponent);\n    float ExponentSecond = max(-127.0, FogStruct_ExponentialFogParameters2.y * (ExclusionIntersectionZ - FogStruct_ExponentialFogParameters2.w));\n    RayOriginTermsSecond = FogStruct_ExponentialFogParameters2.z * exp2(-ExponentSecond);\n  }\n  float ExponentialHeightLineIntegralShared = CalculateLineIntegralShared(FogStruct_ExponentialFogParameters.y, RayDirectionZ, RayOriginTerms) + CalculateLineIntegralShared(FogStruct_ExponentialFogParameters2.y, RayDirectionZ, RayOriginTermsSecond);\n  float ExponentialHeightLineIntegral = ExponentialHeightLineIntegralShared * RayLength;\n  vec3 InscatteringColor = ComputeInscatteringColor(CameraToReceiver, CameraToReceiverLength);\n  vec3 DirectionalInscattering = vec3(0.);\n  float ExpFogFactor = max(clamp(exp2(-ExponentialHeightLineIntegral), 0.0, 1.0), MinFogOpacity);\n  if (FogStruct_ExponentialFogParameters3.w > 0. && CameraToReceiverLength > FogStruct_ExponentialFogParameters3.w)\n  {\n    ExpFogFactor = 1.;\n    DirectionalInscattering = vec3(0.);\n  }\n    vec3 FogColor = (InscatteringColor) * (1. - ExpFogFactor) + DirectionalInscattering;\n  return vec4(FogColor, ExpFogFactor);\n}\nvec4 CalculateHeightFog(vec3 WorldPositionRelativeToCamera)\n{\n  vec3 WorldPosition = WorldPositionRelativeToCamera;\n  float ExcludeDistance = 0.;\n  vec4 FogInscatteringAndOpacity = GetExponentialHeightFog(WorldPositionRelativeToCamera, ExcludeDistance);\n  return FogInscatteringAndOpacity;\n}\n  #if CC_FORWARD_ADD\n  #endif\n  vec4 forward () {\n    FMaterialPixelParameters Parameters;\n    FPixelMaterialInputs PixelMaterialInputs;\n    GlobalView View;\n    surf(PixelMaterialInputs, Parameters, View);\n    lightingPerObject(Parameters, PixelMaterialInputs);\n    vec4 color = vec4(PixelMaterialInputs.EmissiveColor, PixelMaterialInputs.Opacity);\n    vec4 fogColor = CalculateHeightFog(Parameters.AbsoluteWorldPosition.xyz - cc_cameraPos.xyz);\n    color.rgb = color.rgb * fogColor.a + fogColor.rgb;\n    color.rgb *= View.PreExposure;\n    return color;\n  }\n  void deferred (out vec4 color0, out vec4 color1, out vec4 color2, out vec4 color3) {\n    FMaterialPixelParameters Parameters;\n    FPixelMaterialInputs PixelMaterialInputs;\n    GlobalView View;\n    surf(PixelMaterialInputs, Parameters, View);\n    lightingPerObject(Parameters, PixelMaterialInputs);\n    color0 = vec4(vec3(0.), 1.);\n    color1 = vec4(Parameters.AbsoluteWorldPosition, 1.);\n    color2 = vec4(Parameters.WorldNormal, 0.);\n    color3 = vec4(PixelMaterialInputs.EmissiveColor, 0.);\n  }\n  #if CC_TRANSPARENT || (CC_PIPELINE_TYPE == 0)\n    void main () {\n      gl_FragData[0] = forward();\n    }\n  #elif CC_PIPELINE_TYPE == 1\n    void main () {\n      deferred(gl_FragData[0], gl_FragData[1], gl_FragData[2], gl_FragData[3]);\n    }\n  #endif"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]},{"name":"CCCamera","defines":[]},{"name":"CCShadow","defines":[]},{"name":"CCCustomView","defines":[]}],"samplerTextures":[{"name":"cc_shadowMap","defines":["CC_RECEIVE_SHADOW"]},{"name":"cc_spotLightingMap","defines":["CC_RECEIVE_SHADOW"]},{"name":"cc_ibl_map_sky","defines":[]},{"name":"cc_light_cluster_InfoTexture","defines":[]},{"name":"cc_light_cluster_Texture","defines":[]},{"name":"cc_environment","defines":["CC_ENABLE_CLUSTERED_LIGHT_CULLING","CC_ENABLE_Builtin_CLUSTERED_LIGHT_CULLING","CC_USE_IBL"]},{"name":"cc_diffuseMap","defines":["CC_ENABLE_CLUSTERED_LIGHT_CULLING","CC_ENABLE_Builtin_CLUSTERED_LIGHT_CULLING","CC_USE_IBL","CC_USE_DIFFUSEMAP"]}],"buffers":[],"images":[]},"locals":{"blocks":[{"name":"CCMorph","defines":["CC_USE_MORPH"]},{"name":"CCSkinningTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinningAnimation","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinning","defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION"]},{"name":"CCLocalBatched","defines":["!USE_INSTANCING","USE_BATCHING"]},{"name":"CCLocal","defines":["!USE_INSTANCING","!USE_BATCHING"]},{"name":"CCForwardLight","defines":["CC_FORWARD_ADD","CC_ENABLE_CLUSTERED_LIGHT_CULLING"]}],"samplerTextures":[{"name":"cc_PositionDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_POSITION"]},{"name":"cc_NormalDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_NORMAL"]},{"name":"cc_TangentDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_TANGENT"]},{"name":"cc_jointTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"cc_lightingMap","defines":["CC_USE_LIGHTMAP","!USE_BATCHING","!CC_FORWARD_ADD"]}],"buffers":[],"images":[]},"statistics":{"CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS":262,"CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS":114}},"defines":[{"name":"CC_USE_MORPH","type":"boolean","defines":[]},{"name":"CC_MORPH_TARGET_COUNT","type":"number","defines":["CC_USE_MORPH"],"range":[2,8]},{"name":"CC_MORPH_PRECOMPUTED","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_POSITION","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_NORMAL","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_TANGENT","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_USE_SKINNING","type":"boolean","defines":[]},{"name":"CC_USE_BAKED_ANIMATION","type":"boolean","defines":["CC_USE_SKINNING"]},{"name":"USE_INSTANCING","type":"boolean","defines":[],"editor":{"elevated":true}},{"name":"USE_BATCHING","type":"boolean","defines":["!USE_INSTANCING"],"editor":{"elevated":true}},{"name":"CC_USE_LIGHTMAP","type":"boolean","defines":[]},{"name":"CC_RECEIVE_SHADOW","type":"boolean","defines":[]},{"name":"CC_USE_ATTR_COLOR","type":"boolean","defines":[]},{"name":"CC_FORWARD_ADD","type":"boolean","defines":[]},{"name":"SAMPLE_FROM_RT","type":"boolean","defines":[]},{"name":"CC_PIPELINE_TYPE","type":"number","defines":[],"range":[0,1]},{"name":"CC_FORCE_FORWARD_SHADING","type":"boolean","defines":["CC_FORWARD_ADD"]},{"name":"CC_ENABLE_Builtin_CLUSTERED_LIGHT_CULLING","type":"boolean","defines":["CC_ENABLE_CLUSTERED_LIGHT_CULLING"]},{"name":"CC_USE_IBL","type":"number","defines":["CC_ENABLE_CLUSTERED_LIGHT_CULLING","CC_ENABLE_Builtin_CLUSTERED_LIGHT_CULLING"],"range":[0,2]},{"name":"CC_USE_DIFFUSEMAP","type":"number","defines":["CC_ENABLE_CLUSTERED_LIGHT_CULLING","CC_ENABLE_Builtin_CLUSTERED_LIGHT_CULLING","CC_USE_IBL"],"range":[0,2]},{"name":"USE_REFLECTION_DENOISE","type":"boolean","defines":["CC_ENABLE_CLUSTERED_LIGHT_CULLING","CC_ENABLE_Builtin_CLUSTERED_LIGHT_CULLING"]},{"name":"CC_TRANSPARENT","type":"boolean","defines":[]}]}],[{"name":"opaque","passes":[{"program":"../resources/Exported/LakeWoodenHouse/Maps/Demonstrationlight.Demonstrationlight_PersistentLevel.BP_LightStage.MaterialInstanceDynamic_2|unlit-vs|unlit-fs","embeddedMacros":{"CC_TRANSPARENT":false},"properties":{"HDRI_Tint":{"type":16,"value":[1,0.7944809794425964,0.45833298563957214,1],"handleInfo":["VectorParameter_0",0,16]},"CubemapRotation":{"type":13,"value":[0.1849760115146637],"handleInfo":["ScalarParameter_0",0,13]},"HDRI_Contrast":{"type":13,"value":[1.2000000476837158],"handleInfo":["ScalarParameter_0",1,13]},"HDRI_Brightness":{"type":13,"value":[1.600000023841858],"handleInfo":["ScalarParameter_0",2,13]},"Material_TextureCube_0":{"value":"white","type":31},"VectorParameter_0":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,0.7944809794425964,0.45833298563957214,1]},"ScalarParameter_0":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[0.1849760115146637,1.2000000476837158,1.600000023841858,0]}}},{"phase":"deferred","propertyIndex":0,"program":"../resources/Exported/LakeWoodenHouse/Maps/Demonstrationlight.Demonstrationlight_PersistentLevel.BP_LightStage.MaterialInstanceDynamic_2|unlit-vs|unlit-fs","embeddedMacros":{"CC_TRANSPARENT":false},"properties":{"HDRI_Tint":{"type":16,"value":[1,0.7944809794425964,0.45833298563957214,1],"handleInfo":["VectorParameter_0",0,16]},"CubemapRotation":{"type":13,"value":[0.1849760115146637],"handleInfo":["ScalarParameter_0",0,13]},"HDRI_Contrast":{"type":13,"value":[1.2000000476837158],"handleInfo":["ScalarParameter_0",1,13]},"HDRI_Brightness":{"type":13,"value":[1.600000023841858],"handleInfo":["ScalarParameter_0",2,13]},"Material_TextureCube_0":{"value":"white","type":31},"VectorParameter_0":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,0.7944809794425964,0.45833298563957214,1]},"ScalarParameter_0":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[0.1849760115146637,1.2000000476837158,1.600000023841858,0]}}}]},{"name":"transparent","passes":[{"program":"../resources/Exported/LakeWoodenHouse/Maps/Demonstrationlight.Demonstrationlight_PersistentLevel.BP_LightStage.MaterialInstanceDynamic_2|unlit-vs|unlit-fs","embeddedMacros":{"CC_TRANSPARENT":true},"blendState":{"targets":[{"blend":true,"blendSrc":2,"blendDst":4,"blendDstAlpha":4}]},"depthStencilState":{"depthTest":true,"depthWrite":false},"properties":{"HDRI_Tint":{"type":16,"value":[1,0.7944809794425964,0.45833298563957214,1],"handleInfo":["VectorParameter_0",0,16]},"CubemapRotation":{"type":13,"value":[0.1849760115146637],"handleInfo":["ScalarParameter_0",0,13]},"HDRI_Contrast":{"type":13,"value":[1.2000000476837158],"handleInfo":["ScalarParameter_0",1,13]},"HDRI_Brightness":{"type":13,"value":[1.600000023841858],"handleInfo":["ScalarParameter_0",2,13]},"Material_TextureCube_0":{"value":"white","type":31},"VectorParameter_0":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,0.7944809794425964,0.45833298563957214,1]},"ScalarParameter_0":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[0.1849760115146637,1.2000000476837158,1.600000023841858,0]}}}]}]]],0,0,[],[],[]]
