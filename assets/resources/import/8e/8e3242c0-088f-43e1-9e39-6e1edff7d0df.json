[1,0,0,[["cc.EffectAsset",["_name","shaders","techniques"],0]],[[0,0,1,2,4]],[[0,"../resources/Exported/LakeWoodenHouse/Maps/TestPositionOffset",[{"hash":1759195873,"name":"../resources/Exported/LakeWoodenHouse/Maps/TestPositionOffset|pbr-vs|pbr-fs","blocks":[],"samplerTextures":[],"samplers":[],"textures":[],"buffers":[{"name":"b_ccLightsBuffer","memoryAccess":1,"stageFlags":16,"binding":0,"defines":["CC_ENABLE_CLUSTERED_LIGHT_CULLING","CC_ENABLE_Builtin_CLUSTERED_LIGHT_CULLING"]},{"name":"b_clusterLightIndicesBuffer","memoryAccess":1,"stageFlags":16,"binding":1,"defines":["CC_ENABLE_CLUSTERED_LIGHT_CULLING","CC_ENABLE_Builtin_CLUSTERED_LIGHT_CULLING"]},{"name":"b_clusterLightGridBuffer","memoryAccess":1,"stageFlags":16,"binding":2,"defines":["CC_ENABLE_CLUSTERED_LIGHT_CULLING","CC_ENABLE_Builtin_CLUSTERED_LIGHT_CULLING"]}],"images":[],"subpassInputs":[],"attributes":[{"name":"a_position","format":32,"location":0,"defines":[]},{"name":"a_normal","format":32,"location":1,"defines":[]},{"name":"a_texCoord","format":21,"location":2,"defines":[]},{"name":"a_tangent","format":44,"location":3,"defines":[]},{"name":"a_vertexId","format":11,"location":6,"defines":["CC_USE_MORPH"]},{"name":"a_joints","location":4,"defines":["CC_USE_SKINNING"]},{"name":"a_weights","format":44,"location":5,"defines":["CC_USE_SKINNING"]},{"name":"a_jointAnimInfo","format":44,"isInstanced":true,"location":7,"defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION","USE_INSTANCING"]},{"name":"a_matWorld0","format":44,"isInstanced":true,"location":8,"defines":["USE_INSTANCING"]},{"name":"a_matWorld1","format":44,"isInstanced":true,"location":9,"defines":["USE_INSTANCING"]},{"name":"a_matWorld2","format":44,"isInstanced":true,"location":10,"defines":["USE_INSTANCING"]},{"name":"a_lightingMapUVParam","format":44,"isInstanced":true,"location":11,"defines":["USE_INSTANCING","CC_USE_LIGHTMAP"]},{"name":"a_dyn_batch_id","format":11,"location":12,"defines":["!USE_INSTANCING","USE_BATCHING"]},{"name":"a_color","format":44,"location":13,"defines":["CC_USE_ATTR_COLOR"]},{"name":"a_texCoord1","format":21,"location":14,"defines":[]},{"name":"a_lightingMapAdds0","format":44,"isInstanced":true,"location":15,"defines":["CC_USE_LIGHTMAP","!USE_BATCHING","!CC_FORWARD_ADD","USE_INSTANCING"]},{"name":"a_lightingMapAdds1","format":44,"isInstanced":true,"location":16,"defines":["CC_USE_LIGHTMAP","!USE_BATCHING","!CC_FORWARD_ADD","USE_INSTANCING"]},{"name":"a_lightingMapScales0","format":44,"isInstanced":true,"location":17,"defines":["CC_USE_LIGHTMAP","!USE_BATCHING","!CC_FORWARD_ADD","USE_INSTANCING"]},{"name":"a_lightingMapScales1","format":44,"isInstanced":true,"location":18,"defines":["CC_USE_LIGHTMAP","!USE_BATCHING","!CC_FORWARD_ADD","USE_INSTANCING"]}],"varyings":[{"name":"v_shadowPos","type":16,"count":1,"stageFlags":17,"location":0,"defines":[]},{"name":"v_color","type":16,"count":1,"stageFlags":17,"location":1,"defines":["CC_USE_ATTR_COLOR"]},{"name":"v_obj_position","type":15,"count":1,"stageFlags":17,"location":2,"defines":[]},{"name":"v_position","type":15,"count":1,"stageFlags":17,"location":3,"defines":[]},{"name":"v_normal","type":15,"count":1,"stageFlags":17,"location":4,"defines":[]},{"name":"v_uv","type":14,"count":1,"stageFlags":17,"location":5,"defines":[]},{"name":"v_tangent","type":15,"count":1,"stageFlags":17,"location":6,"defines":[]},{"name":"v_bitangent","type":15,"count":1,"stageFlags":17,"location":7,"defines":[]},{"name":"v_uv1","type":14,"count":1,"stageFlags":17,"location":8,"defines":[]},{"name":"v_lightingMapAdds0","type":16,"count":1,"stageFlags":17,"location":9,"defines":["CC_USE_LIGHTMAP","!USE_BATCHING","!CC_FORWARD_ADD","USE_INSTANCING"]},{"name":"v_lightingMapAdds1","type":16,"count":1,"stageFlags":17,"location":10,"defines":["CC_USE_LIGHTMAP","!USE_BATCHING","!CC_FORWARD_ADD","USE_INSTANCING"]},{"name":"v_lightingMapScales0","type":16,"count":1,"stageFlags":17,"location":11,"defines":["CC_USE_LIGHTMAP","!USE_BATCHING","!CC_FORWARD_ADD","USE_INSTANCING"]},{"name":"v_lightingMapScales1","type":16,"count":1,"stageFlags":17,"location":12,"defines":["CC_USE_LIGHTMAP","!USE_BATCHING","!CC_FORWARD_ADD","USE_INSTANCING"]},{"name":"v_luv","type":15,"count":1,"stageFlags":17,"location":13,"defines":["CC_USE_LIGHTMAP","!USE_BATCHING","!CC_FORWARD_ADD"]}],"fragColors":[{"name":"fragColor0","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":0,"tags":[],"defines":[]},{"name":"fragColor1","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":1,"defines":["CC_PIPELINE_TYPE"]},{"name":"fragColor2","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":2,"defines":["CC_PIPELINE_TYPE"]},{"name":"fragColor3","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":3,"defines":["CC_PIPELINE_TYPE"]}],"glsl4":{"vert":"#extension GL_EXT_shader_explicit_arithmetic_types_int32: require\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec3 a_normal;\nlayout(location = 2) in vec2 a_texCoord;\nlayout(location = 3) in vec4 a_tangent;\n#if CC_USE_MORPH\n    int getVertexId() {\n      return gl_VertexIndex;\n    }\n  layout(set = 2, binding = 4) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n  };\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n        ivec2 texSize = textureSize(tex, 0);\n        return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture(tex, x)),\n        decode32(texture(tex, y)),\n        decode32(texture(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    layout(set = 2, binding = 7) uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    layout(set = 2, binding = 8) uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    layout(set = 2, binding = 9) uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout StandardVertInput attr) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    attr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    attr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    attr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n    layout(location = 4) in u32vec4 a_joints;\n  layout(location = 5) in vec4 a_weights;\n  #if CC_USE_BAKED_ANIMATION\n    #if USE_INSTANCING\n      layout(location = 7) in highp vec4 a_jointAnimInfo;\n    #endif\n    layout(set = 2, binding = 3) uniform CCSkinningTexture {\n      highp vec4 cc_jointTextureInfo;\n    };\n    layout(set = 2, binding = 2) uniform CCSkinningAnimation {\n      highp vec4 cc_jointAnimInfo;\n    };\n    layout(set = 2, binding = 6) uniform highp sampler2D cc_jointTexture;\n      #else\n    layout(set = 2, binding = 3) uniform CCSkinning {\n      highp vec4 cc_joints[30 * 3];\n    };\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout StandardVertInput attr) {\n    mat4 m = skinMatrix();\n    attr.position = m * attr.position;\n    attr.normal = (m * vec4(attr.normal, 0.0)).xyz;\n    attr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n  }\n#endif\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\n#if USE_INSTANCING\n  layout(location = 8) in vec4 a_matWorld0;\n  layout(location = 9) in vec4 a_matWorld1;\n  layout(location = 10) in vec4 a_matWorld2;\n  #if CC_USE_LIGHTMAP\n    layout(location = 11) in vec4 a_lightingMapUVParam;\n  #endif\n#elif USE_BATCHING\n  layout(location = 12) in float a_dyn_batch_id;\n  layout(set = 2, binding = 0) uniform CCLocalBatched {\n    highp mat4 cc_matWorlds[10];\n  };\n#else\n  layout(set = 2, binding = 0) uniform CCLocal {\n    highp mat4 cc_matWorld;\n    highp mat4 cc_matWorldIT;\n    highp vec4 cc_lightingMapUVParam;\n  };\n#endif\nlayout(location = 0) out highp vec4 v_shadowPos;\nlayout(set = 0, binding = 2) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  lowp  vec4 cc_shadowNFLSInfo;\n  lowp  vec4 cc_shadowWHPBInfo;\n  lowp  vec4 cc_shadowLPNNInfo;\n  lowp  vec4 cc_shadowColor;\n};\n#if CC_RECEIVE_SHADOW\n  layout(set = 0, binding = 3) uniform highp sampler2D cc_shadowMap;\n  layout(set = 0, binding = 5) uniform highp sampler2D cc_spotLightingMap;\n#endif\n#if CC_USE_ATTR_COLOR\nlayout(location = 13) in vec4 a_color;\nlayout(location = 1) out vec4 v_color;\n#endif\nlayout(location = 2) out vec3 v_obj_position;\nlayout(location = 3) out vec3 v_position;\nlayout(location = 4) out vec3 v_normal;\nlayout(location = 5) out vec2 v_uv;\nlayout(location = 6) out vec3 v_tangent;\nlayout(location = 7) out vec3 v_bitangent;\nlayout(location = 14) in vec2 a_texCoord1;\nlayout(location = 8) out vec2 v_uv1;\n#if (CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD)\n    #if USE_INSTANCING\n      layout(location = 15) in vec4 a_lightingMapAdds0;\n      layout(location = 16) in vec4 a_lightingMapAdds1;\n      layout(location = 17) in vec4 a_lightingMapScales0;\n      layout(location = 18) in vec4 a_lightingMapScales1;\n      layout(location = 9) out vec4 v_lightingMapAdds0;\n      layout(location = 10) out vec4 v_lightingMapAdds1;\n      layout(location = 11) out vec4 v_lightingMapScales0;\n      layout(location = 12) out vec4 v_lightingMapScales1;\n      void getLightingMapVectors () {\n        v_lightingMapAdds0 = a_lightingMapAdds0;\n        v_lightingMapAdds1 = a_lightingMapAdds1;\n        v_lightingMapScales0 = a_lightingMapScales0;\n        v_lightingMapScales1 = a_lightingMapScales1;\n      }\n    #endif\n    layout(location = 13) out vec3 v_luv;\n    void CCLightingMapCaclUV()\n    {\n    #if !USE_INSTANCING\n      v_luv.xy = cc_lightingMapUVParam.xy + a_texCoord1 * cc_lightingMapUVParam.zw;\n      v_luv.z = cc_lightingMapUVParam.z;\n    #else\n      v_luv.xy = a_lightingMapUVParam.xy + a_texCoord1 * a_lightingMapUVParam.zw;\n      v_luv.z = a_lightingMapUVParam.z;\n    #endif\n    }\n#endif\nlayout(set = 0, binding = 7) uniform CCCustomView {\n    mat4 cc_view_taa_prev_viewProj;\n    mat4 cc_view_inverse_transpose_mirror;\n    vec4 cc_view_pr_reflectionPlane;\n    vec4 cc_view_pr_parameters;\n    vec4 cc_view_SkyIrradianceEnvironmentMap[7];\n    vec4 cc_view_SkyColor;\n    vec4 cc_view_SkyLightParameters;\n    vec4 cc_view_IndirectLightingColorScale_Intensity;\n    vec4 cc_view_PreExposure;\n    vec4 cc_view_taa_params1;\n    vec4 cc_view_taa_params2;\n    vec4 cc_view_final_screen_params;\n    vec4 cc_ibl_cluster_BoundsMin;\n    vec4 cc_ibl_cluster_BoundsDelta;\n    vec4 cc_ibl_cluster_CellsDot;\n    vec4 cc_ibl_cluster_CellsMax;\n    vec4 cc_ibl_cluster_TextureSize;\n    vec4 cc_ibl_cluster_InfoTextureInvSize;\n    vec4 cc_ibl_cluster_CellsCountByBoundsSizeAndPixelsPerCell;\n    vec4 cc_light_cluster_BoundsMin;\n    vec4 cc_light_cluster_BoundsDelta;\n    vec4 cc_light_cluster_CellsDot;\n    vec4 cc_light_cluster_CellsMax;\n    vec4 cc_light_cluster_TextureSize;\n    vec4 cc_light_cluster_InfoTextureInvSize;\n    vec4 cc_light_cluster_CellsCountByBoundsSizeAndPixelsPerCell;\n    vec4 FogStruct_ExponentialFogParameters;\n    vec4 FogStruct_ExponentialFogColorParameter;\n    vec4 FogStruct_ExponentialFogParameters2;\n    vec4 FogStruct_ExponentialFogParameters3;\n};\nstruct GlobalView {\n    vec3 IndirectLightingColorScale;\n    float PreExposure;\n};\nvoid sincos0(float a, out float s, out float c)\n{\n  s = sin(a);\n  c = cos(a);\n}\nstruct Light {\n  vec3 color;\n  vec3 direction;\n};\nstruct FDirectLighting\n{\n  vec3 Diffuse;\n  vec3 Specular;\n};\nstruct FPixelMaterialInputs\n{\n  vec3 Normal;\n  vec3 EmissiveColor;\n  float Opacity;\n  float OpacityMask;\n  vec3 BaseColor;\n  float Metallic;\n  float Specular;\n  float Roughness;\n  float AmbientOcclusion;\n  float Anisotropy;\n  float Tangent;\n  float Refraction;\n  float PixelDepthOffset;\n  float ShadingModel;\n  float TwoSidedSign;\n  float RoughnessWithClamp;\n  vec3 DiffuseColor;\n  vec3 SpecularColor;\n  vec3 Subsurface;\n};\nstruct FMaterialPixelParameters {\n  float IndirectIrradiance;\n  vec2 TexCoords_0;\n  vec2 TexCoords_1;\n  vec4 VertexColor;\n  vec3 WorldNormal;\n  vec3 WorldTangent;\n  vec3 ReflectionVector;\n  vec3 CameraVector;\n  vec3 LightVector;\n  vec4 SvPosition;\n  vec4 ScreenPosition;\n  mat3 TangentToWorld;\n  vec3 AbsoluteWorldPosition;\n  vec3 ObjectWorldPosition;\n  vec2 LightmapUVs;\n  int PrimitiveId;\n};\nstruct FMaterialVertexParameters {\n  vec3 WorldPosition;\n  vec4 VertexColor;\n};\n  vec3 RotateAboutAxis(vec4 NormalizedRotationAxisAndAngle, vec3 PositionOnAxis, vec3 Position) {\n      vec3 ClosestPointOnAxis = (PositionOnAxis + vec3 ((NormalizedRotationAxisAndAngle * dot(vec3 (NormalizedRotationAxisAndAngle), (Position - PositionOnAxis)))));\n      vec3 UAxis = (Position - ClosestPointOnAxis);\n      vec3 VAxis = cross(vec3 (NormalizedRotationAxisAndAngle), UAxis);\n      float CosAngle;\n      float SinAngle;\n      sincos0((NormalizedRotationAxisAndAngle).w, SinAngle, CosAngle);\n      vec3 R = ((UAxis * CosAngle) + (VAxis * SinAngle));\n      vec3 RotatedPosition = (ClosestPointOnAxis + R);\n      return (RotatedPosition - Position);\n  }\n  vec3 GetWorldPosition(FMaterialPixelParameters Parameters) {\n      return (Parameters).AbsoluteWorldPosition;\n  }\n  vec3 GetWorldPosition(FMaterialVertexParameters Parameters) {\n      return (Parameters).WorldPosition;\n  }\n  vec3 GetPrevWorldPosition(FMaterialVertexParameters Parameters) {\n      return (Parameters).WorldPosition;\n  }\n   vec4 F4_0101 = vec4(0, 1, 0, 1);\n  vec3 GetMaterialWorldPositionOffset(FMaterialVertexParameters Parameters) {\n    float Local0 = (cc_time.x * 0.250000);\n    float Local1 = (Local0 * (-0.500000));\n    float Local2 = ((F4_0101).a * Local1);\n    vec3 Local3 = (((F4_0101).rgb / sqrt(dot((F4_0101).rgb, (F4_0101).rgb))) * Local2);\n    vec3 Local4 = (GetWorldPosition(Parameters) / 1024.000000);\n    vec3 Local5 = (Local3 + Local4);\n    vec3 Local6 = (Local5 + vec3 (0.500000));\n    vec3 Local7 = fract(Local6);\n    vec3 Local8 = (Local7 * 2.000000);\n    vec3 Local9 = (Local8 + vec3 ((-1.000000)));\n    vec3 Local10 = abs(Local9);\n    vec3 Local11 = (Local10 * 2.000000);\n    vec3 Local12 = (vec3 (3.000000) - Local11);\n    vec3 Local13 = (Local12 * Local10);\n    vec3 Local14 = (Local13 * Local10);\n    float Local15 = dot(((F4_0101).rgb / sqrt(dot((F4_0101).rgb, (F4_0101).rgb))), Local14);\n    vec3 Local16 = (GetWorldPosition(Parameters) / 200.000000);\n    vec3 Local17 = (vec3 (Local2) + Local16);\n    vec3 Local18 = (Local17 + vec3 (0.500000));\n    vec3 Local19 = fract(Local18);\n    vec3 Local20 = (Local19 * 2.000000);\n    vec3 Local21 = (Local20 + vec3 ((-1.000000)));\n    vec3 Local22 = abs(Local21);\n    vec3 Local23 = (Local22 * 2.000000);\n    vec3 Local24 = (vec3 (3.000000) - Local23);\n    vec3 Local25 = (Local24 * Local22);\n    vec3 Local26 = (Local25 * Local22);\n    vec3 Local27 = (Local26 - vec3 (0.000000));\n    float Local28 = dot(Local27, Local27);\n    float Local29 = sqrt(Local28);\n    float Local30 = (Local15 + Local29);\n    float Local31 = (Local30 * 6.283185);\n    vec3 Local32 = RotateAboutAxis(vec4(cross(((F4_0101).rgb / sqrt(dot((F4_0101).rgb, (F4_0101).rgb))), vec3(0.000000, 0.000000, 1.000000)), Local31), (vec3 (0.500000) + vec3(0.000000, 0.000000, (-10.000000))), vec3(0.500000, 0.500000, 0.500000));\n    vec3 Local33 = (Local32 * ((Parameters).VertexColor).r);\n    vec3 Local34 = (Local33 * 0.100000);\n    vec3 Local35 = (Local34 + vec3 (0.500000));\n    float Local36 = (cc_time.x * 0.250000);\n    float Local37 = (Local36 * (-0.500000));\n    float Local38 = ((F4_0101).a * Local37);\n    vec3 Local39 = (((F4_0101).rgb / sqrt(dot((F4_0101).rgb, (F4_0101).rgb))) * Local38);\n    vec3 Local40 = (GetPrevWorldPosition(Parameters) / 1024.000000);\n    vec3 Local41 = (Local39 + Local40);\n    vec3 Local42 = (Local41 + vec3 (0.500000));\n    vec3 Local43 = fract(Local42);\n    vec3 Local44 = (Local43 * 2.000000);\n    vec3 Local45 = (Local44 + vec3 ((-1.000000)));\n    vec3 Local46 = abs(Local45);\n    vec3 Local47 = (Local46 * 2.000000);\n    vec3 Local48 = (vec3 (3.000000) - Local47);\n    vec3 Local49 = (Local48 * Local46);\n    vec3 Local50 = (Local49 * Local46);\n    float Local51 = dot(((F4_0101).rgb / sqrt(dot((F4_0101).rgb, (F4_0101).rgb))), Local50);\n    vec3 Local52 = (GetPrevWorldPosition(Parameters) / 200.000000);\n    vec3 Local53 = (vec3 (Local38) + Local52);\n    vec3 Local54 = (Local53 + vec3 (0.500000));\n    vec3 Local55 = fract(Local54);\n    vec3 Local56 = (Local55 * 2.000000);\n    vec3 Local57 = (Local56 + vec3 ((-1.000000)));\n    vec3 Local58 = abs(Local57);\n    vec3 Local59 = (Local58 * 2.000000);\n    vec3 Local60 = (vec3 (3.000000) - Local59);\n    vec3 Local61 = (Local60 * Local58);\n    vec3 Local62 = (Local61 * Local58);\n    vec3 Local63 = (Local62 - vec3 (0.000000));\n    float Local64 = dot(Local63, Local63);\n    float Local65 = sqrt(Local64);\n    float Local66 = (Local51 + Local65);\n    float Local67 = (Local66 * 6.283185);\n    vec3 Local68 = RotateAboutAxis(vec4(cross(((F4_0101).rgb / sqrt(dot((F4_0101).rgb, (F4_0101).rgb))), vec3(0.000000, 0.000000, 1.000000)), Local67), (vec3 (0.500000) + vec3(0.000000, 0.000000, (-10.000000))), vec3(0.500000, 0.500000, 0.500000));\n    vec3 Local69 = (Local68 * ((Parameters).VertexColor).r);\n    vec3 Local70 = (Local69 * 0.100000);\n    vec3 Local71 = (Local70 + vec3 (0.500000));\n    return Local35;\n}\nvoid main () {\n  StandardVertInput In;\n      In.position = vec4(a_position, 1.0);\n      In.normal = a_normal;\n      In.tangent = a_tangent;\n    #if CC_USE_MORPH\n      applyMorph(In);\n    #endif\n    #if CC_USE_SKINNING\n      CCSkin(In);\n    #endif\n  mat4 matWorld, matWorldIT;\n    #if USE_INSTANCING\n      matWorld = mat4(\n        vec4(a_matWorld0.xyz, 0.0),\n        vec4(a_matWorld1.xyz, 0.0),\n        vec4(a_matWorld2.xyz, 0.0),\n        vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n      );\n      matWorldIT = matWorld;\n    #elif USE_BATCHING\n      matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n      matWorldIT = matWorld;\n    #else\n      matWorld = cc_matWorld;\n      matWorldIT = cc_matWorldIT;\n    #endif\n  vec4 pos = matWorld * In.position;\n  FMaterialVertexParameters Parameters;\n  Parameters.WorldPosition = pos.xzy * 100.;\n  #if CC_USE_ATTR_COLOR\n  Parameters.VertexColor = a_color;\n  #else\n  Parameters.VertexColor = vec4(1.);\n  #endif\n  pos.xyz += GetMaterialWorldPositionOffset(Parameters).xzy / 100.;\n  v_obj_position = matWorld[3].xyz;\n  v_position = pos.xyz;\n  v_normal = normalize((matWorldIT * vec4(In.normal, 0.0)).xyz);\n  v_tangent = normalize((matWorld * vec4(In.tangent.xyz, 0.0)).xyz);\n  v_bitangent = normalize(cross(v_normal, v_tangent) * In.tangent.w);\n  v_uv = a_texCoord;\n  #if SAMPLE_FROM_RT\n      v_uv = cc_cameraPos.w > 1.0 ? vec2(v_uv.x, 1.0 - v_uv.y) : v_uv;\n  #endif\n  v_uv1 = a_texCoord1;\n  #if SAMPLE_FROM_RT\n      v_uv1 = cc_cameraPos.w > 1.0 ? vec2(v_uv1.x, 1.0 - v_uv1.y) : v_uv1;\n  #endif\n  #if CC_USE_ATTR_COLOR\n  v_color = a_color;\n  #endif\n  #if (CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD)\n    CCLightingMapCaclUV();\n    #if USE_INSTANCING\n      getLightingMapVectors();\n    #endif\n  #endif\n  v_shadowPos = cc_matLightViewProj * pos;\n  mat4 matProj = cc_matProj;\n  matProj[2][0] += cc_view_taa_params1.x;\n  matProj[2][1] += cc_view_taa_params1.y;\n  gl_Position = matProj * cc_matView * pos;\n}","frag":"\nprecision highp float;\n  layout(set = 0, binding = 0) uniform CCGlobal {\n    highp   vec4 cc_time;\n    mediump vec4 cc_screenSize;\n    mediump vec4 cc_nativeSize;\n  };\n  layout(set = 0, binding = 1) uniform CCCamera {\n    highp   mat4 cc_matView;\n    highp   mat4 cc_matViewInv;\n    highp   mat4 cc_matProj;\n    highp   mat4 cc_matProjInv;\n    highp   mat4 cc_matViewProj;\n    highp   mat4 cc_matViewProjInv;\n    highp   vec4 cc_cameraPos;\n    mediump vec4 cc_screenScale;\n    mediump vec4 cc_exposure;\n    mediump vec4 cc_mainLitDir;\n    mediump vec4 cc_mainLitColor;\n    mediump vec4 cc_ambientSky;\n    mediump vec4 cc_ambientGround;\n    mediump vec4 cc_fogColor;\n    mediump vec4 cc_fogBase;\n    mediump vec4 cc_fogAdd;\n    mediump vec4 cc_nearFar;\n    mediump vec4 cc_viewPort;\n  };\n  layout(set = 2, binding = 0) uniform CCLocal {\n    highp mat4 cc_matWorld;\n    highp mat4 cc_matWorldIT;\n    highp vec4 cc_lightingMapUVParam;\n  };\n  layout(set = 0, binding = 7) uniform CCCustomView {\n      mat4 cc_view_taa_prev_viewProj;\n      mat4 cc_view_inverse_transpose_mirror;\n      vec4 cc_view_pr_reflectionPlane;\n      vec4 cc_view_pr_parameters;\n      vec4 cc_view_SkyIrradianceEnvironmentMap[7];\n      vec4 cc_view_SkyColor;\n      vec4 cc_view_SkyLightParameters;\n      vec4 cc_view_IndirectLightingColorScale_Intensity;\n      vec4 cc_view_PreExposure;\n      vec4 cc_view_taa_params1;\n      vec4 cc_view_taa_params2;\n      vec4 cc_view_final_screen_params;\n      vec4 cc_ibl_cluster_BoundsMin;\n      vec4 cc_ibl_cluster_BoundsDelta;\n      vec4 cc_ibl_cluster_CellsDot;\n      vec4 cc_ibl_cluster_CellsMax;\n      vec4 cc_ibl_cluster_TextureSize;\n      vec4 cc_ibl_cluster_InfoTextureInvSize;\n      vec4 cc_ibl_cluster_CellsCountByBoundsSizeAndPixelsPerCell;\n      vec4 cc_light_cluster_BoundsMin;\n      vec4 cc_light_cluster_BoundsDelta;\n      vec4 cc_light_cluster_CellsDot;\n      vec4 cc_light_cluster_CellsMax;\n      vec4 cc_light_cluster_TextureSize;\n      vec4 cc_light_cluster_InfoTextureInvSize;\n      vec4 cc_light_cluster_CellsCountByBoundsSizeAndPixelsPerCell;\n      vec4 FogStruct_ExponentialFogParameters;\n      vec4 FogStruct_ExponentialFogColorParameter;\n      vec4 FogStruct_ExponentialFogParameters2;\n      vec4 FogStruct_ExponentialFogParameters3;\n  };\n  struct GlobalView {\n      vec3 IndirectLightingColorScale;\n      float PreExposure;\n  };\n  void getGlobalView (out GlobalView View) {\n      View.IndirectLightingColorScale = cc_view_IndirectLightingColorScale_Intensity.rgb * cc_view_IndirectLightingColorScale_Intensity.w;\n      View.PreExposure = cc_view_PreExposure.x;\n  }\nfloat Luminance( vec3 LinearColor )\n{\n  return dot( LinearColor, vec3( 0.3, 0.59, 0.11 ) );\n}\nvec3 CCRGBE2Linear (vec4 rgbe) {\n    return rgbe.rgb * pow(1.1, rgbe.a * 255.0 - 128.0);\n}\nvec4 decodeCCRGBE (vec4 color) {\n  color.rgb = CCRGBE2Linear(color);\n  color.a = 1.;\n  return color;\n}\nfloat rsqrt (float x) {\n  return 1. / sqrt(x);\n}\nfloat Square(float v)\n{\n    return v * v;\n}\nstruct Light {\n  vec3 color;\n  vec3 direction;\n};\nstruct FDirectLighting\n{\n  vec3 Diffuse;\n  vec3 Specular;\n};\nstruct FPixelMaterialInputs\n{\n  vec3 Normal;\n  vec3 EmissiveColor;\n  float Opacity;\n  float OpacityMask;\n  vec3 BaseColor;\n  float Metallic;\n  float Specular;\n  float Roughness;\n  float AmbientOcclusion;\n  float Anisotropy;\n  float Tangent;\n  float Refraction;\n  float PixelDepthOffset;\n  float ShadingModel;\n  float TwoSidedSign;\n  float RoughnessWithClamp;\n  vec3 DiffuseColor;\n  vec3 SpecularColor;\n  vec3 Subsurface;\n};\nstruct FMaterialPixelParameters {\n  float IndirectIrradiance;\n  vec2 TexCoords_0;\n  vec2 TexCoords_1;\n  vec4 VertexColor;\n  vec3 WorldNormal;\n  vec3 WorldTangent;\n  vec3 ReflectionVector;\n  vec3 CameraVector;\n  vec3 LightVector;\n  vec4 SvPosition;\n  vec4 ScreenPosition;\n  mat3 TangentToWorld;\n  vec3 AbsoluteWorldPosition;\n  vec3 ObjectWorldPosition;\n  vec2 LightmapUVs;\n  int PrimitiveId;\n};\nstruct FMaterialVertexParameters {\n  vec3 WorldPosition;\n  vec4 VertexColor;\n};\n  vec3 GetMaterialNormalRaw(FPixelMaterialInputs PixelMaterialInputs) {\n      return vec3 ((PixelMaterialInputs).Normal);\n  }\n  vec3 GetMaterialNormal(FMaterialPixelParameters Parameters, FPixelMaterialInputs PixelMaterialInputs) {\n      vec3 RetNormal = GetMaterialNormalRaw(PixelMaterialInputs);\n      return RetNormal;\n  }\n  vec3 TransformTangentNormalToWorld(mat3 TangentToWorld, vec3 normal) {\n      return normalize((TangentToWorld * normalize(normal)));\n  }\n  vec3 ReflectionAboutCustomWorldNormal(inout FMaterialPixelParameters Parameters, vec3 WorldNormal, bool bNormalizeInputNormal) {\n      ((Parameters).WorldNormal = (TransformTangentNormalToWorld((Parameters).TangentToWorld, (Parameters).WorldNormal)).xzy);\n      ((Parameters).ReflectionVector = normalize(reflect((-(Parameters).CameraVector), (Parameters).WorldNormal)));\n      return (Parameters).ReflectionVector;\n  }\n  vec4 SvPositionToResolvedScreenPosition(vec4 SvPosition) {\n      vec2 pixelPos = (SvPosition).xy;\n      vec3 ndc = vec3((((pixelPos * (cc_screenSize).zw) - vec2 (0.500000)) * 2.000000), (gl_FragCoord));\n      vec4 screenPos = (vec4(ndc, 1.000000) / (gl_FragCoord));\n      return screenPos;\n  }\n   vec4 F4_0101 = vec4(0, 1, 0, 1);\nvoid CalcPixelMaterialInputs(inout FMaterialPixelParameters Parameters, inout FPixelMaterialInputs PixelMaterialInputs) {\n    ((PixelMaterialInputs).Normal = vec3(0.000000, 0.000000, 1.000000));\n    vec3 MaterialNormal = vec3 (GetMaterialNormal(Parameters, PixelMaterialInputs));\n    ((Parameters).WorldNormal = normalize(MaterialNormal));\n    ((Parameters).ReflectionVector = ReflectionAboutCustomWorldNormal(Parameters, (Parameters).WorldNormal, false));\n    ((PixelMaterialInputs).EmissiveColor = vec3(0.000000, 0.000000, 0.000000));\n    ((PixelMaterialInputs).Opacity = 1.000000);\n    ((PixelMaterialInputs).OpacityMask = 1.000000);\n    ((PixelMaterialInputs).BaseColor = vec3(0.270222, 0.242972, 0.937500));\n    ((PixelMaterialInputs).Metallic = 0.000000);\n    ((PixelMaterialInputs).Specular = 0.500000);\n    ((PixelMaterialInputs).Roughness = 0.500000);\n    ((PixelMaterialInputs).Anisotropy = 0.000000);\n    ((PixelMaterialInputs).Tangent = float (vec3(1.000000, 0.000000, 0.000000)));\n    ((PixelMaterialInputs).Subsurface = vec3 (0));\n    ((PixelMaterialInputs).AmbientOcclusion = 1.000000);\n    ((Parameters).WorldTangent = vec3 (0));\n}\n#if CC_USE_ATTR_COLOR\nlayout(location = 1) in vec4 v_color;\n#endif\nlayout(location = 2) in vec3 v_obj_position;\nlayout(location = 3) in vec3 v_position;\nlayout(location = 4) in vec3 v_normal;\nlayout(location = 5) in vec2 v_uv;\nlayout(location = 8) in vec2 v_uv1;\nlayout(location = 6) in vec3 v_tangent;\nlayout(location = 7) in vec3 v_bitangent;\nvoid getPixelParameters (out FMaterialPixelParameters Parameters) {\n  Parameters.TexCoords_0 = v_uv;\n  Parameters.TexCoords_1 = v_uv1;\n  #if CC_USE_ATTR_COLOR\n    Parameters.VertexColor = v_color;\n  #else\n    Parameters.VertexColor = vec4(1.);\n  #endif\n  Parameters.WorldNormal = v_normal;\n  Parameters.AbsoluteWorldPosition = v_position;\n  Parameters.ObjectWorldPosition = v_obj_position;\n  Parameters.CameraVector = normalize(cc_cameraPos.xyz - v_position);\n  Parameters.SvPosition = gl_FragCoord;\n  Parameters.ScreenPosition = SvPositionToResolvedScreenPosition(gl_FragCoord);\n  Parameters.TangentToWorld = mat3(\n    v_tangent,\n    v_bitangent,\n    v_normal\n  );\n  Parameters.LightmapUVs = v_uv1;\n  Parameters.IndirectIrradiance = 0.;\n}\nvoid surf (out FPixelMaterialInputs PixelMaterialInputs, out FMaterialPixelParameters Parameters, out GlobalView View) {\n  getPixelParameters(Parameters);\n  getGlobalView(View);\n  Parameters.AbsoluteWorldPosition = Parameters.AbsoluteWorldPosition.xzy * 100.;\n  Parameters.ObjectWorldPosition = Parameters.ObjectWorldPosition.xzy * 100.;\n  Parameters.CameraVector = Parameters.CameraVector.xzy;\n  CalcPixelMaterialInputs(Parameters, PixelMaterialInputs);\n  float TwoSidedSign = 1.;\n  if (!gl_FrontFacing) {\n    TwoSidedSign = -1.;\n  }\n  Parameters.AbsoluteWorldPosition = Parameters.AbsoluteWorldPosition.xzy / 100.;\n  Parameters.ObjectWorldPosition = Parameters.ObjectWorldPosition.xzy / 100.;\n  Parameters.CameraVector = Parameters.CameraVector.xzy;\n  Parameters.WorldNormal = Parameters.WorldNormal.xzy * TwoSidedSign;\n  Parameters.ReflectionVector = Parameters.ReflectionVector.xzy;\n  if (PixelMaterialInputs.OpacityMask < 0.33330) {\n    discard;\n  }\n  PixelMaterialInputs.Metallic = clamp(PixelMaterialInputs.Metallic, 0.0, 1.0);\n  PixelMaterialInputs.Specular = clamp(PixelMaterialInputs.Specular, 0.0, 1.0);\n  PixelMaterialInputs.Roughness = clamp(PixelMaterialInputs.Roughness, 0.0, 1.0);\n  PixelMaterialInputs.TwoSidedSign = TwoSidedSign;\n}\nfloat GGX_Mobile(float Roughness, float NoH, vec3 H, vec3 N)\n{\n    vec3 NxH = cross(N, H);\n    float OneMinusNoHSqr = dot(NxH, NxH);\n    float a = Roughness * Roughness;\n    float n = NoH * a;\n    float p = a / (OneMinusNoHSqr + n * n);\n    return p * p;\n}\nfloat D_GGX( float a2, float NoH )\n{\n  float d = ( NoH * a2 - NoH ) * NoH + 1.;\n  return a2 / ( 3.14159265359*d*d );\n}\n  layout(location = 0) in highp vec4 v_shadowPos;\n  layout(set = 0, binding = 2) uniform CCShadow {\n    highp mat4 cc_matLightPlaneProj;\n    highp mat4 cc_matLightView;\n    highp mat4 cc_matLightViewProj;\n    highp vec4 cc_shadowInvProjDepthInfo;\n    highp vec4 cc_shadowProjDepthInfo;\n    highp vec4 cc_shadowProjInfo;\n    lowp  vec4 cc_shadowNFLSInfo;\n    lowp  vec4 cc_shadowWHPBInfo;\n    lowp  vec4 cc_shadowLPNNInfo;\n    lowp  vec4 cc_shadowColor;\n  };\n  float CCGetLinearDepthFromViewSpace(vec3 viewPos) {\n    float dist = length(viewPos);\n    return (dist - cc_shadowNFLSInfo.x) / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x);\n  }\n  float CCGetLinearDepth(vec3 worldPos) {\n    vec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n    return CCGetLinearDepthFromViewSpace(viewStartPos.xyz);\n  }\n  #if CC_RECEIVE_SHADOW\n    layout(set = 0, binding = 3) uniform highp sampler2D cc_shadowMap;\n    layout(set = 0, binding = 5) uniform highp sampler2D cc_spotLightingMap;\n    vec4 ApplyShadowDepthBias_FaceNormal(vec4 shadowPos, vec3 worldNormal)\n    {\n      vec4 newShadowPos = shadowPos;\n      if(cc_shadowLPNNInfo.z > 0.0001)\n      {\n        vec4 viewNormal = cc_matLightView * vec4(worldNormal, 0.0);\n        if(viewNormal.z < 0.1)\n          newShadowPos.xy += viewNormal.xy * cc_shadowProjInfo.xy * cc_shadowLPNNInfo.z * clamp(viewNormal.z, 0.001, 0.1);\n      }\n      return newShadowPos;\n    }\n    vec4 ApplyShadowDepthBias_Perspective(vec4 shadowPos, float viewspaceDepthBias)\n    {\n      vec3 viewSpacePos;\n      viewSpacePos.xy = shadowPos.xy * cc_shadowProjInfo.zw;\n      viewSpacePos.z = shadowPos.z * cc_shadowInvProjDepthInfo.x + shadowPos.w * cc_shadowInvProjDepthInfo.y;\n      viewSpacePos.xyz += cc_shadowProjDepthInfo.z * normalize(viewSpacePos.xyz) * viewspaceDepthBias;\n      vec4 clipSpacePos;\n      clipSpacePos.xy = viewSpacePos.xy * cc_shadowProjInfo.xy;\n      clipSpacePos.zw = viewSpacePos.z * cc_shadowProjDepthInfo.xz + vec2(cc_shadowProjDepthInfo.y, 0.0);\n      if (cc_shadowNFLSInfo.z > 0.000001) {\n        clipSpacePos.z = CCGetLinearDepthFromViewSpace(viewSpacePos.xyz);\n        clipSpacePos.z = (clipSpacePos.z * 2.0 - 1.0) * clipSpacePos.w;\n      }\n      return clipSpacePos;\n    }\n    vec4 ApplyShadowDepthBias_Orthographic(vec4 shadowPos, float viewspaceDepthBias)\n    {\n      float coeffA = cc_shadowProjDepthInfo.x;\n      float coeffB = cc_shadowProjDepthInfo.y;\n      float viewSpacePos_z = (shadowPos.z - coeffB) / coeffA;\n      viewSpacePos_z += viewspaceDepthBias;\n      vec4 result = shadowPos;\n      result.z = viewSpacePos_z * coeffA + coeffB;\n      return result;\n    }\n    float CCGetShadowFactorHard (vec4 shadowPos) {\n      vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, cc_shadowWHPBInfo.w);\n      vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n      if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n          clipPos.y < 0.0 || clipPos.y > 1.0 ||\n          clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n      clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n      float shadow = 0.0;\n      float closestDepth = 0.0;\n      if (cc_shadowLPNNInfo.y > 0.000001) {\n        closestDepth = dot(texture(cc_shadowMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n      } else {\n        closestDepth = texture(cc_shadowMap, clipPos.xy).x;\n      }\n      shadow = step(clipPos.z, closestDepth);\n      return shadow;\n    }\n    float CCGetShadowFactorSoft (vec4 shadowPos) {\n      vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, cc_shadowWHPBInfo.w);\n      vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n      if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n          clipPos.y < 0.0 || clipPos.y > 1.0 ||\n          clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n      clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n      float offsetDepth = clipPos.z;\n      vec2 mapSize = cc_shadowWHPBInfo.xy;\n      vec2 oneTap = 1.0 / mapSize;\n      vec2 clipPos_offset = clipPos.xy + oneTap;\n      float block0, block1, block2, block3;\n      if (cc_shadowLPNNInfo.y > 0.000001) {\n        block0 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block1 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block2 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block3 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      } else {\n        block0 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\n        block1 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)).x);\n        block2 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)).x);\n        block3 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);\n      }\n      float coefX   = mod(clipPos.x, oneTap.x) * mapSize.x;\n      float resultX = mix(block0, block1, coefX);\n      float resultY = mix(block2, block3, coefX);\n      float coefY   = mod(clipPos.y, oneTap.y) * mapSize.y;\n      return mix(resultX, resultY, coefY);\n    }\n    float CCGetShadowFactorSoft2X (vec4 shadowPos) {\n      vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, cc_shadowWHPBInfo.w);\n      vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n      if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n          clipPos.y < 0.0 || clipPos.y > 1.0 ||\n          clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n      clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n      float offsetDepth = clipPos.z;\n      vec2 mapSize = cc_shadowWHPBInfo.xy;\n      vec2 oneTap = 1.0 / mapSize;\n      float clipPos_offset_L = clipPos.x - oneTap.x;\n      float clipPos_offset_R = clipPos.x + oneTap.x;\n      float clipPos_offset_U = clipPos.y - oneTap.y;\n      float clipPos_offset_D = clipPos.y + oneTap.y;\n      float block0, block1, block2, block3, block4, block5, block6, block7, block8;\n      if (cc_shadowLPNNInfo.y > 0.000001) {\n        block0 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block1 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block2 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block3 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block4 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block5 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block6 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block7 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block8 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      } else {\n        block0 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);\n        block1 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)).x);\n        block2 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);\n        block3 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)).x);\n        block4 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\n        block5 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)).x);\n        block6 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);\n        block7 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)).x);\n        block8 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);\n      }\n      float coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\n      float coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\n      float shadow = 0.0;\n      float resultX = mix(block0, block1, coefX);\n      float resultY = mix(block3, block4, coefX);\n      shadow += mix(resultX , resultY, coefY);\n      resultX = mix(block1, block2, coefX);\n      resultY = mix(block4, block5, coefX);\n      shadow += mix(resultX , resultY, coefY);\n      resultX = mix(block3, block4, coefX);\n      resultY = mix(block6, block7, coefX);\n      shadow += mix(resultX, resultY, coefY);\n      resultX = mix(block4, block5, coefX);\n      resultY = mix(block7, block8, coefX);\n      shadow += mix(resultX, resultY, coefY);\n      return shadow * 0.25;\n    }\n    float CCGetSpotLightShadowFactorHard (vec4 shadowPos, vec3 worldPos) {\n      vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, cc_shadowWHPBInfo.w);\n      vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n      if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n          clipPos.y < 0.0 || clipPos.y > 1.0 ||\n          clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n      clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n      float shadow = 0.0;\n      float closestDepth = 0.0;\n      float depth = clipPos.z;\n      if (cc_shadowLPNNInfo.y > 0.000001) {\n        closestDepth = dot(texture(cc_spotLightingMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n      } else {\n        closestDepth = texture(cc_spotLightingMap, clipPos.xy).x;\n      }\n      shadow = step(depth, closestDepth);\n      return shadow;\n    }\n    float CCGetSpotLightShadowFactorSoft (vec4 shadowPos, vec3 worldPos) {\n      vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, cc_shadowWHPBInfo.w);\n      vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n      if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n          clipPos.y < 0.0 || clipPos.y > 1.0 ||\n          clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n      clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n      float depth = 0.0;\n      if (cc_shadowNFLSInfo.z > 0.000001) {\n        depth = CCGetLinearDepth(worldPos);\n      } else {\n        depth = clipPos.z;\n      }\n      float bias = cc_shadowWHPBInfo.w;\n      vec2 oneTap = 1.0 / cc_shadowWHPBInfo.xy;\n      vec2 clipPos_offset = clipPos.xy + oneTap;\n      float block0, block1, block2, block3;\n      if (cc_shadowLPNNInfo.y > 0.000001) {\n        block0 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block1 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block2 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block3 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      } else {\n        block0 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x);\n        block1 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos.y)).x);\n        block2 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset.y)).x);\n        block3 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);\n      }\n      float coefX   = mod(clipPos.x, oneTap.x) * cc_shadowWHPBInfo.x;\n      float resultX = mix(block0, block1, coefX);\n      float resultY = mix(block2, block3, coefX);\n      float coefY   = mod(clipPos.y, oneTap.y) * cc_shadowWHPBInfo.y;\n      return mix(resultX, resultY, coefY);\n    }\n    float CCGetSpotLightShadowFactorSoft2X (vec4 shadowPos, vec3 worldPos) {\n      vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, cc_shadowWHPBInfo.w);\n      vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n      if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n          clipPos.y < 0.0 || clipPos.y > 1.0 ||\n          clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n      clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n      float depth = 0.0;\n      if (cc_shadowNFLSInfo.z > 0.000001) {\n        depth = CCGetLinearDepth(worldPos);\n      } else {\n        depth = clipPos.z;\n      }\n      float bias = cc_shadowWHPBInfo.w;\n      vec2 mapSize = cc_shadowWHPBInfo.xy;\n      vec2 oneTap = 1.0 / mapSize;\n      float clipPos_offset_L = clipPos.x - oneTap.x;\n      float clipPos_offset_R = clipPos.x + oneTap.x;\n      float clipPos_offset_U = clipPos.y - oneTap.y;\n      float clipPos_offset_D = clipPos.y + oneTap.y;\n      float block0, block1, block2, block3, block4, block5, block6, block7, block8;\n      if (cc_shadowLPNNInfo.y > 0.000001) {\n        block0 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block1 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block2 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block3 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block4 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block5 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block6 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block7 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block8 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      } else {\n        block0 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);\n        block1 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_U)).x);\n        block2 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);\n        block3 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos.y)).x);\n        block4 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x);\n        block5 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos.y)).x);\n        block6 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);\n        block7 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_D)).x);\n        block8 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);\n      }\n      float coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\n      float coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\n      float shadow = 0.0;\n      float resultX = mix(block0, block1, coefX);\n      float resultY = mix(block3, block4, coefX);\n      shadow += mix(resultX , resultY, coefY);\n      resultX = mix(block1, block2, coefX);\n      resultY = mix(block4, block5, coefX);\n      shadow += mix(resultX , resultY, coefY);\n      resultX = mix(block3, block4, coefX);\n      resultY = mix(block6, block7, coefX);\n      shadow += mix(resultX, resultY, coefY);\n      resultX = mix(block4, block5, coefX);\n      resultY = mix(block7, block8, coefX);\n      shadow += mix(resultX, resultY, coefY);\n      return shadow * 0.25;\n    }\n  #endif\nconst float FLT_EPSILON = 0.001;\nconst float FLT_EPSILON2 = 0.01;\nfloat CalculateLineIntegralShared(float FogHeightFalloff, float RayDirectionZ, float RayOriginTerms)\n{\n  float Falloff = max(-127.0, FogHeightFalloff * RayDirectionZ);\n  float LineIntegral = ( 1.0 - exp2(-Falloff) ) / Falloff;\n  float LineIntegralTaylor = log(2.0) - ( 0.5 * (pow(2., log(2.0))) ) * Falloff;\n  return RayOriginTerms * ( abs(Falloff) > FLT_EPSILON2 ? LineIntegral : LineIntegralTaylor );\n}\nvec3 ComputeInscatteringColor(vec3 CameraToReceiver, float CameraToReceiverLength)\n{\n  vec3 Inscattering = FogStruct_ExponentialFogColorParameter.xyz;\n  return Inscattering;\n}\nvec4 GetExponentialHeightFog(vec3 WorldPositionRelativeToCamera, float ExcludeDistance)\n{\n  float MinFogOpacity = FogStruct_ExponentialFogColorParameter.w;\n  float MaxWorldObserverHeight = FogStruct_ExponentialFogParameters.z;\n  vec3 View_WorldCameraOrigin = cc_cameraPos.xyz;\n  vec3 WorldObserverOrigin = vec3(View_WorldCameraOrigin.x, min(View_WorldCameraOrigin.y, MaxWorldObserverHeight), View_WorldCameraOrigin.z);\n  vec3 CameraToReceiver = WorldPositionRelativeToCamera;\n  CameraToReceiver.y += View_WorldCameraOrigin.y - WorldObserverOrigin.y;\n  float CameraToReceiverLengthSqr = dot(CameraToReceiver, CameraToReceiver);\n  float CameraToReceiverLengthInv = rsqrt(CameraToReceiverLengthSqr);\n  float CameraToReceiverLength = CameraToReceiverLengthSqr * CameraToReceiverLengthInv;\n  vec3 CameraToReceiverNormalized = CameraToReceiver * CameraToReceiverLengthInv;\n  float RayOriginTerms = FogStruct_ExponentialFogParameters.x;\n  float RayOriginTermsSecond = FogStruct_ExponentialFogParameters2.x;\n  float RayLength = CameraToReceiverLength;\n  float RayDirectionZ = CameraToReceiver.y;\n  ExcludeDistance = max(ExcludeDistance, FogStruct_ExponentialFogParameters.w);\n  if (ExcludeDistance > 0.)\n  {\n    float ExcludeIntersectionTime = ExcludeDistance * CameraToReceiverLengthInv;\n    float CameraToExclusionIntersectionZ = ExcludeIntersectionTime * CameraToReceiver.y;\n    float ExclusionIntersectionZ = WorldObserverOrigin.y + CameraToExclusionIntersectionZ;\n    float ExclusionIntersectionToReceiverZ = CameraToReceiver.y - CameraToExclusionIntersectionZ;\n    RayLength = (1.0 - ExcludeIntersectionTime) * CameraToReceiverLength;\n    RayDirectionZ = ExclusionIntersectionToReceiverZ;\n    float Exponent = max(-127.0, FogStruct_ExponentialFogParameters.y * (ExclusionIntersectionZ - FogStruct_ExponentialFogParameters3.y));\n    RayOriginTerms = FogStruct_ExponentialFogParameters3.x * exp2(-Exponent);\n    float ExponentSecond = max(-127.0, FogStruct_ExponentialFogParameters2.y * (ExclusionIntersectionZ - FogStruct_ExponentialFogParameters2.w));\n    RayOriginTermsSecond = FogStruct_ExponentialFogParameters2.z * exp2(-ExponentSecond);\n  }\n  float ExponentialHeightLineIntegralShared = CalculateLineIntegralShared(FogStruct_ExponentialFogParameters.y, RayDirectionZ, RayOriginTerms) + CalculateLineIntegralShared(FogStruct_ExponentialFogParameters2.y, RayDirectionZ, RayOriginTermsSecond);\n  float ExponentialHeightLineIntegral = ExponentialHeightLineIntegralShared * RayLength;\n  vec3 InscatteringColor = ComputeInscatteringColor(CameraToReceiver, CameraToReceiverLength);\n  vec3 DirectionalInscattering = vec3(0.);\n  float ExpFogFactor = max(clamp(exp2(-ExponentialHeightLineIntegral), 0.0, 1.0), MinFogOpacity);\n  if (FogStruct_ExponentialFogParameters3.w > 0. && CameraToReceiverLength > FogStruct_ExponentialFogParameters3.w)\n  {\n    ExpFogFactor = 1.;\n    DirectionalInscattering = vec3(0.);\n  }\n    vec3 FogColor = (InscatteringColor) * (1. - ExpFogFactor) + DirectionalInscattering;\n  return vec4(FogColor, ExpFogFactor);\n}\nvec4 CalculateHeightFog(vec3 WorldPositionRelativeToCamera)\n{\n  vec3 WorldPosition = WorldPositionRelativeToCamera;\n  float ExcludeDistance = 0.;\n  vec4 FogInscatteringAndOpacity = GetExponentialHeightFog(WorldPositionRelativeToCamera, ExcludeDistance);\n  return FogInscatteringAndOpacity;\n}\nvec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {\n    return textureLod(tex, coord, lod);\n}\nvec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {\n    return textureLod(tex, coord, lod);\n}\nfloat ComputeReflectionCaptureMipFromRoughness(float Roughness, float CubemapMaxMip)\n{\n  float LevelFrom1x1 = 1.000001 - 1.2 * log2(Roughness);\n  return CubemapMaxMip - 1. - LevelFrom1x1;\n}\nvec3 GetSkySHDiffuseSimple(vec3 Normal)\n{\n  vec4 NormalVector = vec4(Normal.xzy, 1);\n  vec3 Intermediate0;\n  Intermediate0.x = dot(cc_view_SkyIrradianceEnvironmentMap[0], NormalVector);\n  Intermediate0.y = dot(cc_view_SkyIrradianceEnvironmentMap[1], NormalVector);\n  Intermediate0.z = dot(cc_view_SkyIrradianceEnvironmentMap[2], NormalVector);\n  return max(vec3(0.), Intermediate0);\n}\nlayout(set = 0, binding = 9) uniform samplerCube cc_ibl_map_sky;\nvec3 GetSkyLightReflection(vec3 ReflectionVector, float Roughness, out float OutSkyAverageBrightness) {\n  float AbsoluteSpecularMip = ComputeReflectionCaptureMipFromRoughness(Roughness, cc_view_SkyLightParameters.x);\n  vec3 Reflection = decodeCCRGBE(fragTextureLod(cc_ibl_map_sky, ReflectionVector, AbsoluteSpecularMip)).rgb;\n  OutSkyAverageBrightness = cc_view_SkyColor.w * Luminance( cc_view_SkyColor.rgb );\n  return Reflection * cc_view_SkyColor.rgb;\n}\nvec3 posWS2screen (vec3 posWS) {\n  vec4 res = cc_matViewProj * vec4(posWS, 1.);\n  res.xyz /= res.w;\n  res.xyz = res.xyz * 0.5 + 0.5;\n  return res.xyz;\n}\nfloat CalcSpecular(float Roughness, float RoughnessWithClamp, float NoH, vec3 H, vec3 N)\n{\n  return (Roughness*0.25 + 0.25) * GGX_Mobile(RoughnessWithClamp, NoH, H, N);\n}\nFDirectLighting MobileIntegrateBxDF(FPixelMaterialInputs ShadingModelContext, vec3 N, vec3 H, float NoH)\n{\n  FDirectLighting Lighting;\n  Lighting.Specular = ShadingModelContext.SpecularColor * CalcSpecular(ShadingModelContext.Roughness, ShadingModelContext.RoughnessWithClamp, NoH, H, N);\n  Lighting.Diffuse = ShadingModelContext.DiffuseColor;\n  return Lighting;\n}\nvec3 EnvBRDFApprox( vec3 SpecularColor, float Roughness, float NoV )\n{\n  const vec4 c0 = vec4(-1., -0.0275, -0.572, 0.022);\n  const vec4 c1 = vec4(1., 0.0425, 1.04, -0.04);\n  vec4 r = Roughness * c0 + c1;\n  float a004 = min( r.x * r.x, exp2( -9.28 * NoV ) ) * r.x + r.y;\n  vec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n  AB.y *= clamp(50.0 * SpecularColor.g, 0.0, 1.0);\n  return SpecularColor * AB.x + AB.y;\n}\nlayout(set = 0, binding = 10) uniform sampler2D cc_ibl_cluster_InfoTexture;\nlayout(set = 0, binding = 11) uniform sampler2D cc_ibl_cluster_Texture;\nlayout(set = 0, binding = 12) uniform sampler2D cc_ibl_cluster_CubemapAtlas;\nvec2 envMapEquirect(vec3 wcNormal) {\n  float phi = acos(-wcNormal.y);\n  float theta = atan(1. * wcNormal.x, wcNormal.z) + 3.14159265359;\n  vec2 uv = vec2(theta / 6.28318530718, 1. - phi / 3.14159265359);\n  return uv;\n}\nfloat ComputeMixingWeight(float IndirectIrradiance, float AverageBrightness, float Roughness)\n{\n  float MixingAlpha = smoothstep(0., 1., clamp(Roughness * 5.000001 + -0.5, 0.0, 1.0));\n  float MixingWeight = IndirectIrradiance / max(AverageBrightness, .0001);\n  MixingWeight = min(MixingWeight, 10000.000001);\n  return mix(1.0, MixingWeight, MixingAlpha);\n}\nvec3 GetLookupVectorForSphereCapture(vec3 ReflectionVector, vec3 WorldPosition, vec4 SphereCapturePositionAndRadius, float NormalizedDistanceToCapture, vec3 LocalCaptureOffset, inout float DistanceAlpha)\n{\n  vec3 ProjectedCaptureVector = ReflectionVector;\n  float ProjectionSphereRadius = SphereCapturePositionAndRadius.w;\n  float SphereRadiusSquared = ProjectionSphereRadius * ProjectionSphereRadius;\n  vec3 LocalPosition = WorldPosition - SphereCapturePositionAndRadius.xyz;\n  float LocalPositionSqr = dot(LocalPosition, LocalPosition);\n  vec3 QuadraticCoef;\n  QuadraticCoef.x = 1.;\n  QuadraticCoef.y = dot(ReflectionVector, LocalPosition);\n  QuadraticCoef.z = LocalPositionSqr - SphereRadiusSquared;\n  float Determinant = QuadraticCoef.y * QuadraticCoef.y - QuadraticCoef.z;\n  if (Determinant >= 0.)\n  {\n    float FarIntersection = sqrt(Determinant) - QuadraticCoef.y;\n    vec3 LocalIntersectionPosition = LocalPosition + FarIntersection * ReflectionVector;\n    ProjectedCaptureVector = normalize(LocalIntersectionPosition - LocalCaptureOffset);\n    float x = clamp(2.5 * NormalizedDistanceToCapture - 1.5, 0.0, 1.0);\n    DistanceAlpha = 1. - x*x*(3. - 2.*x);\n  }\n  return ProjectedCaptureVector;\n}\nvoid EvaluateClusterIBL(float iblIndex, FMaterialPixelParameters MaterialParameters, float mip, float IndirectIrradiance, inout vec4 ImageBasedReflections, inout vec2 CompositedAverageBrightness) {\n  float iblV = (iblIndex + 0.5) * cc_ibl_cluster_InfoTextureInvSize.y;\n  vec4 posRange = texture(cc_ibl_cluster_InfoTexture, vec2(0.5 * cc_ibl_cluster_InfoTextureInvSize.x, iblV));\n  float iblDistance = length(MaterialParameters.AbsoluteWorldPosition - posRange.xyz);\n  float DistanceAlpha = 0.;\n  vec3 ProjectedCaptureVector = MaterialParameters.ReflectionVector;\n  if (iblDistance < posRange.w) {\n    float NormalizedDistanceToCapture = clamp(iblDistance / posRange.w, 0.0, 1.0);\n    ProjectedCaptureVector = GetLookupVectorForSphereCapture(ProjectedCaptureVector, MaterialParameters.AbsoluteWorldPosition, posRange, NormalizedDistanceToCapture, vec3(0.0), DistanceAlpha);\n  }\n  vec4 data3 = texture(cc_ibl_cluster_InfoTexture, vec2(2.5 * cc_ibl_cluster_InfoTextureInvSize.x, iblV));\n  float AverageBrightness = data3.x;\n  float brightness = data3.y;\n  vec2 uv = envMapEquirect(ProjectedCaptureVector);\n  vec4 uvMapping = texture(cc_ibl_cluster_InfoTexture, vec2(1.5 * cc_ibl_cluster_InfoTextureInvSize.x, iblV));\n  vec2 scaleUV = vec2(uvMapping.z, uvMapping.w * 0.5);\n  vec2 rgbUV = uvMapping.xy + scaleUV * uv;\n  vec2 aUV = uvMapping.xy + scaleUV * vec2(uv.x, uv.y + 1.);\n  vec4 SpecularIBL = decodeCCRGBE(fragTextureLod(cc_ibl_cluster_CubemapAtlas, rgbUV, mip));\n  float pixelBrightness = decodeCCRGBE(fragTextureLod(cc_ibl_cluster_CubemapAtlas, aUV, mip)).r;\n  ImageBasedReflections.rgb += SpecularIBL.rgb * brightness * DistanceAlpha * ImageBasedReflections.a;\n  ImageBasedReflections.a *= 1. - (pixelBrightness * DistanceAlpha);\n  CompositedAverageBrightness.x += AverageBrightness * DistanceAlpha * CompositedAverageBrightness.y;\n  CompositedAverageBrightness.y *= 1. - DistanceAlpha;\n}\nvoid EvalCluster (float clusterU, float clusterV, in FMaterialPixelParameters MaterialParameters, float mip, float IndirectIrradiance, inout vec4 ImageBasedReflections, vec2 CompositedAverageBrightness) {\n  #if CC_IBL_MaxPixelsPerCell\n    int calcedIblCount = 0;\n    for (float pixelIndex = 0.5; pixelIndex < float(CC_IBL_MaxPixelsPerCell); pixelIndex++) {\n      vec4 iblIndices = texture(cc_ibl_cluster_Texture, vec2(cc_ibl_cluster_TextureSize.y * (clusterU + pixelIndex), clusterV));\n      vec4 indices = iblIndices * 255.0;\n      for (int e = 0; e < 4; e++) {\n        float iblIndex = indices[e];\n        if (iblIndex <= 0.0)\n          break;\n          EvaluateClusterIBL(iblIndex, MaterialParameters, mip, IndirectIrradiance, ImageBasedReflections, CompositedAverageBrightness);\n      }\n    }\n  #endif\n}\nfloat GetSpecularOcclusion(float NoV, float RoughnessSq, float AO)\n{\n  return clamp(pow( NoV + AO, RoughnessSq ) - 1. + AO, 0.0, 1.0);\n}\nvec3 GetOffSpecularPeakReflectionDir(vec3 Normal, vec3 ReflectionVector, float Roughness)\n{\n  float a = Square(Roughness);\n  return mix( Normal, ReflectionVector, (1. - a) * ( sqrt(1. - a) + a ) );\n}\nlayout(set = 0, binding = 15) uniform sampler2D cc_planar_reflection_Texture;\nvec4 GetPlanarReflection (FMaterialPixelParameters MaterialParameters, GlobalView View) {\n  vec4 planarReflection = vec4(0.);\n  float DistanceFade = 1. - clamp(abs(MaterialParameters.AbsoluteWorldPosition.y) / 0.01, 0.0, 1.0);\n  if (DistanceFade > 0.) {\n    vec3 CameraToPixel = -MaterialParameters.CameraVector;\n    vec3 MirroredCameraVector = reflect(CameraToPixel, -cc_view_pr_reflectionPlane.xyz);\n    vec3 MirroredNormal = (cc_view_inverse_transpose_mirror * vec4(MaterialParameters.WorldNormal, 0.)).xyz;\n    vec3 MirroredReflectionVectorOffNormal = reflect(MirroredCameraVector, MirroredNormal);\n    vec3 VirtualReflectionSpherePosition = MaterialParameters.AbsoluteWorldPosition + MirroredReflectionVectorOffNormal * cc_view_pr_parameters.z;\n    vec2 screenUV = posWS2screen(VirtualReflectionSpherePosition.rgb).xy;\n    planarReflection = texture(cc_planar_reflection_Texture, screenUV);\n    planarReflection.a *= DistanceFade;\n    planarReflection.rgb /= View.PreExposure;\n  }\n  return planarReflection;\n}\nvec3 GetImageBasedReflectionLighting(FMaterialPixelParameters MaterialParameters, FPixelMaterialInputs ShadingModelContext, float IndirectIrradiance, GlobalView View) {\n  float Roughness = ShadingModelContext.Roughness;\n  float RoughnessSq = Roughness * Roughness;\n  float NoV = max(dot(MaterialParameters.WorldNormal, MaterialParameters.CameraVector), 0.);\n  float AO = ShadingModelContext.AmbientOcclusion;\n  float SpecularOcclusion = GetSpecularOcclusion(NoV, RoughnessSq, AO);\n  vec2 CompositedAverageBrightness = vec2(0.0, 1.0);\n  vec4 ImageBasedReflections = vec4(vec3(0.), SpecularOcclusion);\n  vec3 ReflectionVector = 2. * dot( MaterialParameters.CameraVector, MaterialParameters.WorldNormal ) * MaterialParameters.WorldNormal - MaterialParameters.CameraVector;\n  ReflectionVector = GetOffSpecularPeakReflectionDir(MaterialParameters.WorldNormal, ReflectionVector, Roughness);\n  MaterialParameters.ReflectionVector = ReflectionVector;\n  if (ImageBasedReflections.a > 0.) {\n    vec4 planarReflection = GetPlanarReflection(MaterialParameters, View);\n    ImageBasedReflections.rgb += planarReflection.rgb * ImageBasedReflections.a;\n    ImageBasedReflections.a -= planarReflection.a;\n  }\n  vec3 cellCoords = floor((MaterialParameters.AbsoluteWorldPosition - cc_ibl_cluster_BoundsMin.xyz) * cc_ibl_cluster_CellsCountByBoundsSizeAndPixelsPerCell.xyz);\n  if (ImageBasedReflections.a <= 0. || (cellCoords.x < 0.) || (cellCoords.y < 0.) || (cellCoords.z < 0.) ||\n      (cellCoords.x > cc_ibl_cluster_CellsMax.x) || (cellCoords.y > cc_ibl_cluster_CellsMax.y) || (cellCoords.z > cc_ibl_cluster_CellsMax.z)) {\n  }\n  else {\n    float mip = ComputeReflectionCaptureMipFromRoughness(Roughness, 7.000001);\n    float cellIndex = dot(cc_ibl_cluster_CellsDot.xyz, cellCoords);\n    float clusterV = floor(cellIndex * cc_ibl_cluster_TextureSize.y);\n    float clusterU = floor(cellIndex - (clusterV * cc_ibl_cluster_TextureSize.x));\n    clusterV = (clusterV + 0.5) * cc_ibl_cluster_TextureSize.z;\n    EvalCluster(clusterU, clusterV, MaterialParameters, mip, IndirectIrradiance, ImageBasedReflections, CompositedAverageBrightness);\n  }\n  ImageBasedReflections.rgb *= View.IndirectLightingColorScale;\n  CompositedAverageBrightness.x *= Luminance( View.IndirectLightingColorScale );\n  if (ImageBasedReflections.a > 0.) {\n    float SkyAverageBrightness = 1.;\n    vec3 SkyLighting = GetSkyLightReflection(ReflectionVector, Roughness, SkyAverageBrightness);\n    ImageBasedReflections.rgb += ImageBasedReflections.a * SkyLighting;\n    CompositedAverageBrightness.x += SkyAverageBrightness * CompositedAverageBrightness.y;\n      ImageBasedReflections.rgb *= ComputeMixingWeight(IndirectIrradiance, CompositedAverageBrightness.x, Roughness);\n  }\n    vec3 brdf = EnvBRDFApprox(ShadingModelContext.SpecularColor, Roughness, NoV);\n  ImageBasedReflections.rgb *= brdf;\n  return ImageBasedReflections.rgb;\n}\n#if (CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD)\n    layout(location = 13) in vec3 v_luv;\n    layout(set = 2, binding = 10) uniform sampler2D cc_lightingMap;\n    #if USE_INSTANCING\n      layout(location = 9) in vec4 v_lightingMapAdds0;\n      layout(location = 10) in vec4 v_lightingMapAdds1;\n      layout(location = 11) in vec4 v_lightingMapScales0;\n      layout(location = 12) in vec4 v_lightingMapScales1;\n      void getLightingMapVectors (out vec4 lightingMapAdds0, out vec4 lightingMapAdds1, out vec4 lightingMapScales0, out vec4 lightingMapScales1) {\n        lightingMapAdds0 = v_lightingMapAdds0;\n        lightingMapAdds1 = v_lightingMapAdds1;\n        lightingMapScales0 = v_lightingMapScales0;\n        lightingMapScales1 = v_lightingMapScales1;\n      }\n    #endif\n    vec4 GetLightMapColorLQ( vec2 LightmapUV0, vec2 LightmapUV1, vec3 WorldNormal ) {\n      vec4 lightingMapAdds0 = vec4(0.);\n      vec4 lightingMapAdds1 = vec4(0.);\n      vec4 lightingMapScales0 = vec4(1.);\n      vec4 lightingMapScales1 = vec4(1.);\n      #if USE_INSTANCING\n        getLightingMapVectors(lightingMapAdds0, lightingMapAdds1, lightingMapScales0, lightingMapScales1);\n      #endif\n      vec4 Lightmap0 = texture( cc_lightingMap, LightmapUV0 );\n      vec3 LogRGB = Lightmap0.rgb * lightingMapScales0.xyz + lightingMapAdds0.xyz;\n      float LogL = Luminance( LogRGB );\n      const float LogBlackPoint = 0.00390625;\n      float L = exp2( LogL * 16. - 8. ) - LogBlackPoint;\n      float Directionality = 0.6;\n      float Luma = L * Directionality;\n      vec3 Color = LogRGB * (Luma / LogL);\n      return vec4( Color, Luma );\n    }\n#endif\nvec4 GetLightMapColor (vec3 worldNormal) {\n  vec4 lightmapColor =  vec4(vec3(0.), 0.);\n    #if (CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD)\n      vec2 LightmapUV0 = v_luv.xy * vec2( 1., 0.5 );\n      vec2 LightmapUV1 = LightmapUV0 + vec2( 0., 0.5 );\n        lightmapColor = GetLightMapColorLQ(LightmapUV0, LightmapUV1, worldNormal);\n    #endif\n  return lightmapColor;\n}\nvec4 lightingBase (FPixelMaterialInputs ShadingModelContext, FMaterialPixelParameters MaterialParameters, GlobalView View, vec4 shadowPos) {\n  vec3 Color = vec3(0);\n  #if CC_Lighting_Heavily\n    Color += vec3(0.1, 0, 0);\n  #else\n    vec3 direction = normalize(-cc_mainLitDir.xyz);\n    vec3 lightColor = cc_mainLitColor.rgb * cc_mainLitColor.w;\n    lightColor /= 3.14159265359;\n    float NoL = max(0., dot(MaterialParameters.WorldNormal, direction));\n    vec3 H = normalize(MaterialParameters.CameraVector + direction);\n    float NoH = max(0., dot(MaterialParameters.WorldNormal, H));\n    float Shadow = 1.;\n    #if CC_RECEIVE_SHADOW\n        {\n          vec4 pos = ApplyShadowDepthBias_FaceNormal(shadowPos, MaterialParameters.WorldNormal);\n          float pcf = cc_shadowWHPBInfo.z;\n          if (pcf > 1.9) Shadow = CCGetShadowFactorSoft2X(pos);\n          else if (pcf > 0.9) Shadow = CCGetShadowFactorSoft(pos);\n          else Shadow = CCGetShadowFactorHard(pos);\n          Shadow = mix(Shadow, 1.0, cc_shadowNFLSInfo.w);\n        }\n    #endif\n    FDirectLighting Lighting = MobileIntegrateBxDF(ShadingModelContext, MaterialParameters.WorldNormal, H, NoH);\n    Color += (Shadow * NoL) * lightColor * (Lighting.Diffuse + Lighting.Specular );\n    float IndirectIrradiance = MaterialParameters.IndirectIrradiance;\n    #if CC_ENABLE_IBL\n      vec3 SpecularIBL = GetImageBasedReflectionLighting(MaterialParameters, ShadingModelContext, IndirectIrradiance, View);\n      Color += SpecularIBL;\n    #endif\n    Color += ShadingModelContext.EmissiveColor;\n  #endif\n  return vec4(Color, ShadingModelContext.Opacity);\n}\nvec3 transmission (vec3 N, vec3 V, vec3 L, float Falloff, vec3 SubsurfaceColor) {\n    float Wrap = 0.5;\n    float WrapAddOne = ( 1. + Wrap );\n    float WrapNoL = clamp(( -dot(N, L) + Wrap ) / ( WrapAddOne * WrapAddOne ), 0.0, 1.0);\n    float VoL = dot(V, L);\n    float Scatter = D_GGX( 0.6*0.6, clamp(-VoL, 0.0, 1.0) );\n    return SubsurfaceColor * WrapNoL * Scatter * cc_mainLitColor.rgb * cc_mainLitColor.w;\n}\nvoid lightingPerObject (inout FMaterialPixelParameters Parameters, inout FPixelMaterialInputs PixelMaterialInputs) {\n    PixelMaterialInputs.EmissiveColor += transmission(\n      Parameters.WorldNormal,\n      Parameters.CameraVector,\n      normalize(-cc_mainLitDir.xyz), 1.,\n      PixelMaterialInputs.Subsurface\n    );\n  #if !(CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD)\n    vec3 DiffuseLookup = GetSkySHDiffuseSimple(Parameters.WorldNormal) * cc_view_SkyColor.rgb;\n    vec3 DiffuseColor = PixelMaterialInputs.BaseColor - PixelMaterialInputs.BaseColor * PixelMaterialInputs.Metallic;\n    PixelMaterialInputs.EmissiveColor += DiffuseLookup * PixelMaterialInputs.AmbientOcclusion * DiffuseColor;\n    if (PixelMaterialInputs.TwoSidedSign < 0.) {\n      vec3 BackfaceDiffuseLookup = GetSkySHDiffuseSimple(Parameters.WorldNormal * PixelMaterialInputs.TwoSidedSign);\n      PixelMaterialInputs.EmissiveColor += BackfaceDiffuseLookup * PixelMaterialInputs.Subsurface;\n    }\n  #endif\n}\n#if CC_FORWARD_ADD\n#if CC_PIPELINE_TYPE == 0\n# define LIGHTS_PER_PASS 1\n#else\n# define LIGHTS_PER_PASS 10\n#endif\n#if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\nlayout(set = 2, binding = 1) uniform CCForwardLight {\n  highp vec4 cc_lightPos[LIGHTS_PER_PASS];\n  vec4 cc_lightColor[LIGHTS_PER_PASS];\n  vec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];\n  vec4 cc_lightDir[LIGHTS_PER_PASS];\n};\n#endif\n#endif\nfloat SpotAttenuationMask(vec3 L, vec3 SpotDirection, vec2 SpotAngles)\n{\n  return clamp((dot(L, -SpotDirection) - SpotAngles.x) * SpotAngles.y, 0.0, 1.0);\n}\nfloat SpotAttenuation(vec3 L, vec3 SpotDirection, vec2 SpotAngles)\n{\n  float ConeAngleFalloff = Square(SpotAttenuationMask(L, SpotDirection, SpotAngles));\n  return ConeAngleFalloff;\n}\nvoid lightingAddPerLight(\n  in FPixelMaterialInputs ShadingModelContext, in FMaterialPixelParameters MaterialParameters,\n  vec3 pos, bool isSpotLight,\n  vec3 lightColor, float intensity,\n  float range, float spotAngle,\n  vec3 dir,\n  vec4 shadowPos,\n  inout vec3 outColor) {\n  vec3 toLight = pos - MaterialParameters.AbsoluteWorldPosition;\n  float distanceSqr = dot(toLight, toLight);\n  vec3 L = toLight * rsqrt(distanceSqr);\n  vec3 PointH = normalize(MaterialParameters.CameraVector + L);\n  float PointNoL = max(0., dot(MaterialParameters.WorldNormal, L));\n  float PointNoH = max(0., dot(MaterialParameters.WorldNormal, PointH));\n  float Attenuation;\n  {\n    Attenuation = 1. / ( distanceSqr + 0.01 );\n    float InvRadius = 1.0 / max(range, 0.01);\n    float LightRadiusMask = Square(clamp(1. - Square(distanceSqr * (InvRadius * InvRadius)), 0.0, 1.0));\n    Attenuation *= LightRadiusMask;\n  }\n  if (isSpotLight) {\n    vec3 SL = normalize(toLight);\n    float cosInner = 1.;\n    float cosOuter = spotAngle;\n    float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\n    vec2 SpotAngles = vec2(cosOuter, litAngleScale);\n    Attenuation *= SpotAttenuation(L, dir, SpotAngles);\n    float shadow = 1.;\n    #if CC_RECEIVE_SHADOW\n        {\n          vec4 pos = ApplyShadowDepthBias_FaceNormal(shadowPos, MaterialParameters.WorldNormal);\n          float pcf = cc_shadowWHPBInfo.z;\n          if (pcf > 1.9) shadow = CCGetShadowFactorSoft2X(pos);\n          else if (pcf > 0.9) shadow = CCGetShadowFactorSoft(pos);\n          else shadow = CCGetShadowFactorHard(pos);\n          shadow = mix(shadow, 1.0, cc_shadowNFLSInfo.w);\n        }\n    #endif\n    lightColor *= shadow;\n  }\n  FDirectLighting Lighting = MobileIntegrateBxDF(ShadingModelContext, MaterialParameters.WorldNormal, PointH, PointNoH);\n  outColor += min(vec3(65000.0), (Attenuation * PointNoL) * lightColor * intensity / 3.14159265359 * (Lighting.Diffuse + Lighting.Specular));\n}\nlayout(set = 0, binding = 13) uniform sampler2D cc_light_cluster_InfoTexture;\nlayout(set = 0, binding = 14) uniform sampler2D cc_light_cluster_Texture;\nvoid lightingCluster(float clusterIndex, in FPixelMaterialInputs ShadingModelContext, in FMaterialPixelParameters MaterialParameters, vec4 shadowPos, inout vec3 outColor) {\n  #if CC_Lighting_Heavily\n    outColor += vec3(0.1, 0, 0);\n  #else\n    float iblV = (clusterIndex + 0.5) * cc_light_cluster_InfoTextureInvSize.y;\n    vec4 lightPos = texture(cc_light_cluster_InfoTexture, vec2(0.5 * cc_light_cluster_InfoTextureInvSize.x, iblV));\n    vec4 lightColor = texture(cc_light_cluster_InfoTexture, vec2(1.5 * cc_light_cluster_InfoTextureInvSize.x, iblV));\n    vec4 lightSizeRangeAngle = texture(cc_light_cluster_InfoTexture, vec2(2.5 * cc_light_cluster_InfoTextureInvSize.x, iblV));\n    vec4 lightDir = texture(cc_light_cluster_InfoTexture, vec2(3.5 * cc_light_cluster_InfoTextureInvSize.x, iblV));\n    lightingAddPerLight(\n      ShadingModelContext, MaterialParameters,\n      lightPos.xyz, lightPos.w > 0.0,\n      lightColor.rgb, lightColor.w,\n      lightSizeRangeAngle.y, lightSizeRangeAngle.z,\n      lightDir.xyz,\n      shadowPos,\n      outColor\n    );\n  #endif\n}\n#if CC_ENABLE_CLUSTERED_LIGHT_CULLING && CC_ENABLE_Builtin_CLUSTERED_LIGHT_CULLING\n  float SmoothDistAtt (float distSqr, float invSqrAttRadius) {\n    float factor = distSqr * invSqrAttRadius;\n    float smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\n    return smoothFactor * smoothFactor;\n  }\n  float GetDistAtt (float distSqr, float invSqrAttRadius) {\n    float attenuation = 1.0 / max(distSqr, 0.01*0.01);\n    attenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\n    return attenuation;\n  }\n  float GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\n    float cd = dot(litDir, L);\n    float attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\n    return (attenuation * attenuation);\n  }\n  #if CC_USE_IBL\n    layout(set = 0, binding = 4) uniform samplerCube cc_environment;\n    #if CC_USE_DIFFUSEMAP\n      layout(set = 0, binding = 6) uniform samplerCube cc_diffuseMap;\n    #endif\n  #endif\n  float GGXMobile (float roughness, float NoH, vec3 H, vec3 N) {\n    vec3 NxH = cross(N, H);\n    float OneMinusNoHSqr = dot(NxH, NxH);\n    float a = roughness * roughness;\n    float n = NoH * a;\n    float p = a / (OneMinusNoHSqr + n * n);\n    return p * p;\n  }\n  float CalcSpecular (float roughness, float NoH, vec3 H, vec3 N) {\n    return (roughness * 0.25 + 0.25) * GGXMobile(roughness, NoH, H, N);\n  }\n  vec3 BRDFApprox (vec3 specular, float roughness, float NoV) {\n    const vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);\n    const vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);\n    vec4 r = roughness * c0 + c1;\n    float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\n    vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\n    AB.y *= clamp(50.0 * specular.g, 0.0, 1.0);\n    return specular * AB.x + AB.y;\n  }\n  #if USE_REFLECTION_DENOISE\n  #endif\n  struct StandardSurface {\n    vec4 albedo;\n    vec3 position;\n    vec3 normal;\n    vec3 emissive;\n    vec3 lightmap;\n    float lightmap_test;\n    float roughness;\n    float metallic;\n    float occlusion;\n  };\n  layout(set = 1, binding = 0) readonly buffer b_ccLightsBuffer { vec4 b_ccLights[]; };\n  layout(set = 1, binding = 1) readonly buffer b_clusterLightIndicesBuffer { uint b_clusterLightIndices[]; };\n  layout(set = 1, binding = 2) readonly buffer b_clusterLightGridBuffer { uvec4 b_clusterLightGrid[]; };\n  struct CCLight\n  {\n    vec4 cc_lightPos;\n    vec4 cc_lightColor;\n    vec4 cc_lightSizeRangeAngle;\n    vec4 cc_lightDir;\n  };\n  struct Cluster\n  {\n    vec3 minBounds;\n    vec3 maxBounds;\n  };\n  struct LightGrid\n  {\n    uint offset;\n    uint ccLights;\n  };\n  CCLight getCCLight(uint i)\n  {\n    CCLight light;\n    light.cc_lightPos = b_ccLights[4u * i + 0u];\n    light.cc_lightColor = b_ccLights[4u * i + 1u];\n    light.cc_lightSizeRangeAngle = b_ccLights[4u * i + 2u];\n    light.cc_lightDir = b_ccLights[4u * i + 3u];\n    return light;\n  }\n  LightGrid getLightGrid(uint cluster)\n  {\n    uvec4 gridvec = b_clusterLightGrid[cluster];\n    LightGrid grid;\n    grid.offset = gridvec.x;\n    grid.ccLights = gridvec.y;\n    return grid;\n  }\n  uint getGridLightIndex(uint start, uint offset)\n  {\n    return b_clusterLightIndices[start + offset];\n  }\n  uint getClusterZIndex(vec4 worldPos)\n  {\n    float scale = float(24) / log(cc_nearFar.y / cc_nearFar.x);\n    float bias = -(float(24) * log(cc_nearFar.x) / log(cc_nearFar.y / cc_nearFar.x));\n    float eyeDepth = -(cc_matView * worldPos).z;\n    uint zIndex = uint(max(log(eyeDepth) * scale + bias, 0.0));\n    return zIndex;\n  }\n  uint getClusterIndex(vec4 fragCoord, vec4 worldPos)\n  {\n    uint zIndex = getClusterZIndex(worldPos);\n    float clusterSizeX = ceil(cc_nativeSize.x / float(16));\n    float clusterSizeY = ceil(cc_nativeSize.y / float(8));\n    uvec3 indices = uvec3(uvec2(fragCoord.xy / vec2(clusterSizeX, clusterSizeY)), zIndex);\n    uint cluster = (16u * 8u) * indices.z + 16u * indices.y + indices.x;\n    return cluster;\n  }\n  vec4 CCClusterShadingAdditive (StandardSurface s, vec4 shadowPos) {\n    vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n    vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n    vec3 diffuseContrib = diffuse / 3.14159265359;\n    vec3 N = normalize(s.normal);\n    vec3 V = normalize(cc_cameraPos.xyz - s.position);\n    float NV = max(abs(dot(N, V)), 0.001);\n    specular = BRDFApprox(specular, s.roughness, NV);\n    vec3 finalColor = vec3(0.0);\n    uint cluster = getClusterIndex(gl_FragCoord, vec4(s.position, 1.0));\n    LightGrid grid = getLightGrid(cluster);\n    uint numLights = grid.ccLights;\n    for (uint i = 0u; i < 100u; i++) {\n      if (i >= numLights) break;\n      uint lightIndex = getGridLightIndex(grid.offset, i);\n      CCLight light = getCCLight(lightIndex);\n      vec3 SLU = light.cc_lightPos.xyz - s.position;\n      vec3 SL = normalize(SLU);\n      vec3 SH = normalize(SL + V);\n      float SNL = max(dot(N, SL), 0.001);\n      float SNH = max(dot(N, SH), 0.0);\n      float distSqr = dot(SLU, SLU);\n      float litRadius = light.cc_lightSizeRangeAngle.x;\n      float litRadiusSqr = litRadius * litRadius;\n      float illum = 3.14159265359 * (litRadiusSqr / max(litRadiusSqr , distSqr));\n      float attRadiusSqrInv = 1.0 / max(light.cc_lightSizeRangeAngle.y, 0.01);\n      attRadiusSqrInv *= attRadiusSqrInv;\n      float att = GetDistAtt(distSqr, attRadiusSqrInv);\n      vec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\n      if (light.cc_lightPos.w > 0.0) {\n        float cosInner = max(dot(-light.cc_lightDir.xyz, SL), 0.01);\n        float cosOuter = light.cc_lightSizeRangeAngle.z;\n        float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\n        float litAngleOffset = -cosOuter * litAngleScale;\n        att *= GetAngleAtt(SL, -light.cc_lightDir.xyz, litAngleScale, litAngleOffset);\n      }\n      vec3 lightColor = light.cc_lightColor.rgb;\n      float shadow = 1.0;\n      #if CC_RECEIVE_SHADOW\n        if (light.cc_lightPos.w > 0.0) {\n            {\n              float pcf = cc_shadowWHPBInfo.z;\n              if (pcf > 1.9) shadow = CCGetSpotLightShadowFactorSoft2X(shadowPos, s.position);\n              else if (pcf > 0.9) shadow = CCGetSpotLightShadowFactorSoft(shadowPos, s.position);\n              else shadow = CCGetSpotLightShadowFactorHard(shadowPos, s.position);\n            }\n        }\n      #endif\n      lightColor *= shadow;\n      finalColor += SNL * lightColor * light.cc_lightColor.w * illum * att * (diffuseContrib + lspec);\n    }\n    return vec4(finalColor, 0.0);\n  }\n#endif\nvec4 lightingAdd (in FPixelMaterialInputs ShadingModelContext, in FMaterialPixelParameters MaterialParameters, vec4 shadowPos) {\n  vec3 color = vec3(0.);\n  #if CC_ENABLE_CLUSTERED_LIGHT_CULLING && CC_ENABLE_Builtin_CLUSTERED_LIGHT_CULLING\n    StandardSurface s;\n    s.albedo.xyz = ShadingModelContext.BaseColor;\n    s.albedo.w = ShadingModelContext.Opacity;\n    s.metallic = ShadingModelContext.Metallic;\n    s.roughness = ShadingModelContext.Roughness;\n    s.normal = MaterialParameters.WorldNormal;\n    s.position = MaterialParameters.AbsoluteWorldPosition;\n    color = CCClusterShadingAdditive(s, shadowPos).rgb;\n  #else\n  vec3 cellCoords = floor((MaterialParameters.AbsoluteWorldPosition - cc_light_cluster_BoundsMin.xyz) * cc_light_cluster_CellsCountByBoundsSizeAndPixelsPerCell.xyz);\n  if ((cellCoords.x < 0.) || (cellCoords.y < 0.) || (cellCoords.z < 0.) ||\n      (cellCoords.x > cc_light_cluster_CellsMax.x) ||\n      (cellCoords.y > cc_light_cluster_CellsMax.y) ||\n      (cellCoords.z > cc_light_cluster_CellsMax.z)) {\n  }\n  else {\n    float cellIndex = dot(cc_light_cluster_CellsDot.xyz, cellCoords);\n    float clusterV = floor(cellIndex * cc_light_cluster_TextureSize.y);\n    float clusterU = cellIndex - (clusterV * cc_light_cluster_TextureSize.x);\n    clusterV = (clusterV + 0.5) * cc_light_cluster_TextureSize.z;\n    #if CC_LIGHT_MaxPixelsPerCell\n    for (float cellIndex = 0.5; cellIndex < float(CC_LIGHT_MaxPixelsPerCell); cellIndex++) {\n      vec4 lightIndices = texture(cc_light_cluster_Texture, vec2(cc_light_cluster_TextureSize.y * (clusterU + cellIndex), clusterV));\n      vec4 indices = lightIndices * 255.0;\n      for (int e = 0; e < 4; e++) {\n        if (indices[e] <= 0.0) {\n          break;\n        }\n        lightingCluster(indices[e], ShadingModelContext, MaterialParameters, shadowPos, color);\n      }\n      if (cellIndex > cc_light_cluster_CellsCountByBoundsSizeAndPixelsPerCell.w) {\n        break;\n      }\n    }\n    #endif\n  }\n  #endif\n  return vec4(color, ShadingModelContext.Opacity);\n}\nvoid InitShadingModelContext(inout FPixelMaterialInputs ShadingModelContext, FMaterialPixelParameters MaterialParameters) {\n  ShadingModelContext.RoughnessWithClamp = max(0.015625, ShadingModelContext.Roughness);\n  float NoV = max(dot(MaterialParameters.WorldNormal, MaterialParameters.CameraVector), 0.);\n  float DielectricSpecular = 0.08 * ShadingModelContext.Specular;\n  ShadingModelContext.DiffuseColor = ShadingModelContext.BaseColor - ShadingModelContext.BaseColor * ShadingModelContext.Metallic;\n  ShadingModelContext.SpecularColor = mix(0.08 * vec3(ShadingModelContext.Specular), ShadingModelContext.BaseColor, ShadingModelContext.Metallic);\n}\nvec4 lighting (FPixelMaterialInputs ShadingModelContext, FMaterialPixelParameters MaterialParameters, GlobalView View, vec4 shadowPos) {\n  vec4 color = vec4(vec3(0.), 1.);\n    #if CC_ENABLE_LIGHTING_BASE\n      color = lightingBase(ShadingModelContext, MaterialParameters, View, shadowPos);\n    #endif\n    #if CC_ENABLE_LIGHTING_ADD && (0 || 1)\n      color += lightingAdd(ShadingModelContext, MaterialParameters, shadowPos);\n    #endif\n  color *= ShadingModelContext.AmbientOcclusion;\n  return color;\n}\n#if CC_FORWARD_ADD\n#endif\nvec4 forward () {\n  FMaterialPixelParameters Parameters;\n  FPixelMaterialInputs PixelMaterialInputs;\n  GlobalView View;\n  surf(PixelMaterialInputs, Parameters, View);\n  lightingPerObject(Parameters, PixelMaterialInputs);\n  InitShadingModelContext(PixelMaterialInputs, Parameters);\n  vec4 color = lighting(PixelMaterialInputs, Parameters, View, v_shadowPos);\n  vec4 fogColor = CalculateHeightFog(Parameters.AbsoluteWorldPosition.xyz - cc_cameraPos.xyz);\n  color.rgb = color.rgb * fogColor.a + fogColor.rgb;\n  color.rgb *= View.PreExposure;\n  return color;\n}\nvoid deferred (out vec4 color0, out vec4 color1, out vec4 color2, out vec4 color3) {\n  FMaterialPixelParameters Parameters;\n  FPixelMaterialInputs PixelMaterialInputs;\n  GlobalView View;\n  surf(PixelMaterialInputs, Parameters, View);\n  lightingPerObject(Parameters, PixelMaterialInputs);\n  PixelMaterialInputs.DiffuseColor = max(PixelMaterialInputs.BaseColor - PixelMaterialInputs.BaseColor * PixelMaterialInputs.Metallic, 0.);\n  color0 = vec4(PixelMaterialInputs.BaseColor, PixelMaterialInputs.Opacity);\n  color1 = vec4(Parameters.AbsoluteWorldPosition, PixelMaterialInputs.Roughness);\n  color2 = vec4(Parameters.WorldNormal, PixelMaterialInputs.Metallic);\n  vec3 color = vec3(0.);\n  vec4 lightmapColor = GetLightMapColor(Parameters.WorldNormal);\n  Parameters.IndirectIrradiance += lightmapColor.a;\n  color += lightmapColor.xyz * PixelMaterialInputs.DiffuseColor * View.IndirectLightingColorScale;\n  color += PixelMaterialInputs.EmissiveColor;\n  color3 = vec4(color, Parameters.IndirectIrradiance * PixelMaterialInputs.AmbientOcclusion);\n}\n#if CC_TRANSPARENT || (CC_PIPELINE_TYPE == 0)\n  layout(location = 0) out vec4 fragColor0;\n  void main () {\n    fragColor0 = forward();\n  }\n#elif CC_PIPELINE_TYPE == 1\n  layout(location = 0) out vec4 fragColor0;\n  layout(location = 1) out vec4 fragColor1;\n  layout(location = 2) out vec4 fragColor2;\n  layout(location = 3) out vec4 fragColor3;\n  void main () {\n    deferred(fragColor0, fragColor1, fragColor2, fragColor3);\n  }\n#endif"},"glsl3":{"vert":"\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\nin vec4 a_tangent;\n#if CC_USE_MORPH\n    in float a_vertexId;\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n  layout(std140) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n  };\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n        ivec2 texSize = textureSize(tex, 0);\n        return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture(tex, x)),\n        decode32(texture(tex, y)),\n        decode32(texture(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout StandardVertInput attr) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    attr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    attr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    attr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n    in vec4 a_joints;\n  in vec4 a_weights;\n  #if CC_USE_BAKED_ANIMATION\n    #if USE_INSTANCING\n      in highp vec4 a_jointAnimInfo;\n    #endif\n    layout(std140) uniform CCSkinningTexture {\n      highp vec4 cc_jointTextureInfo;\n    };\n    layout(std140) uniform CCSkinningAnimation {\n      highp vec4 cc_jointAnimInfo;\n    };\n    uniform highp sampler2D cc_jointTexture;\n      #else\n    layout(std140) uniform CCSkinning {\n      highp vec4 cc_joints[30 * 3];\n    };\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout StandardVertInput attr) {\n    mat4 m = skinMatrix();\n    attr.position = m * attr.position;\n    attr.normal = (m * vec4(attr.normal, 0.0)).xyz;\n    attr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n  }\n#endif\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\n#if USE_INSTANCING\n  in vec4 a_matWorld0;\n  in vec4 a_matWorld1;\n  in vec4 a_matWorld2;\n  #if CC_USE_LIGHTMAP\n    in vec4 a_lightingMapUVParam;\n  #endif\n#elif USE_BATCHING\n  in float a_dyn_batch_id;\n  layout(std140) uniform CCLocalBatched {\n    highp mat4 cc_matWorlds[10];\n  };\n#else\n  layout(std140) uniform CCLocal {\n    highp mat4 cc_matWorld;\n    highp mat4 cc_matWorldIT;\n    highp vec4 cc_lightingMapUVParam;\n  };\n#endif\nout highp vec4 v_shadowPos;\nlayout(std140) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  lowp  vec4 cc_shadowNFLSInfo;\n  lowp  vec4 cc_shadowWHPBInfo;\n  lowp  vec4 cc_shadowLPNNInfo;\n  lowp  vec4 cc_shadowColor;\n};\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotLightingMap;\n#endif\n#if CC_USE_ATTR_COLOR\nin vec4 a_color;\nout vec4 v_color;\n#endif\nout vec3 v_obj_position;\nout vec3 v_position;\nout vec3 v_normal;\nout vec2 v_uv;\nout vec3 v_tangent;\nout vec3 v_bitangent;\nin vec2 a_texCoord1;\nout vec2 v_uv1;\n#if (CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD)\n    #if USE_INSTANCING\n      in vec4 a_lightingMapAdds0;\n      in vec4 a_lightingMapAdds1;\n      in vec4 a_lightingMapScales0;\n      in vec4 a_lightingMapScales1;\n      out vec4 v_lightingMapAdds0;\n      out vec4 v_lightingMapAdds1;\n      out vec4 v_lightingMapScales0;\n      out vec4 v_lightingMapScales1;\n      void getLightingMapVectors () {\n        v_lightingMapAdds0 = a_lightingMapAdds0;\n        v_lightingMapAdds1 = a_lightingMapAdds1;\n        v_lightingMapScales0 = a_lightingMapScales0;\n        v_lightingMapScales1 = a_lightingMapScales1;\n      }\n    #endif\n    out vec3 v_luv;\n    void CCLightingMapCaclUV()\n    {\n    #if !USE_INSTANCING\n      v_luv.xy = cc_lightingMapUVParam.xy + a_texCoord1 * cc_lightingMapUVParam.zw;\n      v_luv.z = cc_lightingMapUVParam.z;\n    #else\n      v_luv.xy = a_lightingMapUVParam.xy + a_texCoord1 * a_lightingMapUVParam.zw;\n      v_luv.z = a_lightingMapUVParam.z;\n    #endif\n    }\n#endif\nlayout(std140) uniform CCCustomView {\n    mat4 cc_view_taa_prev_viewProj;\n    mat4 cc_view_inverse_transpose_mirror;\n    vec4 cc_view_pr_reflectionPlane;\n    vec4 cc_view_pr_parameters;\n    vec4 cc_view_SkyIrradianceEnvironmentMap[7];\n    vec4 cc_view_SkyColor;\n    vec4 cc_view_SkyLightParameters;\n    vec4 cc_view_IndirectLightingColorScale_Intensity;\n    vec4 cc_view_PreExposure;\n    vec4 cc_view_taa_params1;\n    vec4 cc_view_taa_params2;\n    vec4 cc_view_final_screen_params;\n    vec4 cc_ibl_cluster_BoundsMin;\n    vec4 cc_ibl_cluster_BoundsDelta;\n    vec4 cc_ibl_cluster_CellsDot;\n    vec4 cc_ibl_cluster_CellsMax;\n    vec4 cc_ibl_cluster_TextureSize;\n    vec4 cc_ibl_cluster_InfoTextureInvSize;\n    vec4 cc_ibl_cluster_CellsCountByBoundsSizeAndPixelsPerCell;\n    vec4 cc_light_cluster_BoundsMin;\n    vec4 cc_light_cluster_BoundsDelta;\n    vec4 cc_light_cluster_CellsDot;\n    vec4 cc_light_cluster_CellsMax;\n    vec4 cc_light_cluster_TextureSize;\n    vec4 cc_light_cluster_InfoTextureInvSize;\n    vec4 cc_light_cluster_CellsCountByBoundsSizeAndPixelsPerCell;\n    vec4 FogStruct_ExponentialFogParameters;\n    vec4 FogStruct_ExponentialFogColorParameter;\n    vec4 FogStruct_ExponentialFogParameters2;\n    vec4 FogStruct_ExponentialFogParameters3;\n};\nstruct GlobalView {\n    vec3 IndirectLightingColorScale;\n    float PreExposure;\n};\nvoid sincos0(float a, out float s, out float c)\n{\n  s = sin(a);\n  c = cos(a);\n}\nstruct Light {\n  vec3 color;\n  vec3 direction;\n};\nstruct FDirectLighting\n{\n  vec3 Diffuse;\n  vec3 Specular;\n};\nstruct FPixelMaterialInputs\n{\n  vec3 Normal;\n  vec3 EmissiveColor;\n  float Opacity;\n  float OpacityMask;\n  vec3 BaseColor;\n  float Metallic;\n  float Specular;\n  float Roughness;\n  float AmbientOcclusion;\n  float Anisotropy;\n  float Tangent;\n  float Refraction;\n  float PixelDepthOffset;\n  float ShadingModel;\n  float TwoSidedSign;\n  float RoughnessWithClamp;\n  vec3 DiffuseColor;\n  vec3 SpecularColor;\n  vec3 Subsurface;\n};\nstruct FMaterialPixelParameters {\n  float IndirectIrradiance;\n  vec2 TexCoords_0;\n  vec2 TexCoords_1;\n  vec4 VertexColor;\n  vec3 WorldNormal;\n  vec3 WorldTangent;\n  vec3 ReflectionVector;\n  vec3 CameraVector;\n  vec3 LightVector;\n  vec4 SvPosition;\n  vec4 ScreenPosition;\n  mat3 TangentToWorld;\n  vec3 AbsoluteWorldPosition;\n  vec3 ObjectWorldPosition;\n  vec2 LightmapUVs;\n  int PrimitiveId;\n};\nstruct FMaterialVertexParameters {\n  vec3 WorldPosition;\n  vec4 VertexColor;\n};\n  vec3 RotateAboutAxis(vec4 NormalizedRotationAxisAndAngle, vec3 PositionOnAxis, vec3 Position) {\n      vec3 ClosestPointOnAxis = (PositionOnAxis + vec3 ((NormalizedRotationAxisAndAngle * dot(vec3 (NormalizedRotationAxisAndAngle), (Position - PositionOnAxis)))));\n      vec3 UAxis = (Position - ClosestPointOnAxis);\n      vec3 VAxis = cross(vec3 (NormalizedRotationAxisAndAngle), UAxis);\n      float CosAngle;\n      float SinAngle;\n      sincos0((NormalizedRotationAxisAndAngle).w, SinAngle, CosAngle);\n      vec3 R = ((UAxis * CosAngle) + (VAxis * SinAngle));\n      vec3 RotatedPosition = (ClosestPointOnAxis + R);\n      return (RotatedPosition - Position);\n  }\n  vec3 GetWorldPosition(FMaterialPixelParameters Parameters) {\n      return (Parameters).AbsoluteWorldPosition;\n  }\n  vec3 GetWorldPosition(FMaterialVertexParameters Parameters) {\n      return (Parameters).WorldPosition;\n  }\n  vec3 GetPrevWorldPosition(FMaterialVertexParameters Parameters) {\n      return (Parameters).WorldPosition;\n  }\n   vec4 F4_0101 = vec4(0, 1, 0, 1);\n  vec3 GetMaterialWorldPositionOffset(FMaterialVertexParameters Parameters) {\n    float Local0 = (cc_time.x * 0.250000);\n    float Local1 = (Local0 * (-0.500000));\n    float Local2 = ((F4_0101).a * Local1);\n    vec3 Local3 = (((F4_0101).rgb / sqrt(dot((F4_0101).rgb, (F4_0101).rgb))) * Local2);\n    vec3 Local4 = (GetWorldPosition(Parameters) / 1024.000000);\n    vec3 Local5 = (Local3 + Local4);\n    vec3 Local6 = (Local5 + vec3 (0.500000));\n    vec3 Local7 = fract(Local6);\n    vec3 Local8 = (Local7 * 2.000000);\n    vec3 Local9 = (Local8 + vec3 ((-1.000000)));\n    vec3 Local10 = abs(Local9);\n    vec3 Local11 = (Local10 * 2.000000);\n    vec3 Local12 = (vec3 (3.000000) - Local11);\n    vec3 Local13 = (Local12 * Local10);\n    vec3 Local14 = (Local13 * Local10);\n    float Local15 = dot(((F4_0101).rgb / sqrt(dot((F4_0101).rgb, (F4_0101).rgb))), Local14);\n    vec3 Local16 = (GetWorldPosition(Parameters) / 200.000000);\n    vec3 Local17 = (vec3 (Local2) + Local16);\n    vec3 Local18 = (Local17 + vec3 (0.500000));\n    vec3 Local19 = fract(Local18);\n    vec3 Local20 = (Local19 * 2.000000);\n    vec3 Local21 = (Local20 + vec3 ((-1.000000)));\n    vec3 Local22 = abs(Local21);\n    vec3 Local23 = (Local22 * 2.000000);\n    vec3 Local24 = (vec3 (3.000000) - Local23);\n    vec3 Local25 = (Local24 * Local22);\n    vec3 Local26 = (Local25 * Local22);\n    vec3 Local27 = (Local26 - vec3 (0.000000));\n    float Local28 = dot(Local27, Local27);\n    float Local29 = sqrt(Local28);\n    float Local30 = (Local15 + Local29);\n    float Local31 = (Local30 * 6.283185);\n    vec3 Local32 = RotateAboutAxis(vec4(cross(((F4_0101).rgb / sqrt(dot((F4_0101).rgb, (F4_0101).rgb))), vec3(0.000000, 0.000000, 1.000000)), Local31), (vec3 (0.500000) + vec3(0.000000, 0.000000, (-10.000000))), vec3(0.500000, 0.500000, 0.500000));\n    vec3 Local33 = (Local32 * ((Parameters).VertexColor).r);\n    vec3 Local34 = (Local33 * 0.100000);\n    vec3 Local35 = (Local34 + vec3 (0.500000));\n    float Local36 = (cc_time.x * 0.250000);\n    float Local37 = (Local36 * (-0.500000));\n    float Local38 = ((F4_0101).a * Local37);\n    vec3 Local39 = (((F4_0101).rgb / sqrt(dot((F4_0101).rgb, (F4_0101).rgb))) * Local38);\n    vec3 Local40 = (GetPrevWorldPosition(Parameters) / 1024.000000);\n    vec3 Local41 = (Local39 + Local40);\n    vec3 Local42 = (Local41 + vec3 (0.500000));\n    vec3 Local43 = fract(Local42);\n    vec3 Local44 = (Local43 * 2.000000);\n    vec3 Local45 = (Local44 + vec3 ((-1.000000)));\n    vec3 Local46 = abs(Local45);\n    vec3 Local47 = (Local46 * 2.000000);\n    vec3 Local48 = (vec3 (3.000000) - Local47);\n    vec3 Local49 = (Local48 * Local46);\n    vec3 Local50 = (Local49 * Local46);\n    float Local51 = dot(((F4_0101).rgb / sqrt(dot((F4_0101).rgb, (F4_0101).rgb))), Local50);\n    vec3 Local52 = (GetPrevWorldPosition(Parameters) / 200.000000);\n    vec3 Local53 = (vec3 (Local38) + Local52);\n    vec3 Local54 = (Local53 + vec3 (0.500000));\n    vec3 Local55 = fract(Local54);\n    vec3 Local56 = (Local55 * 2.000000);\n    vec3 Local57 = (Local56 + vec3 ((-1.000000)));\n    vec3 Local58 = abs(Local57);\n    vec3 Local59 = (Local58 * 2.000000);\n    vec3 Local60 = (vec3 (3.000000) - Local59);\n    vec3 Local61 = (Local60 * Local58);\n    vec3 Local62 = (Local61 * Local58);\n    vec3 Local63 = (Local62 - vec3 (0.000000));\n    float Local64 = dot(Local63, Local63);\n    float Local65 = sqrt(Local64);\n    float Local66 = (Local51 + Local65);\n    float Local67 = (Local66 * 6.283185);\n    vec3 Local68 = RotateAboutAxis(vec4(cross(((F4_0101).rgb / sqrt(dot((F4_0101).rgb, (F4_0101).rgb))), vec3(0.000000, 0.000000, 1.000000)), Local67), (vec3 (0.500000) + vec3(0.000000, 0.000000, (-10.000000))), vec3(0.500000, 0.500000, 0.500000));\n    vec3 Local69 = (Local68 * ((Parameters).VertexColor).r);\n    vec3 Local70 = (Local69 * 0.100000);\n    vec3 Local71 = (Local70 + vec3 (0.500000));\n    return Local35;\n}\nvoid main () {\n  StandardVertInput In;\n      In.position = vec4(a_position, 1.0);\n      In.normal = a_normal;\n      In.tangent = a_tangent;\n    #if CC_USE_MORPH\n      applyMorph(In);\n    #endif\n    #if CC_USE_SKINNING\n      CCSkin(In);\n    #endif\n  mat4 matWorld, matWorldIT;\n    #if USE_INSTANCING\n      matWorld = mat4(\n        vec4(a_matWorld0.xyz, 0.0),\n        vec4(a_matWorld1.xyz, 0.0),\n        vec4(a_matWorld2.xyz, 0.0),\n        vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n      );\n      matWorldIT = matWorld;\n    #elif USE_BATCHING\n      matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n      matWorldIT = matWorld;\n    #else\n      matWorld = cc_matWorld;\n      matWorldIT = cc_matWorldIT;\n    #endif\n  vec4 pos = matWorld * In.position;\n  FMaterialVertexParameters Parameters;\n  Parameters.WorldPosition = pos.xzy * 100.;\n  #if CC_USE_ATTR_COLOR\n  Parameters.VertexColor = a_color;\n  #else\n  Parameters.VertexColor = vec4(1.);\n  #endif\n  pos.xyz += GetMaterialWorldPositionOffset(Parameters).xzy / 100.;\n  v_obj_position = matWorld[3].xyz;\n  v_position = pos.xyz;\n  v_normal = normalize((matWorldIT * vec4(In.normal, 0.0)).xyz);\n  v_tangent = normalize((matWorld * vec4(In.tangent.xyz, 0.0)).xyz);\n  v_bitangent = normalize(cross(v_normal, v_tangent) * In.tangent.w);\n  v_uv = a_texCoord;\n  #if SAMPLE_FROM_RT\n      v_uv = cc_cameraPos.w > 1.0 ? vec2(v_uv.x, 1.0 - v_uv.y) : v_uv;\n  #endif\n  v_uv1 = a_texCoord1;\n  #if SAMPLE_FROM_RT\n      v_uv1 = cc_cameraPos.w > 1.0 ? vec2(v_uv1.x, 1.0 - v_uv1.y) : v_uv1;\n  #endif\n  #if CC_USE_ATTR_COLOR\n  v_color = a_color;\n  #endif\n  #if (CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD)\n    CCLightingMapCaclUV();\n    #if USE_INSTANCING\n      getLightingMapVectors();\n    #endif\n  #endif\n  v_shadowPos = cc_matLightViewProj * pos;\n  mat4 matProj = cc_matProj;\n  matProj[2][0] += cc_view_taa_params1.x;\n  matProj[2][1] += cc_view_taa_params1.y;\n  gl_Position = matProj * cc_matView * pos;\n}","frag":"\nprecision highp float;\n  layout(std140) uniform CCGlobal {\n    highp   vec4 cc_time;\n    mediump vec4 cc_screenSize;\n    mediump vec4 cc_nativeSize;\n  };\n  layout(std140) uniform CCCamera {\n    highp   mat4 cc_matView;\n    highp   mat4 cc_matViewInv;\n    highp   mat4 cc_matProj;\n    highp   mat4 cc_matProjInv;\n    highp   mat4 cc_matViewProj;\n    highp   mat4 cc_matViewProjInv;\n    highp   vec4 cc_cameraPos;\n    mediump vec4 cc_screenScale;\n    mediump vec4 cc_exposure;\n    mediump vec4 cc_mainLitDir;\n    mediump vec4 cc_mainLitColor;\n    mediump vec4 cc_ambientSky;\n    mediump vec4 cc_ambientGround;\n    mediump vec4 cc_fogColor;\n    mediump vec4 cc_fogBase;\n    mediump vec4 cc_fogAdd;\n    mediump vec4 cc_nearFar;\n    mediump vec4 cc_viewPort;\n  };\n  layout(std140) uniform CCLocal {\n    highp mat4 cc_matWorld;\n    highp mat4 cc_matWorldIT;\n    highp vec4 cc_lightingMapUVParam;\n  };\n  layout(std140) uniform CCCustomView {\n      mat4 cc_view_taa_prev_viewProj;\n      mat4 cc_view_inverse_transpose_mirror;\n      vec4 cc_view_pr_reflectionPlane;\n      vec4 cc_view_pr_parameters;\n      vec4 cc_view_SkyIrradianceEnvironmentMap[7];\n      vec4 cc_view_SkyColor;\n      vec4 cc_view_SkyLightParameters;\n      vec4 cc_view_IndirectLightingColorScale_Intensity;\n      vec4 cc_view_PreExposure;\n      vec4 cc_view_taa_params1;\n      vec4 cc_view_taa_params2;\n      vec4 cc_view_final_screen_params;\n      vec4 cc_ibl_cluster_BoundsMin;\n      vec4 cc_ibl_cluster_BoundsDelta;\n      vec4 cc_ibl_cluster_CellsDot;\n      vec4 cc_ibl_cluster_CellsMax;\n      vec4 cc_ibl_cluster_TextureSize;\n      vec4 cc_ibl_cluster_InfoTextureInvSize;\n      vec4 cc_ibl_cluster_CellsCountByBoundsSizeAndPixelsPerCell;\n      vec4 cc_light_cluster_BoundsMin;\n      vec4 cc_light_cluster_BoundsDelta;\n      vec4 cc_light_cluster_CellsDot;\n      vec4 cc_light_cluster_CellsMax;\n      vec4 cc_light_cluster_TextureSize;\n      vec4 cc_light_cluster_InfoTextureInvSize;\n      vec4 cc_light_cluster_CellsCountByBoundsSizeAndPixelsPerCell;\n      vec4 FogStruct_ExponentialFogParameters;\n      vec4 FogStruct_ExponentialFogColorParameter;\n      vec4 FogStruct_ExponentialFogParameters2;\n      vec4 FogStruct_ExponentialFogParameters3;\n  };\n  struct GlobalView {\n      vec3 IndirectLightingColorScale;\n      float PreExposure;\n  };\n  void getGlobalView (out GlobalView View) {\n      View.IndirectLightingColorScale = cc_view_IndirectLightingColorScale_Intensity.rgb * cc_view_IndirectLightingColorScale_Intensity.w;\n      View.PreExposure = cc_view_PreExposure.x;\n  }\nfloat Luminance( vec3 LinearColor )\n{\n  return dot( LinearColor, vec3( 0.3, 0.59, 0.11 ) );\n}\nvec3 CCRGBE2Linear (vec4 rgbe) {\n    return rgbe.rgb * pow(1.1, rgbe.a * 255.0 - 128.0);\n}\nvec4 decodeCCRGBE (vec4 color) {\n  color.rgb = CCRGBE2Linear(color);\n  color.a = 1.;\n  return color;\n}\nfloat rsqrt (float x) {\n  return 1. / sqrt(x);\n}\nfloat Square(float v)\n{\n    return v * v;\n}\nstruct Light {\n  vec3 color;\n  vec3 direction;\n};\nstruct FDirectLighting\n{\n  vec3 Diffuse;\n  vec3 Specular;\n};\nstruct FPixelMaterialInputs\n{\n  vec3 Normal;\n  vec3 EmissiveColor;\n  float Opacity;\n  float OpacityMask;\n  vec3 BaseColor;\n  float Metallic;\n  float Specular;\n  float Roughness;\n  float AmbientOcclusion;\n  float Anisotropy;\n  float Tangent;\n  float Refraction;\n  float PixelDepthOffset;\n  float ShadingModel;\n  float TwoSidedSign;\n  float RoughnessWithClamp;\n  vec3 DiffuseColor;\n  vec3 SpecularColor;\n  vec3 Subsurface;\n};\nstruct FMaterialPixelParameters {\n  float IndirectIrradiance;\n  vec2 TexCoords_0;\n  vec2 TexCoords_1;\n  vec4 VertexColor;\n  vec3 WorldNormal;\n  vec3 WorldTangent;\n  vec3 ReflectionVector;\n  vec3 CameraVector;\n  vec3 LightVector;\n  vec4 SvPosition;\n  vec4 ScreenPosition;\n  mat3 TangentToWorld;\n  vec3 AbsoluteWorldPosition;\n  vec3 ObjectWorldPosition;\n  vec2 LightmapUVs;\n  int PrimitiveId;\n};\nstruct FMaterialVertexParameters {\n  vec3 WorldPosition;\n  vec4 VertexColor;\n};\n  vec3 GetMaterialNormalRaw(FPixelMaterialInputs PixelMaterialInputs) {\n      return vec3 ((PixelMaterialInputs).Normal);\n  }\n  vec3 GetMaterialNormal(FMaterialPixelParameters Parameters, FPixelMaterialInputs PixelMaterialInputs) {\n      vec3 RetNormal = GetMaterialNormalRaw(PixelMaterialInputs);\n      return RetNormal;\n  }\n  vec3 TransformTangentNormalToWorld(mat3 TangentToWorld, vec3 normal) {\n      return normalize((TangentToWorld * normalize(normal)));\n  }\n  vec3 ReflectionAboutCustomWorldNormal(inout FMaterialPixelParameters Parameters, vec3 WorldNormal, bool bNormalizeInputNormal) {\n      ((Parameters).WorldNormal = (TransformTangentNormalToWorld((Parameters).TangentToWorld, (Parameters).WorldNormal)).xzy);\n      ((Parameters).ReflectionVector = normalize(reflect((-(Parameters).CameraVector), (Parameters).WorldNormal)));\n      return (Parameters).ReflectionVector;\n  }\n  vec4 SvPositionToResolvedScreenPosition(vec4 SvPosition) {\n      vec2 pixelPos = (SvPosition).xy;\n      vec3 ndc = vec3((((pixelPos * (cc_screenSize).zw) - vec2 (0.500000)) * 2.000000), (gl_FragCoord));\n      vec4 screenPos = (vec4(ndc, 1.000000) / (gl_FragCoord));\n      return screenPos;\n  }\n   vec4 F4_0101 = vec4(0, 1, 0, 1);\nvoid CalcPixelMaterialInputs(inout FMaterialPixelParameters Parameters, inout FPixelMaterialInputs PixelMaterialInputs) {\n    ((PixelMaterialInputs).Normal = vec3(0.000000, 0.000000, 1.000000));\n    vec3 MaterialNormal = vec3 (GetMaterialNormal(Parameters, PixelMaterialInputs));\n    ((Parameters).WorldNormal = normalize(MaterialNormal));\n    ((Parameters).ReflectionVector = ReflectionAboutCustomWorldNormal(Parameters, (Parameters).WorldNormal, false));\n    ((PixelMaterialInputs).EmissiveColor = vec3(0.000000, 0.000000, 0.000000));\n    ((PixelMaterialInputs).Opacity = 1.000000);\n    ((PixelMaterialInputs).OpacityMask = 1.000000);\n    ((PixelMaterialInputs).BaseColor = vec3(0.270222, 0.242972, 0.937500));\n    ((PixelMaterialInputs).Metallic = 0.000000);\n    ((PixelMaterialInputs).Specular = 0.500000);\n    ((PixelMaterialInputs).Roughness = 0.500000);\n    ((PixelMaterialInputs).Anisotropy = 0.000000);\n    ((PixelMaterialInputs).Tangent = float (vec3(1.000000, 0.000000, 0.000000)));\n    ((PixelMaterialInputs).Subsurface = vec3 (0));\n    ((PixelMaterialInputs).AmbientOcclusion = 1.000000);\n    ((Parameters).WorldTangent = vec3 (0));\n}\n#if CC_USE_ATTR_COLOR\nin vec4 v_color;\n#endif\nin vec3 v_obj_position;\nin vec3 v_position;\nin vec3 v_normal;\nin vec2 v_uv;\nin vec2 v_uv1;\nin vec3 v_tangent;\nin vec3 v_bitangent;\nvoid getPixelParameters (out FMaterialPixelParameters Parameters) {\n  Parameters.TexCoords_0 = v_uv;\n  Parameters.TexCoords_1 = v_uv1;\n  #if CC_USE_ATTR_COLOR\n    Parameters.VertexColor = v_color;\n  #else\n    Parameters.VertexColor = vec4(1.);\n  #endif\n  Parameters.WorldNormal = v_normal;\n  Parameters.AbsoluteWorldPosition = v_position;\n  Parameters.ObjectWorldPosition = v_obj_position;\n  Parameters.CameraVector = normalize(cc_cameraPos.xyz - v_position);\n  Parameters.SvPosition = gl_FragCoord;\n  Parameters.ScreenPosition = SvPositionToResolvedScreenPosition(gl_FragCoord);\n  Parameters.TangentToWorld = mat3(\n    v_tangent,\n    v_bitangent,\n    v_normal\n  );\n  Parameters.LightmapUVs = v_uv1;\n  Parameters.IndirectIrradiance = 0.;\n}\nvoid surf (out FPixelMaterialInputs PixelMaterialInputs, out FMaterialPixelParameters Parameters, out GlobalView View) {\n  getPixelParameters(Parameters);\n  getGlobalView(View);\n  Parameters.AbsoluteWorldPosition = Parameters.AbsoluteWorldPosition.xzy * 100.;\n  Parameters.ObjectWorldPosition = Parameters.ObjectWorldPosition.xzy * 100.;\n  Parameters.CameraVector = Parameters.CameraVector.xzy;\n  CalcPixelMaterialInputs(Parameters, PixelMaterialInputs);\n  float TwoSidedSign = 1.;\n  if (!gl_FrontFacing) {\n    TwoSidedSign = -1.;\n  }\n  Parameters.AbsoluteWorldPosition = Parameters.AbsoluteWorldPosition.xzy / 100.;\n  Parameters.ObjectWorldPosition = Parameters.ObjectWorldPosition.xzy / 100.;\n  Parameters.CameraVector = Parameters.CameraVector.xzy;\n  Parameters.WorldNormal = Parameters.WorldNormal.xzy * TwoSidedSign;\n  Parameters.ReflectionVector = Parameters.ReflectionVector.xzy;\n  if (PixelMaterialInputs.OpacityMask < 0.33330) {\n    discard;\n  }\n  PixelMaterialInputs.Metallic = clamp(PixelMaterialInputs.Metallic, 0.0, 1.0);\n  PixelMaterialInputs.Specular = clamp(PixelMaterialInputs.Specular, 0.0, 1.0);\n  PixelMaterialInputs.Roughness = clamp(PixelMaterialInputs.Roughness, 0.0, 1.0);\n  PixelMaterialInputs.TwoSidedSign = TwoSidedSign;\n}\nfloat GGX_Mobile(float Roughness, float NoH, vec3 H, vec3 N)\n{\n    vec3 NxH = cross(N, H);\n    float OneMinusNoHSqr = dot(NxH, NxH);\n    float a = Roughness * Roughness;\n    float n = NoH * a;\n    float p = a / (OneMinusNoHSqr + n * n);\n    return p * p;\n}\nfloat D_GGX( float a2, float NoH )\n{\n  float d = ( NoH * a2 - NoH ) * NoH + 1.;\n  return a2 / ( 3.14159265359*d*d );\n}\n  in highp vec4 v_shadowPos;\n  layout(std140) uniform CCShadow {\n    highp mat4 cc_matLightPlaneProj;\n    highp mat4 cc_matLightView;\n    highp mat4 cc_matLightViewProj;\n    highp vec4 cc_shadowInvProjDepthInfo;\n    highp vec4 cc_shadowProjDepthInfo;\n    highp vec4 cc_shadowProjInfo;\n    lowp  vec4 cc_shadowNFLSInfo;\n    lowp  vec4 cc_shadowWHPBInfo;\n    lowp  vec4 cc_shadowLPNNInfo;\n    lowp  vec4 cc_shadowColor;\n  };\n  float CCGetLinearDepthFromViewSpace(vec3 viewPos) {\n    float dist = length(viewPos);\n    return (dist - cc_shadowNFLSInfo.x) / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x);\n  }\n  float CCGetLinearDepth(vec3 worldPos) {\n    vec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n    return CCGetLinearDepthFromViewSpace(viewStartPos.xyz);\n  }\n  #if CC_RECEIVE_SHADOW\n    uniform highp sampler2D cc_shadowMap;\n    uniform highp sampler2D cc_spotLightingMap;\n    vec4 ApplyShadowDepthBias_FaceNormal(vec4 shadowPos, vec3 worldNormal)\n    {\n      vec4 newShadowPos = shadowPos;\n      if(cc_shadowLPNNInfo.z > 0.0001)\n      {\n        vec4 viewNormal = cc_matLightView * vec4(worldNormal, 0.0);\n        if(viewNormal.z < 0.1)\n          newShadowPos.xy += viewNormal.xy * cc_shadowProjInfo.xy * cc_shadowLPNNInfo.z * clamp(viewNormal.z, 0.001, 0.1);\n      }\n      return newShadowPos;\n    }\n    vec4 ApplyShadowDepthBias_Perspective(vec4 shadowPos, float viewspaceDepthBias)\n    {\n      vec3 viewSpacePos;\n      viewSpacePos.xy = shadowPos.xy * cc_shadowProjInfo.zw;\n      viewSpacePos.z = shadowPos.z * cc_shadowInvProjDepthInfo.x + shadowPos.w * cc_shadowInvProjDepthInfo.y;\n      viewSpacePos.xyz += cc_shadowProjDepthInfo.z * normalize(viewSpacePos.xyz) * viewspaceDepthBias;\n      vec4 clipSpacePos;\n      clipSpacePos.xy = viewSpacePos.xy * cc_shadowProjInfo.xy;\n      clipSpacePos.zw = viewSpacePos.z * cc_shadowProjDepthInfo.xz + vec2(cc_shadowProjDepthInfo.y, 0.0);\n      if (cc_shadowNFLSInfo.z > 0.000001) {\n        clipSpacePos.z = CCGetLinearDepthFromViewSpace(viewSpacePos.xyz);\n        clipSpacePos.z = (clipSpacePos.z * 2.0 - 1.0) * clipSpacePos.w;\n      }\n      return clipSpacePos;\n    }\n    vec4 ApplyShadowDepthBias_Orthographic(vec4 shadowPos, float viewspaceDepthBias)\n    {\n      float coeffA = cc_shadowProjDepthInfo.x;\n      float coeffB = cc_shadowProjDepthInfo.y;\n      float viewSpacePos_z = (shadowPos.z - coeffB) / coeffA;\n      viewSpacePos_z += viewspaceDepthBias;\n      vec4 result = shadowPos;\n      result.z = viewSpacePos_z * coeffA + coeffB;\n      return result;\n    }\n    float CCGetShadowFactorHard (vec4 shadowPos) {\n      vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, cc_shadowWHPBInfo.w);\n      vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n      if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n          clipPos.y < 0.0 || clipPos.y > 1.0 ||\n          clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n      clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n      float shadow = 0.0;\n      float closestDepth = 0.0;\n      if (cc_shadowLPNNInfo.y > 0.000001) {\n        closestDepth = dot(texture(cc_shadowMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n      } else {\n        closestDepth = texture(cc_shadowMap, clipPos.xy).x;\n      }\n      shadow = step(clipPos.z, closestDepth);\n      return shadow;\n    }\n    float CCGetShadowFactorSoft (vec4 shadowPos) {\n      vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, cc_shadowWHPBInfo.w);\n      vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n      if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n          clipPos.y < 0.0 || clipPos.y > 1.0 ||\n          clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n      clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n      float offsetDepth = clipPos.z;\n      vec2 mapSize = cc_shadowWHPBInfo.xy;\n      vec2 oneTap = 1.0 / mapSize;\n      vec2 clipPos_offset = clipPos.xy + oneTap;\n      float block0, block1, block2, block3;\n      if (cc_shadowLPNNInfo.y > 0.000001) {\n        block0 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block1 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block2 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block3 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      } else {\n        block0 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\n        block1 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)).x);\n        block2 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)).x);\n        block3 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);\n      }\n      float coefX   = mod(clipPos.x, oneTap.x) * mapSize.x;\n      float resultX = mix(block0, block1, coefX);\n      float resultY = mix(block2, block3, coefX);\n      float coefY   = mod(clipPos.y, oneTap.y) * mapSize.y;\n      return mix(resultX, resultY, coefY);\n    }\n    float CCGetShadowFactorSoft2X (vec4 shadowPos) {\n      vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, cc_shadowWHPBInfo.w);\n      vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n      if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n          clipPos.y < 0.0 || clipPos.y > 1.0 ||\n          clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n      clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n      float offsetDepth = clipPos.z;\n      vec2 mapSize = cc_shadowWHPBInfo.xy;\n      vec2 oneTap = 1.0 / mapSize;\n      float clipPos_offset_L = clipPos.x - oneTap.x;\n      float clipPos_offset_R = clipPos.x + oneTap.x;\n      float clipPos_offset_U = clipPos.y - oneTap.y;\n      float clipPos_offset_D = clipPos.y + oneTap.y;\n      float block0, block1, block2, block3, block4, block5, block6, block7, block8;\n      if (cc_shadowLPNNInfo.y > 0.000001) {\n        block0 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block1 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block2 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block3 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block4 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block5 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block6 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block7 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block8 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      } else {\n        block0 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);\n        block1 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)).x);\n        block2 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);\n        block3 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)).x);\n        block4 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\n        block5 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)).x);\n        block6 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);\n        block7 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)).x);\n        block8 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);\n      }\n      float coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\n      float coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\n      float shadow = 0.0;\n      float resultX = mix(block0, block1, coefX);\n      float resultY = mix(block3, block4, coefX);\n      shadow += mix(resultX , resultY, coefY);\n      resultX = mix(block1, block2, coefX);\n      resultY = mix(block4, block5, coefX);\n      shadow += mix(resultX , resultY, coefY);\n      resultX = mix(block3, block4, coefX);\n      resultY = mix(block6, block7, coefX);\n      shadow += mix(resultX, resultY, coefY);\n      resultX = mix(block4, block5, coefX);\n      resultY = mix(block7, block8, coefX);\n      shadow += mix(resultX, resultY, coefY);\n      return shadow * 0.25;\n    }\n    float CCGetSpotLightShadowFactorHard (vec4 shadowPos, vec3 worldPos) {\n      vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, cc_shadowWHPBInfo.w);\n      vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n      if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n          clipPos.y < 0.0 || clipPos.y > 1.0 ||\n          clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n      clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n      float shadow = 0.0;\n      float closestDepth = 0.0;\n      float depth = clipPos.z;\n      if (cc_shadowLPNNInfo.y > 0.000001) {\n        closestDepth = dot(texture(cc_spotLightingMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n      } else {\n        closestDepth = texture(cc_spotLightingMap, clipPos.xy).x;\n      }\n      shadow = step(depth, closestDepth);\n      return shadow;\n    }\n    float CCGetSpotLightShadowFactorSoft (vec4 shadowPos, vec3 worldPos) {\n      vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, cc_shadowWHPBInfo.w);\n      vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n      if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n          clipPos.y < 0.0 || clipPos.y > 1.0 ||\n          clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n      clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n      float depth = 0.0;\n      if (cc_shadowNFLSInfo.z > 0.000001) {\n        depth = CCGetLinearDepth(worldPos);\n      } else {\n        depth = clipPos.z;\n      }\n      float bias = cc_shadowWHPBInfo.w;\n      vec2 oneTap = 1.0 / cc_shadowWHPBInfo.xy;\n      vec2 clipPos_offset = clipPos.xy + oneTap;\n      float block0, block1, block2, block3;\n      if (cc_shadowLPNNInfo.y > 0.000001) {\n        block0 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block1 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block2 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block3 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      } else {\n        block0 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x);\n        block1 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos.y)).x);\n        block2 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset.y)).x);\n        block3 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);\n      }\n      float coefX   = mod(clipPos.x, oneTap.x) * cc_shadowWHPBInfo.x;\n      float resultX = mix(block0, block1, coefX);\n      float resultY = mix(block2, block3, coefX);\n      float coefY   = mod(clipPos.y, oneTap.y) * cc_shadowWHPBInfo.y;\n      return mix(resultX, resultY, coefY);\n    }\n    float CCGetSpotLightShadowFactorSoft2X (vec4 shadowPos, vec3 worldPos) {\n      vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, cc_shadowWHPBInfo.w);\n      vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n      if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n          clipPos.y < 0.0 || clipPos.y > 1.0 ||\n          clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n      clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n      float depth = 0.0;\n      if (cc_shadowNFLSInfo.z > 0.000001) {\n        depth = CCGetLinearDepth(worldPos);\n      } else {\n        depth = clipPos.z;\n      }\n      float bias = cc_shadowWHPBInfo.w;\n      vec2 mapSize = cc_shadowWHPBInfo.xy;\n      vec2 oneTap = 1.0 / mapSize;\n      float clipPos_offset_L = clipPos.x - oneTap.x;\n      float clipPos_offset_R = clipPos.x + oneTap.x;\n      float clipPos_offset_U = clipPos.y - oneTap.y;\n      float clipPos_offset_D = clipPos.y + oneTap.y;\n      float block0, block1, block2, block3, block4, block5, block6, block7, block8;\n      if (cc_shadowLPNNInfo.y > 0.000001) {\n        block0 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block1 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block2 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block3 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block4 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block5 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block6 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block7 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block8 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      } else {\n        block0 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);\n        block1 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_U)).x);\n        block2 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);\n        block3 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos.y)).x);\n        block4 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x);\n        block5 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos.y)).x);\n        block6 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);\n        block7 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_D)).x);\n        block8 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);\n      }\n      float coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\n      float coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\n      float shadow = 0.0;\n      float resultX = mix(block0, block1, coefX);\n      float resultY = mix(block3, block4, coefX);\n      shadow += mix(resultX , resultY, coefY);\n      resultX = mix(block1, block2, coefX);\n      resultY = mix(block4, block5, coefX);\n      shadow += mix(resultX , resultY, coefY);\n      resultX = mix(block3, block4, coefX);\n      resultY = mix(block6, block7, coefX);\n      shadow += mix(resultX, resultY, coefY);\n      resultX = mix(block4, block5, coefX);\n      resultY = mix(block7, block8, coefX);\n      shadow += mix(resultX, resultY, coefY);\n      return shadow * 0.25;\n    }\n  #endif\nconst float FLT_EPSILON = 0.001;\nconst float FLT_EPSILON2 = 0.01;\nfloat CalculateLineIntegralShared(float FogHeightFalloff, float RayDirectionZ, float RayOriginTerms)\n{\n  float Falloff = max(-127.0, FogHeightFalloff * RayDirectionZ);\n  float LineIntegral = ( 1.0 - exp2(-Falloff) ) / Falloff;\n  float LineIntegralTaylor = log(2.0) - ( 0.5 * (pow(2., log(2.0))) ) * Falloff;\n  return RayOriginTerms * ( abs(Falloff) > FLT_EPSILON2 ? LineIntegral : LineIntegralTaylor );\n}\nvec3 ComputeInscatteringColor(vec3 CameraToReceiver, float CameraToReceiverLength)\n{\n  vec3 Inscattering = FogStruct_ExponentialFogColorParameter.xyz;\n  return Inscattering;\n}\nvec4 GetExponentialHeightFog(vec3 WorldPositionRelativeToCamera, float ExcludeDistance)\n{\n  float MinFogOpacity = FogStruct_ExponentialFogColorParameter.w;\n  float MaxWorldObserverHeight = FogStruct_ExponentialFogParameters.z;\n  vec3 View_WorldCameraOrigin = cc_cameraPos.xyz;\n  vec3 WorldObserverOrigin = vec3(View_WorldCameraOrigin.x, min(View_WorldCameraOrigin.y, MaxWorldObserverHeight), View_WorldCameraOrigin.z);\n  vec3 CameraToReceiver = WorldPositionRelativeToCamera;\n  CameraToReceiver.y += View_WorldCameraOrigin.y - WorldObserverOrigin.y;\n  float CameraToReceiverLengthSqr = dot(CameraToReceiver, CameraToReceiver);\n  float CameraToReceiverLengthInv = rsqrt(CameraToReceiverLengthSqr);\n  float CameraToReceiverLength = CameraToReceiverLengthSqr * CameraToReceiverLengthInv;\n  vec3 CameraToReceiverNormalized = CameraToReceiver * CameraToReceiverLengthInv;\n  float RayOriginTerms = FogStruct_ExponentialFogParameters.x;\n  float RayOriginTermsSecond = FogStruct_ExponentialFogParameters2.x;\n  float RayLength = CameraToReceiverLength;\n  float RayDirectionZ = CameraToReceiver.y;\n  ExcludeDistance = max(ExcludeDistance, FogStruct_ExponentialFogParameters.w);\n  if (ExcludeDistance > 0.)\n  {\n    float ExcludeIntersectionTime = ExcludeDistance * CameraToReceiverLengthInv;\n    float CameraToExclusionIntersectionZ = ExcludeIntersectionTime * CameraToReceiver.y;\n    float ExclusionIntersectionZ = WorldObserverOrigin.y + CameraToExclusionIntersectionZ;\n    float ExclusionIntersectionToReceiverZ = CameraToReceiver.y - CameraToExclusionIntersectionZ;\n    RayLength = (1.0 - ExcludeIntersectionTime) * CameraToReceiverLength;\n    RayDirectionZ = ExclusionIntersectionToReceiverZ;\n    float Exponent = max(-127.0, FogStruct_ExponentialFogParameters.y * (ExclusionIntersectionZ - FogStruct_ExponentialFogParameters3.y));\n    RayOriginTerms = FogStruct_ExponentialFogParameters3.x * exp2(-Exponent);\n    float ExponentSecond = max(-127.0, FogStruct_ExponentialFogParameters2.y * (ExclusionIntersectionZ - FogStruct_ExponentialFogParameters2.w));\n    RayOriginTermsSecond = FogStruct_ExponentialFogParameters2.z * exp2(-ExponentSecond);\n  }\n  float ExponentialHeightLineIntegralShared = CalculateLineIntegralShared(FogStruct_ExponentialFogParameters.y, RayDirectionZ, RayOriginTerms) + CalculateLineIntegralShared(FogStruct_ExponentialFogParameters2.y, RayDirectionZ, RayOriginTermsSecond);\n  float ExponentialHeightLineIntegral = ExponentialHeightLineIntegralShared * RayLength;\n  vec3 InscatteringColor = ComputeInscatteringColor(CameraToReceiver, CameraToReceiverLength);\n  vec3 DirectionalInscattering = vec3(0.);\n  float ExpFogFactor = max(clamp(exp2(-ExponentialHeightLineIntegral), 0.0, 1.0), MinFogOpacity);\n  if (FogStruct_ExponentialFogParameters3.w > 0. && CameraToReceiverLength > FogStruct_ExponentialFogParameters3.w)\n  {\n    ExpFogFactor = 1.;\n    DirectionalInscattering = vec3(0.);\n  }\n    vec3 FogColor = (InscatteringColor) * (1. - ExpFogFactor) + DirectionalInscattering;\n  return vec4(FogColor, ExpFogFactor);\n}\nvec4 CalculateHeightFog(vec3 WorldPositionRelativeToCamera)\n{\n  vec3 WorldPosition = WorldPositionRelativeToCamera;\n  float ExcludeDistance = 0.;\n  vec4 FogInscatteringAndOpacity = GetExponentialHeightFog(WorldPositionRelativeToCamera, ExcludeDistance);\n  return FogInscatteringAndOpacity;\n}\nvec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {\n    return textureLod(tex, coord, lod);\n}\nvec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {\n    return textureLod(tex, coord, lod);\n}\nfloat ComputeReflectionCaptureMipFromRoughness(float Roughness, float CubemapMaxMip)\n{\n  float LevelFrom1x1 = 1.000001 - 1.2 * log2(Roughness);\n  return CubemapMaxMip - 1. - LevelFrom1x1;\n}\nvec3 GetSkySHDiffuseSimple(vec3 Normal)\n{\n  vec4 NormalVector = vec4(Normal.xzy, 1);\n  vec3 Intermediate0;\n  Intermediate0.x = dot(cc_view_SkyIrradianceEnvironmentMap[0], NormalVector);\n  Intermediate0.y = dot(cc_view_SkyIrradianceEnvironmentMap[1], NormalVector);\n  Intermediate0.z = dot(cc_view_SkyIrradianceEnvironmentMap[2], NormalVector);\n  return max(vec3(0.), Intermediate0);\n}\nuniform samplerCube cc_ibl_map_sky;\nvec3 GetSkyLightReflection(vec3 ReflectionVector, float Roughness, out float OutSkyAverageBrightness) {\n  float AbsoluteSpecularMip = ComputeReflectionCaptureMipFromRoughness(Roughness, cc_view_SkyLightParameters.x);\n  vec3 Reflection = decodeCCRGBE(fragTextureLod(cc_ibl_map_sky, ReflectionVector, AbsoluteSpecularMip)).rgb;\n  OutSkyAverageBrightness = cc_view_SkyColor.w * Luminance( cc_view_SkyColor.rgb );\n  return Reflection * cc_view_SkyColor.rgb;\n}\nvec3 posWS2screen (vec3 posWS) {\n  vec4 res = cc_matViewProj * vec4(posWS, 1.);\n  res.xyz /= res.w;\n  res.xyz = res.xyz * 0.5 + 0.5;\n  return res.xyz;\n}\nfloat CalcSpecular(float Roughness, float RoughnessWithClamp, float NoH, vec3 H, vec3 N)\n{\n  return (Roughness*0.25 + 0.25) * GGX_Mobile(RoughnessWithClamp, NoH, H, N);\n}\nFDirectLighting MobileIntegrateBxDF(FPixelMaterialInputs ShadingModelContext, vec3 N, vec3 H, float NoH)\n{\n  FDirectLighting Lighting;\n  Lighting.Specular = ShadingModelContext.SpecularColor * CalcSpecular(ShadingModelContext.Roughness, ShadingModelContext.RoughnessWithClamp, NoH, H, N);\n  Lighting.Diffuse = ShadingModelContext.DiffuseColor;\n  return Lighting;\n}\nvec3 EnvBRDFApprox( vec3 SpecularColor, float Roughness, float NoV )\n{\n  const vec4 c0 = vec4(-1., -0.0275, -0.572, 0.022);\n  const vec4 c1 = vec4(1., 0.0425, 1.04, -0.04);\n  vec4 r = Roughness * c0 + c1;\n  float a004 = min( r.x * r.x, exp2( -9.28 * NoV ) ) * r.x + r.y;\n  vec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n  AB.y *= clamp(50.0 * SpecularColor.g, 0.0, 1.0);\n  return SpecularColor * AB.x + AB.y;\n}\nuniform sampler2D cc_ibl_cluster_InfoTexture;\nuniform sampler2D cc_ibl_cluster_Texture;\nuniform sampler2D cc_ibl_cluster_CubemapAtlas;\nvec2 envMapEquirect(vec3 wcNormal) {\n  float phi = acos(-wcNormal.y);\n  float theta = atan(1. * wcNormal.x, wcNormal.z) + 3.14159265359;\n  vec2 uv = vec2(theta / 6.28318530718, 1. - phi / 3.14159265359);\n  return uv;\n}\nfloat ComputeMixingWeight(float IndirectIrradiance, float AverageBrightness, float Roughness)\n{\n  float MixingAlpha = smoothstep(0., 1., clamp(Roughness * 5.000001 + -0.5, 0.0, 1.0));\n  float MixingWeight = IndirectIrradiance / max(AverageBrightness, .0001);\n  MixingWeight = min(MixingWeight, 10000.000001);\n  return mix(1.0, MixingWeight, MixingAlpha);\n}\nvec3 GetLookupVectorForSphereCapture(vec3 ReflectionVector, vec3 WorldPosition, vec4 SphereCapturePositionAndRadius, float NormalizedDistanceToCapture, vec3 LocalCaptureOffset, inout float DistanceAlpha)\n{\n  vec3 ProjectedCaptureVector = ReflectionVector;\n  float ProjectionSphereRadius = SphereCapturePositionAndRadius.w;\n  float SphereRadiusSquared = ProjectionSphereRadius * ProjectionSphereRadius;\n  vec3 LocalPosition = WorldPosition - SphereCapturePositionAndRadius.xyz;\n  float LocalPositionSqr = dot(LocalPosition, LocalPosition);\n  vec3 QuadraticCoef;\n  QuadraticCoef.x = 1.;\n  QuadraticCoef.y = dot(ReflectionVector, LocalPosition);\n  QuadraticCoef.z = LocalPositionSqr - SphereRadiusSquared;\n  float Determinant = QuadraticCoef.y * QuadraticCoef.y - QuadraticCoef.z;\n  if (Determinant >= 0.)\n  {\n    float FarIntersection = sqrt(Determinant) - QuadraticCoef.y;\n    vec3 LocalIntersectionPosition = LocalPosition + FarIntersection * ReflectionVector;\n    ProjectedCaptureVector = normalize(LocalIntersectionPosition - LocalCaptureOffset);\n    float x = clamp(2.5 * NormalizedDistanceToCapture - 1.5, 0.0, 1.0);\n    DistanceAlpha = 1. - x*x*(3. - 2.*x);\n  }\n  return ProjectedCaptureVector;\n}\nvoid EvaluateClusterIBL(float iblIndex, FMaterialPixelParameters MaterialParameters, float mip, float IndirectIrradiance, inout vec4 ImageBasedReflections, inout vec2 CompositedAverageBrightness) {\n  float iblV = (iblIndex + 0.5) * cc_ibl_cluster_InfoTextureInvSize.y;\n  vec4 posRange = texture(cc_ibl_cluster_InfoTexture, vec2(0.5 * cc_ibl_cluster_InfoTextureInvSize.x, iblV));\n  float iblDistance = length(MaterialParameters.AbsoluteWorldPosition - posRange.xyz);\n  float DistanceAlpha = 0.;\n  vec3 ProjectedCaptureVector = MaterialParameters.ReflectionVector;\n  if (iblDistance < posRange.w) {\n    float NormalizedDistanceToCapture = clamp(iblDistance / posRange.w, 0.0, 1.0);\n    ProjectedCaptureVector = GetLookupVectorForSphereCapture(ProjectedCaptureVector, MaterialParameters.AbsoluteWorldPosition, posRange, NormalizedDistanceToCapture, vec3(0.0), DistanceAlpha);\n  }\n  vec4 data3 = texture(cc_ibl_cluster_InfoTexture, vec2(2.5 * cc_ibl_cluster_InfoTextureInvSize.x, iblV));\n  float AverageBrightness = data3.x;\n  float brightness = data3.y;\n  vec2 uv = envMapEquirect(ProjectedCaptureVector);\n  vec4 uvMapping = texture(cc_ibl_cluster_InfoTexture, vec2(1.5 * cc_ibl_cluster_InfoTextureInvSize.x, iblV));\n  vec2 scaleUV = vec2(uvMapping.z, uvMapping.w * 0.5);\n  vec2 rgbUV = uvMapping.xy + scaleUV * uv;\n  vec2 aUV = uvMapping.xy + scaleUV * vec2(uv.x, uv.y + 1.);\n  vec4 SpecularIBL = decodeCCRGBE(fragTextureLod(cc_ibl_cluster_CubemapAtlas, rgbUV, mip));\n  float pixelBrightness = decodeCCRGBE(fragTextureLod(cc_ibl_cluster_CubemapAtlas, aUV, mip)).r;\n  ImageBasedReflections.rgb += SpecularIBL.rgb * brightness * DistanceAlpha * ImageBasedReflections.a;\n  ImageBasedReflections.a *= 1. - (pixelBrightness * DistanceAlpha);\n  CompositedAverageBrightness.x += AverageBrightness * DistanceAlpha * CompositedAverageBrightness.y;\n  CompositedAverageBrightness.y *= 1. - DistanceAlpha;\n}\nvoid EvalCluster (float clusterU, float clusterV, in FMaterialPixelParameters MaterialParameters, float mip, float IndirectIrradiance, inout vec4 ImageBasedReflections, vec2 CompositedAverageBrightness) {\n  #if CC_IBL_MaxPixelsPerCell\n    int calcedIblCount = 0;\n    for (float pixelIndex = 0.5; pixelIndex < float(CC_IBL_MaxPixelsPerCell); pixelIndex++) {\n      vec4 iblIndices = texture(cc_ibl_cluster_Texture, vec2(cc_ibl_cluster_TextureSize.y * (clusterU + pixelIndex), clusterV));\n      vec4 indices = iblIndices * 255.0;\n      for (int e = 0; e < 4; e++) {\n        float iblIndex = indices[e];\n        if (iblIndex <= 0.0)\n          break;\n          EvaluateClusterIBL(iblIndex, MaterialParameters, mip, IndirectIrradiance, ImageBasedReflections, CompositedAverageBrightness);\n      }\n    }\n  #endif\n}\nfloat GetSpecularOcclusion(float NoV, float RoughnessSq, float AO)\n{\n  return clamp(pow( NoV + AO, RoughnessSq ) - 1. + AO, 0.0, 1.0);\n}\nvec3 GetOffSpecularPeakReflectionDir(vec3 Normal, vec3 ReflectionVector, float Roughness)\n{\n  float a = Square(Roughness);\n  return mix( Normal, ReflectionVector, (1. - a) * ( sqrt(1. - a) + a ) );\n}\nuniform sampler2D cc_planar_reflection_Texture;\nvec4 GetPlanarReflection (FMaterialPixelParameters MaterialParameters, GlobalView View) {\n  vec4 planarReflection = vec4(0.);\n  float DistanceFade = 1. - clamp(abs(MaterialParameters.AbsoluteWorldPosition.y) / 0.01, 0.0, 1.0);\n  if (DistanceFade > 0.) {\n    vec3 CameraToPixel = -MaterialParameters.CameraVector;\n    vec3 MirroredCameraVector = reflect(CameraToPixel, -cc_view_pr_reflectionPlane.xyz);\n    vec3 MirroredNormal = (cc_view_inverse_transpose_mirror * vec4(MaterialParameters.WorldNormal, 0.)).xyz;\n    vec3 MirroredReflectionVectorOffNormal = reflect(MirroredCameraVector, MirroredNormal);\n    vec3 VirtualReflectionSpherePosition = MaterialParameters.AbsoluteWorldPosition + MirroredReflectionVectorOffNormal * cc_view_pr_parameters.z;\n    vec2 screenUV = posWS2screen(VirtualReflectionSpherePosition.rgb).xy;\n    planarReflection = texture(cc_planar_reflection_Texture, screenUV);\n    planarReflection.a *= DistanceFade;\n    planarReflection.rgb /= View.PreExposure;\n  }\n  return planarReflection;\n}\nvec3 GetImageBasedReflectionLighting(FMaterialPixelParameters MaterialParameters, FPixelMaterialInputs ShadingModelContext, float IndirectIrradiance, GlobalView View) {\n  float Roughness = ShadingModelContext.Roughness;\n  float RoughnessSq = Roughness * Roughness;\n  float NoV = max(dot(MaterialParameters.WorldNormal, MaterialParameters.CameraVector), 0.);\n  float AO = ShadingModelContext.AmbientOcclusion;\n  float SpecularOcclusion = GetSpecularOcclusion(NoV, RoughnessSq, AO);\n  vec2 CompositedAverageBrightness = vec2(0.0, 1.0);\n  vec4 ImageBasedReflections = vec4(vec3(0.), SpecularOcclusion);\n  vec3 ReflectionVector = 2. * dot( MaterialParameters.CameraVector, MaterialParameters.WorldNormal ) * MaterialParameters.WorldNormal - MaterialParameters.CameraVector;\n  ReflectionVector = GetOffSpecularPeakReflectionDir(MaterialParameters.WorldNormal, ReflectionVector, Roughness);\n  MaterialParameters.ReflectionVector = ReflectionVector;\n  if (ImageBasedReflections.a > 0.) {\n    vec4 planarReflection = GetPlanarReflection(MaterialParameters, View);\n    ImageBasedReflections.rgb += planarReflection.rgb * ImageBasedReflections.a;\n    ImageBasedReflections.a -= planarReflection.a;\n  }\n  vec3 cellCoords = floor((MaterialParameters.AbsoluteWorldPosition - cc_ibl_cluster_BoundsMin.xyz) * cc_ibl_cluster_CellsCountByBoundsSizeAndPixelsPerCell.xyz);\n  if (ImageBasedReflections.a <= 0. || (cellCoords.x < 0.) || (cellCoords.y < 0.) || (cellCoords.z < 0.) ||\n      (cellCoords.x > cc_ibl_cluster_CellsMax.x) || (cellCoords.y > cc_ibl_cluster_CellsMax.y) || (cellCoords.z > cc_ibl_cluster_CellsMax.z)) {\n  }\n  else {\n    float mip = ComputeReflectionCaptureMipFromRoughness(Roughness, 7.000001);\n    float cellIndex = dot(cc_ibl_cluster_CellsDot.xyz, cellCoords);\n    float clusterV = floor(cellIndex * cc_ibl_cluster_TextureSize.y);\n    float clusterU = floor(cellIndex - (clusterV * cc_ibl_cluster_TextureSize.x));\n    clusterV = (clusterV + 0.5) * cc_ibl_cluster_TextureSize.z;\n    EvalCluster(clusterU, clusterV, MaterialParameters, mip, IndirectIrradiance, ImageBasedReflections, CompositedAverageBrightness);\n  }\n  ImageBasedReflections.rgb *= View.IndirectLightingColorScale;\n  CompositedAverageBrightness.x *= Luminance( View.IndirectLightingColorScale );\n  if (ImageBasedReflections.a > 0.) {\n    float SkyAverageBrightness = 1.;\n    vec3 SkyLighting = GetSkyLightReflection(ReflectionVector, Roughness, SkyAverageBrightness);\n    ImageBasedReflections.rgb += ImageBasedReflections.a * SkyLighting;\n    CompositedAverageBrightness.x += SkyAverageBrightness * CompositedAverageBrightness.y;\n      ImageBasedReflections.rgb *= ComputeMixingWeight(IndirectIrradiance, CompositedAverageBrightness.x, Roughness);\n  }\n    vec3 brdf = EnvBRDFApprox(ShadingModelContext.SpecularColor, Roughness, NoV);\n  ImageBasedReflections.rgb *= brdf;\n  return ImageBasedReflections.rgb;\n}\n#if (CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD)\n    in vec3 v_luv;\n    uniform sampler2D cc_lightingMap;\n    #if USE_INSTANCING\n      in vec4 v_lightingMapAdds0;\n      in vec4 v_lightingMapAdds1;\n      in vec4 v_lightingMapScales0;\n      in vec4 v_lightingMapScales1;\n      void getLightingMapVectors (out vec4 lightingMapAdds0, out vec4 lightingMapAdds1, out vec4 lightingMapScales0, out vec4 lightingMapScales1) {\n        lightingMapAdds0 = v_lightingMapAdds0;\n        lightingMapAdds1 = v_lightingMapAdds1;\n        lightingMapScales0 = v_lightingMapScales0;\n        lightingMapScales1 = v_lightingMapScales1;\n      }\n    #endif\n    vec4 GetLightMapColorLQ( vec2 LightmapUV0, vec2 LightmapUV1, vec3 WorldNormal ) {\n      vec4 lightingMapAdds0 = vec4(0.);\n      vec4 lightingMapAdds1 = vec4(0.);\n      vec4 lightingMapScales0 = vec4(1.);\n      vec4 lightingMapScales1 = vec4(1.);\n      #if USE_INSTANCING\n        getLightingMapVectors(lightingMapAdds0, lightingMapAdds1, lightingMapScales0, lightingMapScales1);\n      #endif\n      vec4 Lightmap0 = texture( cc_lightingMap, LightmapUV0 );\n      vec3 LogRGB = Lightmap0.rgb * lightingMapScales0.xyz + lightingMapAdds0.xyz;\n      float LogL = Luminance( LogRGB );\n      const float LogBlackPoint = 0.00390625;\n      float L = exp2( LogL * 16. - 8. ) - LogBlackPoint;\n      float Directionality = 0.6;\n      float Luma = L * Directionality;\n      vec3 Color = LogRGB * (Luma / LogL);\n      return vec4( Color, Luma );\n    }\n#endif\nvec4 GetLightMapColor (vec3 worldNormal) {\n  vec4 lightmapColor =  vec4(vec3(0.), 0.);\n    #if (CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD)\n      vec2 LightmapUV0 = v_luv.xy * vec2( 1., 0.5 );\n      vec2 LightmapUV1 = LightmapUV0 + vec2( 0., 0.5 );\n        lightmapColor = GetLightMapColorLQ(LightmapUV0, LightmapUV1, worldNormal);\n    #endif\n  return lightmapColor;\n}\nvec4 lightingBase (FPixelMaterialInputs ShadingModelContext, FMaterialPixelParameters MaterialParameters, GlobalView View, vec4 shadowPos) {\n  vec3 Color = vec3(0);\n  #if CC_Lighting_Heavily\n    Color += vec3(0.1, 0, 0);\n  #else\n    vec3 direction = normalize(-cc_mainLitDir.xyz);\n    vec3 lightColor = cc_mainLitColor.rgb * cc_mainLitColor.w;\n    lightColor /= 3.14159265359;\n    float NoL = max(0., dot(MaterialParameters.WorldNormal, direction));\n    vec3 H = normalize(MaterialParameters.CameraVector + direction);\n    float NoH = max(0., dot(MaterialParameters.WorldNormal, H));\n    float Shadow = 1.;\n    #if CC_RECEIVE_SHADOW\n        {\n          vec4 pos = ApplyShadowDepthBias_FaceNormal(shadowPos, MaterialParameters.WorldNormal);\n          float pcf = cc_shadowWHPBInfo.z;\n          if (pcf > 1.9) Shadow = CCGetShadowFactorSoft2X(pos);\n          else if (pcf > 0.9) Shadow = CCGetShadowFactorSoft(pos);\n          else Shadow = CCGetShadowFactorHard(pos);\n          Shadow = mix(Shadow, 1.0, cc_shadowNFLSInfo.w);\n        }\n    #endif\n    FDirectLighting Lighting = MobileIntegrateBxDF(ShadingModelContext, MaterialParameters.WorldNormal, H, NoH);\n    Color += (Shadow * NoL) * lightColor * (Lighting.Diffuse + Lighting.Specular );\n    float IndirectIrradiance = MaterialParameters.IndirectIrradiance;\n    #if CC_ENABLE_IBL\n      vec3 SpecularIBL = GetImageBasedReflectionLighting(MaterialParameters, ShadingModelContext, IndirectIrradiance, View);\n      Color += SpecularIBL;\n    #endif\n    Color += ShadingModelContext.EmissiveColor;\n  #endif\n  return vec4(Color, ShadingModelContext.Opacity);\n}\nvec3 transmission (vec3 N, vec3 V, vec3 L, float Falloff, vec3 SubsurfaceColor) {\n    float Wrap = 0.5;\n    float WrapAddOne = ( 1. + Wrap );\n    float WrapNoL = clamp(( -dot(N, L) + Wrap ) / ( WrapAddOne * WrapAddOne ), 0.0, 1.0);\n    float VoL = dot(V, L);\n    float Scatter = D_GGX( 0.6*0.6, clamp(-VoL, 0.0, 1.0) );\n    return SubsurfaceColor * WrapNoL * Scatter * cc_mainLitColor.rgb * cc_mainLitColor.w;\n}\nvoid lightingPerObject (inout FMaterialPixelParameters Parameters, inout FPixelMaterialInputs PixelMaterialInputs) {\n    PixelMaterialInputs.EmissiveColor += transmission(\n      Parameters.WorldNormal,\n      Parameters.CameraVector,\n      normalize(-cc_mainLitDir.xyz), 1.,\n      PixelMaterialInputs.Subsurface\n    );\n  #if !(CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD)\n    vec3 DiffuseLookup = GetSkySHDiffuseSimple(Parameters.WorldNormal) * cc_view_SkyColor.rgb;\n    vec3 DiffuseColor = PixelMaterialInputs.BaseColor - PixelMaterialInputs.BaseColor * PixelMaterialInputs.Metallic;\n    PixelMaterialInputs.EmissiveColor += DiffuseLookup * PixelMaterialInputs.AmbientOcclusion * DiffuseColor;\n    if (PixelMaterialInputs.TwoSidedSign < 0.) {\n      vec3 BackfaceDiffuseLookup = GetSkySHDiffuseSimple(Parameters.WorldNormal * PixelMaterialInputs.TwoSidedSign);\n      PixelMaterialInputs.EmissiveColor += BackfaceDiffuseLookup * PixelMaterialInputs.Subsurface;\n    }\n  #endif\n}\n#if CC_FORWARD_ADD\n#if CC_PIPELINE_TYPE == 0\n# define LIGHTS_PER_PASS 1\n#else\n# define LIGHTS_PER_PASS 10\n#endif\n#if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\nlayout(std140) uniform CCForwardLight {\n  highp vec4 cc_lightPos[LIGHTS_PER_PASS];\n  vec4 cc_lightColor[LIGHTS_PER_PASS];\n  vec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];\n  vec4 cc_lightDir[LIGHTS_PER_PASS];\n};\n#endif\n#endif\nfloat SpotAttenuationMask(vec3 L, vec3 SpotDirection, vec2 SpotAngles)\n{\n  return clamp((dot(L, -SpotDirection) - SpotAngles.x) * SpotAngles.y, 0.0, 1.0);\n}\nfloat SpotAttenuation(vec3 L, vec3 SpotDirection, vec2 SpotAngles)\n{\n  float ConeAngleFalloff = Square(SpotAttenuationMask(L, SpotDirection, SpotAngles));\n  return ConeAngleFalloff;\n}\nvoid lightingAddPerLight(\n  in FPixelMaterialInputs ShadingModelContext, in FMaterialPixelParameters MaterialParameters,\n  vec3 pos, bool isSpotLight,\n  vec3 lightColor, float intensity,\n  float range, float spotAngle,\n  vec3 dir,\n  vec4 shadowPos,\n  inout vec3 outColor) {\n  vec3 toLight = pos - MaterialParameters.AbsoluteWorldPosition;\n  float distanceSqr = dot(toLight, toLight);\n  vec3 L = toLight * rsqrt(distanceSqr);\n  vec3 PointH = normalize(MaterialParameters.CameraVector + L);\n  float PointNoL = max(0., dot(MaterialParameters.WorldNormal, L));\n  float PointNoH = max(0., dot(MaterialParameters.WorldNormal, PointH));\n  float Attenuation;\n  {\n    Attenuation = 1. / ( distanceSqr + 0.01 );\n    float InvRadius = 1.0 / max(range, 0.01);\n    float LightRadiusMask = Square(clamp(1. - Square(distanceSqr * (InvRadius * InvRadius)), 0.0, 1.0));\n    Attenuation *= LightRadiusMask;\n  }\n  if (isSpotLight) {\n    vec3 SL = normalize(toLight);\n    float cosInner = 1.;\n    float cosOuter = spotAngle;\n    float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\n    vec2 SpotAngles = vec2(cosOuter, litAngleScale);\n    Attenuation *= SpotAttenuation(L, dir, SpotAngles);\n    float shadow = 1.;\n    #if CC_RECEIVE_SHADOW\n        {\n          vec4 pos = ApplyShadowDepthBias_FaceNormal(shadowPos, MaterialParameters.WorldNormal);\n          float pcf = cc_shadowWHPBInfo.z;\n          if (pcf > 1.9) shadow = CCGetShadowFactorSoft2X(pos);\n          else if (pcf > 0.9) shadow = CCGetShadowFactorSoft(pos);\n          else shadow = CCGetShadowFactorHard(pos);\n          shadow = mix(shadow, 1.0, cc_shadowNFLSInfo.w);\n        }\n    #endif\n    lightColor *= shadow;\n  }\n  FDirectLighting Lighting = MobileIntegrateBxDF(ShadingModelContext, MaterialParameters.WorldNormal, PointH, PointNoH);\n  outColor += min(vec3(65000.0), (Attenuation * PointNoL) * lightColor * intensity / 3.14159265359 * (Lighting.Diffuse + Lighting.Specular));\n}\nuniform sampler2D cc_light_cluster_InfoTexture;\nuniform sampler2D cc_light_cluster_Texture;\nvoid lightingCluster(float clusterIndex, in FPixelMaterialInputs ShadingModelContext, in FMaterialPixelParameters MaterialParameters, vec4 shadowPos, inout vec3 outColor) {\n  #if CC_Lighting_Heavily\n    outColor += vec3(0.1, 0, 0);\n  #else\n    float iblV = (clusterIndex + 0.5) * cc_light_cluster_InfoTextureInvSize.y;\n    vec4 lightPos = texture(cc_light_cluster_InfoTexture, vec2(0.5 * cc_light_cluster_InfoTextureInvSize.x, iblV));\n    vec4 lightColor = texture(cc_light_cluster_InfoTexture, vec2(1.5 * cc_light_cluster_InfoTextureInvSize.x, iblV));\n    vec4 lightSizeRangeAngle = texture(cc_light_cluster_InfoTexture, vec2(2.5 * cc_light_cluster_InfoTextureInvSize.x, iblV));\n    vec4 lightDir = texture(cc_light_cluster_InfoTexture, vec2(3.5 * cc_light_cluster_InfoTextureInvSize.x, iblV));\n    lightingAddPerLight(\n      ShadingModelContext, MaterialParameters,\n      lightPos.xyz, lightPos.w > 0.0,\n      lightColor.rgb, lightColor.w,\n      lightSizeRangeAngle.y, lightSizeRangeAngle.z,\n      lightDir.xyz,\n      shadowPos,\n      outColor\n    );\n  #endif\n}\n#if CC_ENABLE_CLUSTERED_LIGHT_CULLING && CC_ENABLE_Builtin_CLUSTERED_LIGHT_CULLING\n  float SmoothDistAtt (float distSqr, float invSqrAttRadius) {\n    float factor = distSqr * invSqrAttRadius;\n    float smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\n    return smoothFactor * smoothFactor;\n  }\n  float GetDistAtt (float distSqr, float invSqrAttRadius) {\n    float attenuation = 1.0 / max(distSqr, 0.01*0.01);\n    attenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\n    return attenuation;\n  }\n  float GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\n    float cd = dot(litDir, L);\n    float attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\n    return (attenuation * attenuation);\n  }\n  #if CC_USE_IBL\n    uniform samplerCube cc_environment;\n    #if CC_USE_DIFFUSEMAP\n      uniform samplerCube cc_diffuseMap;\n    #endif\n  #endif\n  float GGXMobile (float roughness, float NoH, vec3 H, vec3 N) {\n    vec3 NxH = cross(N, H);\n    float OneMinusNoHSqr = dot(NxH, NxH);\n    float a = roughness * roughness;\n    float n = NoH * a;\n    float p = a / (OneMinusNoHSqr + n * n);\n    return p * p;\n  }\n  float CalcSpecular (float roughness, float NoH, vec3 H, vec3 N) {\n    return (roughness * 0.25 + 0.25) * GGXMobile(roughness, NoH, H, N);\n  }\n  vec3 BRDFApprox (vec3 specular, float roughness, float NoV) {\n    const vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);\n    const vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);\n    vec4 r = roughness * c0 + c1;\n    float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\n    vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\n    AB.y *= clamp(50.0 * specular.g, 0.0, 1.0);\n    return specular * AB.x + AB.y;\n  }\n  #if USE_REFLECTION_DENOISE\n  #endif\n  struct StandardSurface {\n    vec4 albedo;\n    vec3 position;\n    vec3 normal;\n    vec3 emissive;\n    vec3 lightmap;\n    float lightmap_test;\n    float roughness;\n    float metallic;\n    float occlusion;\n  };\n  layout(std430, binding = 4) readonly buffer b_ccLightsBuffer { vec4 b_ccLights[]; };\n  layout(std430, binding = 5) readonly buffer b_clusterLightIndicesBuffer { uint b_clusterLightIndices[]; };\n  layout(std430, binding = 6) readonly buffer b_clusterLightGridBuffer { uvec4 b_clusterLightGrid[]; };\n  struct CCLight\n  {\n    vec4 cc_lightPos;\n    vec4 cc_lightColor;\n    vec4 cc_lightSizeRangeAngle;\n    vec4 cc_lightDir;\n  };\n  struct Cluster\n  {\n    vec3 minBounds;\n    vec3 maxBounds;\n  };\n  struct LightGrid\n  {\n    uint offset;\n    uint ccLights;\n  };\n  CCLight getCCLight(uint i)\n  {\n    CCLight light;\n    light.cc_lightPos = b_ccLights[4u * i + 0u];\n    light.cc_lightColor = b_ccLights[4u * i + 1u];\n    light.cc_lightSizeRangeAngle = b_ccLights[4u * i + 2u];\n    light.cc_lightDir = b_ccLights[4u * i + 3u];\n    return light;\n  }\n  LightGrid getLightGrid(uint cluster)\n  {\n    uvec4 gridvec = b_clusterLightGrid[cluster];\n    LightGrid grid;\n    grid.offset = gridvec.x;\n    grid.ccLights = gridvec.y;\n    return grid;\n  }\n  uint getGridLightIndex(uint start, uint offset)\n  {\n    return b_clusterLightIndices[start + offset];\n  }\n  uint getClusterZIndex(vec4 worldPos)\n  {\n    float scale = float(24) / log(cc_nearFar.y / cc_nearFar.x);\n    float bias = -(float(24) * log(cc_nearFar.x) / log(cc_nearFar.y / cc_nearFar.x));\n    float eyeDepth = -(cc_matView * worldPos).z;\n    uint zIndex = uint(max(log(eyeDepth) * scale + bias, 0.0));\n    return zIndex;\n  }\n  uint getClusterIndex(vec4 fragCoord, vec4 worldPos)\n  {\n    uint zIndex = getClusterZIndex(worldPos);\n    float clusterSizeX = ceil(cc_nativeSize.x / float(16));\n    float clusterSizeY = ceil(cc_nativeSize.y / float(8));\n    uvec3 indices = uvec3(uvec2(fragCoord.xy / vec2(clusterSizeX, clusterSizeY)), zIndex);\n    uint cluster = (16u * 8u) * indices.z + 16u * indices.y + indices.x;\n    return cluster;\n  }\n  vec4 CCClusterShadingAdditive (StandardSurface s, vec4 shadowPos) {\n    vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n    vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n    vec3 diffuseContrib = diffuse / 3.14159265359;\n    vec3 N = normalize(s.normal);\n    vec3 V = normalize(cc_cameraPos.xyz - s.position);\n    float NV = max(abs(dot(N, V)), 0.001);\n    specular = BRDFApprox(specular, s.roughness, NV);\n    vec3 finalColor = vec3(0.0);\n    uint cluster = getClusterIndex(gl_FragCoord, vec4(s.position, 1.0));\n    LightGrid grid = getLightGrid(cluster);\n    uint numLights = grid.ccLights;\n    for (uint i = 0u; i < 100u; i++) {\n      if (i >= numLights) break;\n      uint lightIndex = getGridLightIndex(grid.offset, i);\n      CCLight light = getCCLight(lightIndex);\n      vec3 SLU = light.cc_lightPos.xyz - s.position;\n      vec3 SL = normalize(SLU);\n      vec3 SH = normalize(SL + V);\n      float SNL = max(dot(N, SL), 0.001);\n      float SNH = max(dot(N, SH), 0.0);\n      float distSqr = dot(SLU, SLU);\n      float litRadius = light.cc_lightSizeRangeAngle.x;\n      float litRadiusSqr = litRadius * litRadius;\n      float illum = 3.14159265359 * (litRadiusSqr / max(litRadiusSqr , distSqr));\n      float attRadiusSqrInv = 1.0 / max(light.cc_lightSizeRangeAngle.y, 0.01);\n      attRadiusSqrInv *= attRadiusSqrInv;\n      float att = GetDistAtt(distSqr, attRadiusSqrInv);\n      vec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\n      if (light.cc_lightPos.w > 0.0) {\n        float cosInner = max(dot(-light.cc_lightDir.xyz, SL), 0.01);\n        float cosOuter = light.cc_lightSizeRangeAngle.z;\n        float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\n        float litAngleOffset = -cosOuter * litAngleScale;\n        att *= GetAngleAtt(SL, -light.cc_lightDir.xyz, litAngleScale, litAngleOffset);\n      }\n      vec3 lightColor = light.cc_lightColor.rgb;\n      float shadow = 1.0;\n      #if CC_RECEIVE_SHADOW\n        if (light.cc_lightPos.w > 0.0) {\n            {\n              float pcf = cc_shadowWHPBInfo.z;\n              if (pcf > 1.9) shadow = CCGetSpotLightShadowFactorSoft2X(shadowPos, s.position);\n              else if (pcf > 0.9) shadow = CCGetSpotLightShadowFactorSoft(shadowPos, s.position);\n              else shadow = CCGetSpotLightShadowFactorHard(shadowPos, s.position);\n            }\n        }\n      #endif\n      lightColor *= shadow;\n      finalColor += SNL * lightColor * light.cc_lightColor.w * illum * att * (diffuseContrib + lspec);\n    }\n    return vec4(finalColor, 0.0);\n  }\n#endif\nvec4 lightingAdd (in FPixelMaterialInputs ShadingModelContext, in FMaterialPixelParameters MaterialParameters, vec4 shadowPos) {\n  vec3 color = vec3(0.);\n  #if CC_ENABLE_CLUSTERED_LIGHT_CULLING && CC_ENABLE_Builtin_CLUSTERED_LIGHT_CULLING\n    StandardSurface s;\n    s.albedo.xyz = ShadingModelContext.BaseColor;\n    s.albedo.w = ShadingModelContext.Opacity;\n    s.metallic = ShadingModelContext.Metallic;\n    s.roughness = ShadingModelContext.Roughness;\n    s.normal = MaterialParameters.WorldNormal;\n    s.position = MaterialParameters.AbsoluteWorldPosition;\n    color = CCClusterShadingAdditive(s, shadowPos).rgb;\n  #else\n  vec3 cellCoords = floor((MaterialParameters.AbsoluteWorldPosition - cc_light_cluster_BoundsMin.xyz) * cc_light_cluster_CellsCountByBoundsSizeAndPixelsPerCell.xyz);\n  if ((cellCoords.x < 0.) || (cellCoords.y < 0.) || (cellCoords.z < 0.) ||\n      (cellCoords.x > cc_light_cluster_CellsMax.x) ||\n      (cellCoords.y > cc_light_cluster_CellsMax.y) ||\n      (cellCoords.z > cc_light_cluster_CellsMax.z)) {\n  }\n  else {\n    float cellIndex = dot(cc_light_cluster_CellsDot.xyz, cellCoords);\n    float clusterV = floor(cellIndex * cc_light_cluster_TextureSize.y);\n    float clusterU = cellIndex - (clusterV * cc_light_cluster_TextureSize.x);\n    clusterV = (clusterV + 0.5) * cc_light_cluster_TextureSize.z;\n    #if CC_LIGHT_MaxPixelsPerCell\n    for (float cellIndex = 0.5; cellIndex < float(CC_LIGHT_MaxPixelsPerCell); cellIndex++) {\n      vec4 lightIndices = texture(cc_light_cluster_Texture, vec2(cc_light_cluster_TextureSize.y * (clusterU + cellIndex), clusterV));\n      vec4 indices = lightIndices * 255.0;\n      for (int e = 0; e < 4; e++) {\n        if (indices[e] <= 0.0) {\n          break;\n        }\n        lightingCluster(indices[e], ShadingModelContext, MaterialParameters, shadowPos, color);\n      }\n      if (cellIndex > cc_light_cluster_CellsCountByBoundsSizeAndPixelsPerCell.w) {\n        break;\n      }\n    }\n    #endif\n  }\n  #endif\n  return vec4(color, ShadingModelContext.Opacity);\n}\nvoid InitShadingModelContext(inout FPixelMaterialInputs ShadingModelContext, FMaterialPixelParameters MaterialParameters) {\n  ShadingModelContext.RoughnessWithClamp = max(0.015625, ShadingModelContext.Roughness);\n  float NoV = max(dot(MaterialParameters.WorldNormal, MaterialParameters.CameraVector), 0.);\n  float DielectricSpecular = 0.08 * ShadingModelContext.Specular;\n  ShadingModelContext.DiffuseColor = ShadingModelContext.BaseColor - ShadingModelContext.BaseColor * ShadingModelContext.Metallic;\n  ShadingModelContext.SpecularColor = mix(0.08 * vec3(ShadingModelContext.Specular), ShadingModelContext.BaseColor, ShadingModelContext.Metallic);\n}\nvec4 lighting (FPixelMaterialInputs ShadingModelContext, FMaterialPixelParameters MaterialParameters, GlobalView View, vec4 shadowPos) {\n  vec4 color = vec4(vec3(0.), 1.);\n    #if CC_ENABLE_LIGHTING_BASE\n      color = lightingBase(ShadingModelContext, MaterialParameters, View, shadowPos);\n    #endif\n    #if CC_ENABLE_LIGHTING_ADD && (0 || 1)\n      color += lightingAdd(ShadingModelContext, MaterialParameters, shadowPos);\n    #endif\n  color *= ShadingModelContext.AmbientOcclusion;\n  return color;\n}\n#if CC_FORWARD_ADD\n#endif\nvec4 forward () {\n  FMaterialPixelParameters Parameters;\n  FPixelMaterialInputs PixelMaterialInputs;\n  GlobalView View;\n  surf(PixelMaterialInputs, Parameters, View);\n  lightingPerObject(Parameters, PixelMaterialInputs);\n  InitShadingModelContext(PixelMaterialInputs, Parameters);\n  vec4 color = lighting(PixelMaterialInputs, Parameters, View, v_shadowPos);\n  vec4 fogColor = CalculateHeightFog(Parameters.AbsoluteWorldPosition.xyz - cc_cameraPos.xyz);\n  color.rgb = color.rgb * fogColor.a + fogColor.rgb;\n  color.rgb *= View.PreExposure;\n  return color;\n}\nvoid deferred (out vec4 color0, out vec4 color1, out vec4 color2, out vec4 color3) {\n  FMaterialPixelParameters Parameters;\n  FPixelMaterialInputs PixelMaterialInputs;\n  GlobalView View;\n  surf(PixelMaterialInputs, Parameters, View);\n  lightingPerObject(Parameters, PixelMaterialInputs);\n  PixelMaterialInputs.DiffuseColor = max(PixelMaterialInputs.BaseColor - PixelMaterialInputs.BaseColor * PixelMaterialInputs.Metallic, 0.);\n  color0 = vec4(PixelMaterialInputs.BaseColor, PixelMaterialInputs.Opacity);\n  color1 = vec4(Parameters.AbsoluteWorldPosition, PixelMaterialInputs.Roughness);\n  color2 = vec4(Parameters.WorldNormal, PixelMaterialInputs.Metallic);\n  vec3 color = vec3(0.);\n  vec4 lightmapColor = GetLightMapColor(Parameters.WorldNormal);\n  Parameters.IndirectIrradiance += lightmapColor.a;\n  color += lightmapColor.xyz * PixelMaterialInputs.DiffuseColor * View.IndirectLightingColorScale;\n  color += PixelMaterialInputs.EmissiveColor;\n  color3 = vec4(color, Parameters.IndirectIrradiance * PixelMaterialInputs.AmbientOcclusion);\n}\n#if CC_TRANSPARENT || (CC_PIPELINE_TYPE == 0)\n  layout(location = 0) out vec4 fragColor0;\n  void main () {\n    fragColor0 = forward();\n  }\n#elif CC_PIPELINE_TYPE == 1\n  layout(location = 0) out vec4 fragColor0;\n  layout(location = 1) out vec4 fragColor1;\n  layout(location = 2) out vec4 fragColor2;\n  layout(location = 3) out vec4 fragColor3;\n  void main () {\n    deferred(fragColor0, fragColor1, fragColor2, fragColor3);\n  }\n#endif"},"glsl1":{"vert":"\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\nattribute vec4 a_tangent;\n#if CC_USE_MORPH\n    attribute float a_vertexId;\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n  uniform vec4 cc_displacementWeights[15];\n  uniform vec4 cc_displacementTextureInfo;\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n        int pixelIndex = elementIndex;\n        vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n        vec2 uv = getPixelCoordFromLocation(location, cc_displacementTextureInfo.xy);\n        return texture2D(tex, uv);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture2D(tex, x)),\n        decode32(texture2D(tex, y)),\n        decode32(texture2D(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout StandardVertInput attr) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    attr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    attr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    attr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n    attribute vec4 a_joints;\n  attribute vec4 a_weights;\n  #if CC_USE_BAKED_ANIMATION\n    #if USE_INSTANCING\n      attribute highp vec4 a_jointAnimInfo;\n    #endif\n    uniform highp vec4 cc_jointTextureInfo;\n    uniform highp vec4 cc_jointAnimInfo;\n    uniform highp sampler2D cc_jointTexture;\n      #else\n    uniform highp vec4 cc_joints[90];\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout StandardVertInput attr) {\n    mat4 m = skinMatrix();\n    attr.position = m * attr.position;\n    attr.normal = (m * vec4(attr.normal, 0.0)).xyz;\n    attr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n  }\n#endif\nuniform highp vec4 cc_time;\nuniform highp mat4 cc_matView;\n  uniform highp mat4 cc_matProj;\n  uniform highp vec4 cc_cameraPos;\n#if USE_INSTANCING\n  attribute vec4 a_matWorld0;\n  attribute vec4 a_matWorld1;\n  attribute vec4 a_matWorld2;\n  #if CC_USE_LIGHTMAP\n    attribute vec4 a_lightingMapUVParam;\n  #endif\n#elif USE_BATCHING\n  attribute float a_dyn_batch_id;\n  uniform highp mat4 cc_matWorlds[10];\n#else\n  uniform highp mat4 cc_matWorld;\n  uniform highp mat4 cc_matWorldIT;\n  uniform highp vec4 cc_lightingMapUVParam;\n#endif\nvarying highp vec4 v_shadowPos;\nuniform highp mat4 cc_matLightViewProj;\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotLightingMap;\n#endif\n#if CC_USE_ATTR_COLOR\nattribute vec4 a_color;\nvarying vec4 v_color;\n#endif\nvarying vec3 v_obj_position;\nvarying vec3 v_position;\nvarying vec3 v_normal;\nvarying vec2 v_uv;\nvarying vec3 v_tangent;\nvarying vec3 v_bitangent;\nattribute vec2 a_texCoord1;\nvarying vec2 v_uv1;\n#if (CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD)\n    #if USE_INSTANCING\n      attribute vec4 a_lightingMapAdds0;\n      attribute vec4 a_lightingMapAdds1;\n      attribute vec4 a_lightingMapScales0;\n      attribute vec4 a_lightingMapScales1;\n      varying vec4 v_lightingMapAdds0;\n      varying vec4 v_lightingMapAdds1;\n      varying vec4 v_lightingMapScales0;\n      varying vec4 v_lightingMapScales1;\n      void getLightingMapVectors () {\n        v_lightingMapAdds0 = a_lightingMapAdds0;\n        v_lightingMapAdds1 = a_lightingMapAdds1;\n        v_lightingMapScales0 = a_lightingMapScales0;\n        v_lightingMapScales1 = a_lightingMapScales1;\n      }\n    #endif\n    varying vec3 v_luv;\n    void CCLightingMapCaclUV()\n    {\n    #if !USE_INSTANCING\n      v_luv.xy = cc_lightingMapUVParam.xy + a_texCoord1 * cc_lightingMapUVParam.zw;\n      v_luv.z = cc_lightingMapUVParam.z;\n    #else\n      v_luv.xy = a_lightingMapUVParam.xy + a_texCoord1 * a_lightingMapUVParam.zw;\n      v_luv.z = a_lightingMapUVParam.z;\n    #endif\n    }\n#endif\nuniform vec4 cc_view_taa_params1;\nstruct GlobalView {\n    vec3 IndirectLightingColorScale;\n    float PreExposure;\n};\n  #ifdef GL_OES_standard_derivatives\n  #else\n  #endif\nvoid sincos0(float a, out float s, out float c)\n{\n  s = sin(a);\n  c = cos(a);\n}\nstruct Light {\n  vec3 color;\n  vec3 direction;\n};\nstruct FDirectLighting\n{\n  vec3 Diffuse;\n  vec3 Specular;\n};\nstruct FPixelMaterialInputs\n{\n  vec3 Normal;\n  vec3 EmissiveColor;\n  float Opacity;\n  float OpacityMask;\n  vec3 BaseColor;\n  float Metallic;\n  float Specular;\n  float Roughness;\n  float AmbientOcclusion;\n  float Anisotropy;\n  float Tangent;\n  float Refraction;\n  float PixelDepthOffset;\n  float ShadingModel;\n  float TwoSidedSign;\n  float RoughnessWithClamp;\n  vec3 DiffuseColor;\n  vec3 SpecularColor;\n  vec3 Subsurface;\n};\nstruct FMaterialPixelParameters {\n  float IndirectIrradiance;\n  vec2 TexCoords_0;\n  vec2 TexCoords_1;\n  vec4 VertexColor;\n  vec3 WorldNormal;\n  vec3 WorldTangent;\n  vec3 ReflectionVector;\n  vec3 CameraVector;\n  vec3 LightVector;\n  vec4 SvPosition;\n  vec4 ScreenPosition;\n  mat3 TangentToWorld;\n  vec3 AbsoluteWorldPosition;\n  vec3 ObjectWorldPosition;\n  vec2 LightmapUVs;\n  int PrimitiveId;\n};\nstruct FMaterialVertexParameters {\n  vec3 WorldPosition;\n  vec4 VertexColor;\n};\n  vec3 RotateAboutAxis(vec4 NormalizedRotationAxisAndAngle, vec3 PositionOnAxis, vec3 Position) {\n      vec3 ClosestPointOnAxis = (PositionOnAxis + vec3 ((NormalizedRotationAxisAndAngle * dot(vec3 (NormalizedRotationAxisAndAngle), (Position - PositionOnAxis)))));\n      vec3 UAxis = (Position - ClosestPointOnAxis);\n      vec3 VAxis = cross(vec3 (NormalizedRotationAxisAndAngle), UAxis);\n      float CosAngle;\n      float SinAngle;\n      sincos0((NormalizedRotationAxisAndAngle).w, SinAngle, CosAngle);\n      vec3 R = ((UAxis * CosAngle) + (VAxis * SinAngle));\n      vec3 RotatedPosition = (ClosestPointOnAxis + R);\n      return (RotatedPosition - Position);\n  }\n  vec3 GetWorldPosition(FMaterialPixelParameters Parameters) {\n      return (Parameters).AbsoluteWorldPosition;\n  }\n  vec3 GetWorldPosition(FMaterialVertexParameters Parameters) {\n      return (Parameters).WorldPosition;\n  }\n  vec3 GetPrevWorldPosition(FMaterialVertexParameters Parameters) {\n      return (Parameters).WorldPosition;\n  }\n   vec4 F4_0101 = vec4(0, 1, 0, 1);\n  vec3 GetMaterialWorldPositionOffset(FMaterialVertexParameters Parameters) {\n    float Local0 = (cc_time.x * 0.250000);\n    float Local1 = (Local0 * (-0.500000));\n    float Local2 = ((F4_0101).a * Local1);\n    vec3 Local3 = (((F4_0101).rgb / sqrt(dot((F4_0101).rgb, (F4_0101).rgb))) * Local2);\n    vec3 Local4 = (GetWorldPosition(Parameters) / 1024.000000);\n    vec3 Local5 = (Local3 + Local4);\n    vec3 Local6 = (Local5 + vec3 (0.500000));\n    vec3 Local7 = fract(Local6);\n    vec3 Local8 = (Local7 * 2.000000);\n    vec3 Local9 = (Local8 + vec3 ((-1.000000)));\n    vec3 Local10 = abs(Local9);\n    vec3 Local11 = (Local10 * 2.000000);\n    vec3 Local12 = (vec3 (3.000000) - Local11);\n    vec3 Local13 = (Local12 * Local10);\n    vec3 Local14 = (Local13 * Local10);\n    float Local15 = dot(((F4_0101).rgb / sqrt(dot((F4_0101).rgb, (F4_0101).rgb))), Local14);\n    vec3 Local16 = (GetWorldPosition(Parameters) / 200.000000);\n    vec3 Local17 = (vec3 (Local2) + Local16);\n    vec3 Local18 = (Local17 + vec3 (0.500000));\n    vec3 Local19 = fract(Local18);\n    vec3 Local20 = (Local19 * 2.000000);\n    vec3 Local21 = (Local20 + vec3 ((-1.000000)));\n    vec3 Local22 = abs(Local21);\n    vec3 Local23 = (Local22 * 2.000000);\n    vec3 Local24 = (vec3 (3.000000) - Local23);\n    vec3 Local25 = (Local24 * Local22);\n    vec3 Local26 = (Local25 * Local22);\n    vec3 Local27 = (Local26 - vec3 (0.000000));\n    float Local28 = dot(Local27, Local27);\n    float Local29 = sqrt(Local28);\n    float Local30 = (Local15 + Local29);\n    float Local31 = (Local30 * 6.283185);\n    vec3 Local32 = RotateAboutAxis(vec4(cross(((F4_0101).rgb / sqrt(dot((F4_0101).rgb, (F4_0101).rgb))), vec3(0.000000, 0.000000, 1.000000)), Local31), (vec3 (0.500000) + vec3(0.000000, 0.000000, (-10.000000))), vec3(0.500000, 0.500000, 0.500000));\n    vec3 Local33 = (Local32 * ((Parameters).VertexColor).r);\n    vec3 Local34 = (Local33 * 0.100000);\n    vec3 Local35 = (Local34 + vec3 (0.500000));\n    float Local36 = (cc_time.x * 0.250000);\n    float Local37 = (Local36 * (-0.500000));\n    float Local38 = ((F4_0101).a * Local37);\n    vec3 Local39 = (((F4_0101).rgb / sqrt(dot((F4_0101).rgb, (F4_0101).rgb))) * Local38);\n    vec3 Local40 = (GetPrevWorldPosition(Parameters) / 1024.000000);\n    vec3 Local41 = (Local39 + Local40);\n    vec3 Local42 = (Local41 + vec3 (0.500000));\n    vec3 Local43 = fract(Local42);\n    vec3 Local44 = (Local43 * 2.000000);\n    vec3 Local45 = (Local44 + vec3 ((-1.000000)));\n    vec3 Local46 = abs(Local45);\n    vec3 Local47 = (Local46 * 2.000000);\n    vec3 Local48 = (vec3 (3.000000) - Local47);\n    vec3 Local49 = (Local48 * Local46);\n    vec3 Local50 = (Local49 * Local46);\n    float Local51 = dot(((F4_0101).rgb / sqrt(dot((F4_0101).rgb, (F4_0101).rgb))), Local50);\n    vec3 Local52 = (GetPrevWorldPosition(Parameters) / 200.000000);\n    vec3 Local53 = (vec3 (Local38) + Local52);\n    vec3 Local54 = (Local53 + vec3 (0.500000));\n    vec3 Local55 = fract(Local54);\n    vec3 Local56 = (Local55 * 2.000000);\n    vec3 Local57 = (Local56 + vec3 ((-1.000000)));\n    vec3 Local58 = abs(Local57);\n    vec3 Local59 = (Local58 * 2.000000);\n    vec3 Local60 = (vec3 (3.000000) - Local59);\n    vec3 Local61 = (Local60 * Local58);\n    vec3 Local62 = (Local61 * Local58);\n    vec3 Local63 = (Local62 - vec3 (0.000000));\n    float Local64 = dot(Local63, Local63);\n    float Local65 = sqrt(Local64);\n    float Local66 = (Local51 + Local65);\n    float Local67 = (Local66 * 6.283185);\n    vec3 Local68 = RotateAboutAxis(vec4(cross(((F4_0101).rgb / sqrt(dot((F4_0101).rgb, (F4_0101).rgb))), vec3(0.000000, 0.000000, 1.000000)), Local67), (vec3 (0.500000) + vec3(0.000000, 0.000000, (-10.000000))), vec3(0.500000, 0.500000, 0.500000));\n    vec3 Local69 = (Local68 * ((Parameters).VertexColor).r);\n    vec3 Local70 = (Local69 * 0.100000);\n    vec3 Local71 = (Local70 + vec3 (0.500000));\n    return Local35;\n}\nvoid main () {\n  StandardVertInput In;\n      In.position = vec4(a_position, 1.0);\n      In.normal = a_normal;\n      In.tangent = a_tangent;\n    #if CC_USE_MORPH\n      applyMorph(In);\n    #endif\n    #if CC_USE_SKINNING\n      CCSkin(In);\n    #endif\n  mat4 matWorld, matWorldIT;\n    #if USE_INSTANCING\n      matWorld = mat4(\n        vec4(a_matWorld0.xyz, 0.0),\n        vec4(a_matWorld1.xyz, 0.0),\n        vec4(a_matWorld2.xyz, 0.0),\n        vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n      );\n      matWorldIT = matWorld;\n    #elif USE_BATCHING\n      matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n      matWorldIT = matWorld;\n    #else\n      matWorld = cc_matWorld;\n      matWorldIT = cc_matWorldIT;\n    #endif\n  vec4 pos = matWorld * In.position;\n  FMaterialVertexParameters Parameters;\n  Parameters.WorldPosition = pos.xzy * 100.;\n  #if CC_USE_ATTR_COLOR\n  Parameters.VertexColor = a_color;\n  #else\n  Parameters.VertexColor = vec4(1.);\n  #endif\n  pos.xyz += GetMaterialWorldPositionOffset(Parameters).xzy / 100.;\n  v_obj_position = matWorld[3].xyz;\n  v_position = pos.xyz;\n  v_normal = normalize((matWorldIT * vec4(In.normal, 0.0)).xyz);\n  v_tangent = normalize((matWorld * vec4(In.tangent.xyz, 0.0)).xyz);\n  v_bitangent = normalize(cross(v_normal, v_tangent) * In.tangent.w);\n  v_uv = a_texCoord;\n  #if SAMPLE_FROM_RT\n      v_uv = cc_cameraPos.w > 1.0 ? vec2(v_uv.x, 1.0 - v_uv.y) : v_uv;\n  #endif\n  v_uv1 = a_texCoord1;\n  #if SAMPLE_FROM_RT\n      v_uv1 = cc_cameraPos.w > 1.0 ? vec2(v_uv1.x, 1.0 - v_uv1.y) : v_uv1;\n  #endif\n  #if CC_USE_ATTR_COLOR\n  v_color = a_color;\n  #endif\n  #if (CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD)\n    CCLightingMapCaclUV();\n    #if USE_INSTANCING\n      getLightingMapVectors();\n    #endif\n  #endif\n  v_shadowPos = cc_matLightViewProj * pos;\n  mat4 matProj = cc_matProj;\n  matProj[2][0] += cc_view_taa_params1.x;\n  matProj[2][1] += cc_view_taa_params1.y;\n  gl_Position = matProj * cc_matView * pos;\n}","frag":"\n#ifdef GL_EXT_draw_buffers\n#extension GL_EXT_draw_buffers: enable\n#endif\n#ifdef GL_EXT_shader_texture_lod\n#extension GL_EXT_shader_texture_lod: enable\n#endif\n#ifdef GL_OES_standard_derivatives\n#extension GL_OES_standard_derivatives: enable\n#endif\nprecision highp float;\n  uniform mediump vec4 cc_screenSize;\n  uniform mediump vec4 cc_nativeSize;\n  uniform highp mat4 cc_matView;\n  uniform highp mat4 cc_matViewProj;\n  uniform highp vec4 cc_cameraPos;\n  uniform mediump vec4 cc_mainLitDir;\n  uniform mediump vec4 cc_mainLitColor;\n  uniform mediump vec4 cc_nearFar;\n  uniform mat4 cc_view_inverse_transpose_mirror;\n  uniform vec4 cc_view_pr_reflectionPlane;\n  uniform vec4 cc_view_pr_parameters;\n  uniform vec4 cc_view_SkyIrradianceEnvironmentMap[7];\n  uniform vec4 cc_view_SkyColor;\n  uniform vec4 cc_view_SkyLightParameters;\n  uniform vec4 cc_view_IndirectLightingColorScale_Intensity;\n  uniform vec4 cc_view_PreExposure;\n  uniform vec4 cc_ibl_cluster_BoundsMin;\n  uniform vec4 cc_ibl_cluster_CellsDot;\n  uniform vec4 cc_ibl_cluster_CellsMax;\n  uniform vec4 cc_ibl_cluster_TextureSize;\n  uniform vec4 cc_ibl_cluster_InfoTextureInvSize;\n  uniform vec4 cc_ibl_cluster_CellsCountByBoundsSizeAndPixelsPerCell;\n  uniform vec4 cc_light_cluster_BoundsMin;\n  uniform vec4 cc_light_cluster_CellsDot;\n  uniform vec4 cc_light_cluster_CellsMax;\n  uniform vec4 cc_light_cluster_TextureSize;\n  uniform vec4 cc_light_cluster_InfoTextureInvSize;\n  uniform vec4 cc_light_cluster_CellsCountByBoundsSizeAndPixelsPerCell;\n  uniform vec4 FogStruct_ExponentialFogParameters;\n  uniform vec4 FogStruct_ExponentialFogColorParameter;\n  uniform vec4 FogStruct_ExponentialFogParameters2;\n  uniform vec4 FogStruct_ExponentialFogParameters3;\n  struct GlobalView {\n      vec3 IndirectLightingColorScale;\n      float PreExposure;\n  };\n  void getGlobalView (out GlobalView View) {\n      View.IndirectLightingColorScale = cc_view_IndirectLightingColorScale_Intensity.rgb * cc_view_IndirectLightingColorScale_Intensity.w;\n      View.PreExposure = cc_view_PreExposure.x;\n  }\nfloat Luminance( vec3 LinearColor )\n{\n  return dot( LinearColor, vec3( 0.3, 0.59, 0.11 ) );\n}\nvec3 CCRGBE2Linear (vec4 rgbe) {\n    return rgbe.rgb * pow(1.1, rgbe.a * 255.0 - 128.0);\n}\nvec4 decodeCCRGBE (vec4 color) {\n  color.rgb = CCRGBE2Linear(color);\n  color.a = 1.;\n  return color;\n}\nfloat rsqrt (float x) {\n  return 1. / sqrt(x);\n}\n  #ifdef GL_OES_standard_derivatives\n  #else\n  #endif\nfloat Square(float v)\n{\n    return v * v;\n}\nstruct Light {\n  vec3 color;\n  vec3 direction;\n};\nstruct FDirectLighting\n{\n  vec3 Diffuse;\n  vec3 Specular;\n};\nstruct FPixelMaterialInputs\n{\n  vec3 Normal;\n  vec3 EmissiveColor;\n  float Opacity;\n  float OpacityMask;\n  vec3 BaseColor;\n  float Metallic;\n  float Specular;\n  float Roughness;\n  float AmbientOcclusion;\n  float Anisotropy;\n  float Tangent;\n  float Refraction;\n  float PixelDepthOffset;\n  float ShadingModel;\n  float TwoSidedSign;\n  float RoughnessWithClamp;\n  vec3 DiffuseColor;\n  vec3 SpecularColor;\n  vec3 Subsurface;\n};\nstruct FMaterialPixelParameters {\n  float IndirectIrradiance;\n  vec2 TexCoords_0;\n  vec2 TexCoords_1;\n  vec4 VertexColor;\n  vec3 WorldNormal;\n  vec3 WorldTangent;\n  vec3 ReflectionVector;\n  vec3 CameraVector;\n  vec3 LightVector;\n  vec4 SvPosition;\n  vec4 ScreenPosition;\n  mat3 TangentToWorld;\n  vec3 AbsoluteWorldPosition;\n  vec3 ObjectWorldPosition;\n  vec2 LightmapUVs;\n  int PrimitiveId;\n};\nstruct FMaterialVertexParameters {\n  vec3 WorldPosition;\n  vec4 VertexColor;\n};\n  vec3 GetMaterialNormalRaw(FPixelMaterialInputs PixelMaterialInputs) {\n      return vec3 ((PixelMaterialInputs).Normal);\n  }\n  vec3 GetMaterialNormal(FMaterialPixelParameters Parameters, FPixelMaterialInputs PixelMaterialInputs) {\n      vec3 RetNormal = GetMaterialNormalRaw(PixelMaterialInputs);\n      return RetNormal;\n  }\n  vec3 TransformTangentNormalToWorld(mat3 TangentToWorld, vec3 normal) {\n      return normalize((TangentToWorld * normalize(normal)));\n  }\n  vec3 ReflectionAboutCustomWorldNormal(inout FMaterialPixelParameters Parameters, vec3 WorldNormal, bool bNormalizeInputNormal) {\n      ((Parameters).WorldNormal = (TransformTangentNormalToWorld((Parameters).TangentToWorld, (Parameters).WorldNormal)).xzy);\n      ((Parameters).ReflectionVector = normalize(reflect((-(Parameters).CameraVector), (Parameters).WorldNormal)));\n      return (Parameters).ReflectionVector;\n  }\n  vec4 SvPositionToResolvedScreenPosition(vec4 SvPosition) {\n      vec2 pixelPos = (SvPosition).xy;\n      vec3 ndc = vec3((((pixelPos * (cc_screenSize).zw) - vec2 (0.500000)) * 2.000000), (gl_FragCoord));\n      vec4 screenPos = (vec4(ndc, 1.000000) / (gl_FragCoord));\n      return screenPos;\n  }\n   vec4 F4_0101 = vec4(0, 1, 0, 1);\nvoid CalcPixelMaterialInputs(inout FMaterialPixelParameters Parameters, inout FPixelMaterialInputs PixelMaterialInputs) {\n    ((PixelMaterialInputs).Normal = vec3(0.000000, 0.000000, 1.000000));\n    vec3 MaterialNormal = vec3 (GetMaterialNormal(Parameters, PixelMaterialInputs));\n    ((Parameters).WorldNormal = normalize(MaterialNormal));\n    ((Parameters).ReflectionVector = ReflectionAboutCustomWorldNormal(Parameters, (Parameters).WorldNormal, false));\n    ((PixelMaterialInputs).EmissiveColor = vec3(0.000000, 0.000000, 0.000000));\n    ((PixelMaterialInputs).Opacity = 1.000000);\n    ((PixelMaterialInputs).OpacityMask = 1.000000);\n    ((PixelMaterialInputs).BaseColor = vec3(0.270222, 0.242972, 0.937500));\n    ((PixelMaterialInputs).Metallic = 0.000000);\n    ((PixelMaterialInputs).Specular = 0.500000);\n    ((PixelMaterialInputs).Roughness = 0.500000);\n    ((PixelMaterialInputs).Anisotropy = 0.000000);\n    ((PixelMaterialInputs).Tangent = float (vec3(1.000000, 0.000000, 0.000000)));\n    ((PixelMaterialInputs).Subsurface = vec3 (0));\n    ((PixelMaterialInputs).AmbientOcclusion = 1.000000);\n    ((Parameters).WorldTangent = vec3 (0));\n}\n#if CC_USE_ATTR_COLOR\nvarying vec4 v_color;\n#endif\nvarying vec3 v_obj_position;\nvarying vec3 v_position;\nvarying vec3 v_normal;\nvarying vec2 v_uv;\nvarying vec2 v_uv1;\nvarying vec3 v_tangent;\nvarying vec3 v_bitangent;\nvoid getPixelParameters (out FMaterialPixelParameters Parameters) {\n  Parameters.TexCoords_0 = v_uv;\n  Parameters.TexCoords_1 = v_uv1;\n  #if CC_USE_ATTR_COLOR\n    Parameters.VertexColor = v_color;\n  #else\n    Parameters.VertexColor = vec4(1.);\n  #endif\n  Parameters.WorldNormal = v_normal;\n  Parameters.AbsoluteWorldPosition = v_position;\n  Parameters.ObjectWorldPosition = v_obj_position;\n  Parameters.CameraVector = normalize(cc_cameraPos.xyz - v_position);\n  Parameters.SvPosition = gl_FragCoord;\n  Parameters.ScreenPosition = SvPositionToResolvedScreenPosition(gl_FragCoord);\n  Parameters.TangentToWorld = mat3(\n    v_tangent,\n    v_bitangent,\n    v_normal\n  );\n  Parameters.LightmapUVs = v_uv1;\n  Parameters.IndirectIrradiance = 0.;\n}\nvoid surf (out FPixelMaterialInputs PixelMaterialInputs, out FMaterialPixelParameters Parameters, out GlobalView View) {\n  getPixelParameters(Parameters);\n  getGlobalView(View);\n  Parameters.AbsoluteWorldPosition = Parameters.AbsoluteWorldPosition.xzy * 100.;\n  Parameters.ObjectWorldPosition = Parameters.ObjectWorldPosition.xzy * 100.;\n  Parameters.CameraVector = Parameters.CameraVector.xzy;\n  CalcPixelMaterialInputs(Parameters, PixelMaterialInputs);\n  float TwoSidedSign = 1.;\n  if (!gl_FrontFacing) {\n    TwoSidedSign = -1.;\n  }\n  Parameters.AbsoluteWorldPosition = Parameters.AbsoluteWorldPosition.xzy / 100.;\n  Parameters.ObjectWorldPosition = Parameters.ObjectWorldPosition.xzy / 100.;\n  Parameters.CameraVector = Parameters.CameraVector.xzy;\n  Parameters.WorldNormal = Parameters.WorldNormal.xzy * TwoSidedSign;\n  Parameters.ReflectionVector = Parameters.ReflectionVector.xzy;\n  if (PixelMaterialInputs.OpacityMask < 0.33330) {\n    discard;\n  }\n  PixelMaterialInputs.Metallic = clamp(PixelMaterialInputs.Metallic, 0.0, 1.0);\n  PixelMaterialInputs.Specular = clamp(PixelMaterialInputs.Specular, 0.0, 1.0);\n  PixelMaterialInputs.Roughness = clamp(PixelMaterialInputs.Roughness, 0.0, 1.0);\n  PixelMaterialInputs.TwoSidedSign = TwoSidedSign;\n}\nfloat GGX_Mobile(float Roughness, float NoH, vec3 H, vec3 N)\n{\n    vec3 NxH = cross(N, H);\n    float OneMinusNoHSqr = dot(NxH, NxH);\n    float a = Roughness * Roughness;\n    float n = NoH * a;\n    float p = a / (OneMinusNoHSqr + n * n);\n    return p * p;\n}\nfloat D_GGX( float a2, float NoH )\n{\n  float d = ( NoH * a2 - NoH ) * NoH + 1.;\n  return a2 / ( 3.14159265359*d*d );\n}\n  varying highp vec4 v_shadowPos;\n  uniform highp mat4 cc_matLightView;\n  uniform highp vec4 cc_shadowInvProjDepthInfo;\n  uniform highp vec4 cc_shadowProjDepthInfo;\n  uniform highp vec4 cc_shadowProjInfo;\n  uniform lowp vec4 cc_shadowNFLSInfo;\n  uniform lowp vec4 cc_shadowWHPBInfo;\n  uniform lowp vec4 cc_shadowLPNNInfo;\n  float CCGetLinearDepthFromViewSpace(vec3 viewPos) {\n    float dist = length(viewPos);\n    return (dist - cc_shadowNFLSInfo.x) / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x);\n  }\n  float CCGetLinearDepth(vec3 worldPos) {\n    vec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n    return CCGetLinearDepthFromViewSpace(viewStartPos.xyz);\n  }\n  #if CC_RECEIVE_SHADOW\n    uniform highp sampler2D cc_shadowMap;\n    uniform highp sampler2D cc_spotLightingMap;\n    vec4 ApplyShadowDepthBias_FaceNormal(vec4 shadowPos, vec3 worldNormal)\n    {\n      vec4 newShadowPos = shadowPos;\n      if(cc_shadowLPNNInfo.z > 0.0001)\n      {\n        vec4 viewNormal = cc_matLightView * vec4(worldNormal, 0.0);\n        if(viewNormal.z < 0.1)\n          newShadowPos.xy += viewNormal.xy * cc_shadowProjInfo.xy * cc_shadowLPNNInfo.z * clamp(viewNormal.z, 0.001, 0.1);\n      }\n      return newShadowPos;\n    }\n    vec4 ApplyShadowDepthBias_Perspective(vec4 shadowPos, float viewspaceDepthBias)\n    {\n      vec3 viewSpacePos;\n      viewSpacePos.xy = shadowPos.xy * cc_shadowProjInfo.zw;\n      viewSpacePos.z = shadowPos.z * cc_shadowInvProjDepthInfo.x + shadowPos.w * cc_shadowInvProjDepthInfo.y;\n      viewSpacePos.xyz += cc_shadowProjDepthInfo.z * normalize(viewSpacePos.xyz) * viewspaceDepthBias;\n      vec4 clipSpacePos;\n      clipSpacePos.xy = viewSpacePos.xy * cc_shadowProjInfo.xy;\n      clipSpacePos.zw = viewSpacePos.z * cc_shadowProjDepthInfo.xz + vec2(cc_shadowProjDepthInfo.y, 0.0);\n      if (cc_shadowNFLSInfo.z > 0.000001) {\n        clipSpacePos.z = CCGetLinearDepthFromViewSpace(viewSpacePos.xyz);\n        clipSpacePos.z = (clipSpacePos.z * 2.0 - 1.0) * clipSpacePos.w;\n      }\n      return clipSpacePos;\n    }\n    vec4 ApplyShadowDepthBias_Orthographic(vec4 shadowPos, float viewspaceDepthBias)\n    {\n      float coeffA = cc_shadowProjDepthInfo.x;\n      float coeffB = cc_shadowProjDepthInfo.y;\n      float viewSpacePos_z = (shadowPos.z - coeffB) / coeffA;\n      viewSpacePos_z += viewspaceDepthBias;\n      vec4 result = shadowPos;\n      result.z = viewSpacePos_z * coeffA + coeffB;\n      return result;\n    }\n    float CCGetShadowFactorHard (vec4 shadowPos) {\n      vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, cc_shadowWHPBInfo.w);\n      vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n      if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n          clipPos.y < 0.0 || clipPos.y > 1.0 ||\n          clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n      clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n      float shadow = 0.0;\n      float closestDepth = 0.0;\n      if (cc_shadowLPNNInfo.y > 0.000001) {\n        closestDepth = dot(texture2D(cc_shadowMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n      } else {\n        closestDepth = texture2D(cc_shadowMap, clipPos.xy).x;\n      }\n      shadow = step(clipPos.z, closestDepth);\n      return shadow;\n    }\n    float CCGetShadowFactorSoft (vec4 shadowPos) {\n      vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, cc_shadowWHPBInfo.w);\n      vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n      if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n          clipPos.y < 0.0 || clipPos.y > 1.0 ||\n          clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n      clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n      float offsetDepth = clipPos.z;\n      vec2 mapSize = cc_shadowWHPBInfo.xy;\n      vec2 oneTap = 1.0 / mapSize;\n      vec2 clipPos_offset = clipPos.xy + oneTap;\n      float block0, block1, block2, block3;\n      if (cc_shadowLPNNInfo.y > 0.000001) {\n        block0 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block1 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block2 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block3 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      } else {\n        block0 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\n        block1 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)).x);\n        block2 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)).x);\n        block3 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);\n      }\n      float coefX   = mod(clipPos.x, oneTap.x) * mapSize.x;\n      float resultX = mix(block0, block1, coefX);\n      float resultY = mix(block2, block3, coefX);\n      float coefY   = mod(clipPos.y, oneTap.y) * mapSize.y;\n      return mix(resultX, resultY, coefY);\n    }\n    float CCGetShadowFactorSoft2X (vec4 shadowPos) {\n      vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, cc_shadowWHPBInfo.w);\n      vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n      if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n          clipPos.y < 0.0 || clipPos.y > 1.0 ||\n          clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n      clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n      float offsetDepth = clipPos.z;\n      vec2 mapSize = cc_shadowWHPBInfo.xy;\n      vec2 oneTap = 1.0 / mapSize;\n      float clipPos_offset_L = clipPos.x - oneTap.x;\n      float clipPos_offset_R = clipPos.x + oneTap.x;\n      float clipPos_offset_U = clipPos.y - oneTap.y;\n      float clipPos_offset_D = clipPos.y + oneTap.y;\n      float block0, block1, block2, block3, block4, block5, block6, block7, block8;\n      if (cc_shadowLPNNInfo.y > 0.000001) {\n        block0 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block1 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block2 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block3 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block4 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block5 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block6 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block7 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block8 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      } else {\n        block0 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);\n        block1 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)).x);\n        block2 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);\n        block3 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)).x);\n        block4 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\n        block5 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)).x);\n        block6 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);\n        block7 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)).x);\n        block8 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);\n      }\n      float coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\n      float coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\n      float shadow = 0.0;\n      float resultX = mix(block0, block1, coefX);\n      float resultY = mix(block3, block4, coefX);\n      shadow += mix(resultX , resultY, coefY);\n      resultX = mix(block1, block2, coefX);\n      resultY = mix(block4, block5, coefX);\n      shadow += mix(resultX , resultY, coefY);\n      resultX = mix(block3, block4, coefX);\n      resultY = mix(block6, block7, coefX);\n      shadow += mix(resultX, resultY, coefY);\n      resultX = mix(block4, block5, coefX);\n      resultY = mix(block7, block8, coefX);\n      shadow += mix(resultX, resultY, coefY);\n      return shadow * 0.25;\n    }\n    float CCGetSpotLightShadowFactorHard (vec4 shadowPos, vec3 worldPos) {\n      vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, cc_shadowWHPBInfo.w);\n      vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n      if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n          clipPos.y < 0.0 || clipPos.y > 1.0 ||\n          clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n      clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n      float shadow = 0.0;\n      float closestDepth = 0.0;\n      float depth = clipPos.z;\n      if (cc_shadowLPNNInfo.y > 0.000001) {\n        closestDepth = dot(texture2D(cc_spotLightingMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n      } else {\n        closestDepth = texture2D(cc_spotLightingMap, clipPos.xy).x;\n      }\n      shadow = step(depth, closestDepth);\n      return shadow;\n    }\n    float CCGetSpotLightShadowFactorSoft (vec4 shadowPos, vec3 worldPos) {\n      vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, cc_shadowWHPBInfo.w);\n      vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n      if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n          clipPos.y < 0.0 || clipPos.y > 1.0 ||\n          clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n      clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n      float depth = 0.0;\n      if (cc_shadowNFLSInfo.z > 0.000001) {\n        depth = CCGetLinearDepth(worldPos);\n      } else {\n        depth = clipPos.z;\n      }\n      float bias = cc_shadowWHPBInfo.w;\n      vec2 oneTap = 1.0 / cc_shadowWHPBInfo.xy;\n      vec2 clipPos_offset = clipPos.xy + oneTap;\n      float block0, block1, block2, block3;\n      if (cc_shadowLPNNInfo.y > 0.000001) {\n        block0 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block1 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block2 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block3 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      } else {\n        block0 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x);\n        block1 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos.y)).x);\n        block2 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset.y)).x);\n        block3 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);\n      }\n      float coefX   = mod(clipPos.x, oneTap.x) * cc_shadowWHPBInfo.x;\n      float resultX = mix(block0, block1, coefX);\n      float resultY = mix(block2, block3, coefX);\n      float coefY   = mod(clipPos.y, oneTap.y) * cc_shadowWHPBInfo.y;\n      return mix(resultX, resultY, coefY);\n    }\n    float CCGetSpotLightShadowFactorSoft2X (vec4 shadowPos, vec3 worldPos) {\n      vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, cc_shadowWHPBInfo.w);\n      vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n      if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n          clipPos.y < 0.0 || clipPos.y > 1.0 ||\n          clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n      clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n      float depth = 0.0;\n      if (cc_shadowNFLSInfo.z > 0.000001) {\n        depth = CCGetLinearDepth(worldPos);\n      } else {\n        depth = clipPos.z;\n      }\n      float bias = cc_shadowWHPBInfo.w;\n      vec2 mapSize = cc_shadowWHPBInfo.xy;\n      vec2 oneTap = 1.0 / mapSize;\n      float clipPos_offset_L = clipPos.x - oneTap.x;\n      float clipPos_offset_R = clipPos.x + oneTap.x;\n      float clipPos_offset_U = clipPos.y - oneTap.y;\n      float clipPos_offset_D = clipPos.y + oneTap.y;\n      float block0, block1, block2, block3, block4, block5, block6, block7, block8;\n      if (cc_shadowLPNNInfo.y > 0.000001) {\n        block0 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block1 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block2 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block3 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block4 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block5 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block6 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block7 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block8 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      } else {\n        block0 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);\n        block1 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_U)).x);\n        block2 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);\n        block3 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos.y)).x);\n        block4 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x);\n        block5 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos.y)).x);\n        block6 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);\n        block7 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_D)).x);\n        block8 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);\n      }\n      float coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\n      float coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\n      float shadow = 0.0;\n      float resultX = mix(block0, block1, coefX);\n      float resultY = mix(block3, block4, coefX);\n      shadow += mix(resultX , resultY, coefY);\n      resultX = mix(block1, block2, coefX);\n      resultY = mix(block4, block5, coefX);\n      shadow += mix(resultX , resultY, coefY);\n      resultX = mix(block3, block4, coefX);\n      resultY = mix(block6, block7, coefX);\n      shadow += mix(resultX, resultY, coefY);\n      resultX = mix(block4, block5, coefX);\n      resultY = mix(block7, block8, coefX);\n      shadow += mix(resultX, resultY, coefY);\n      return shadow * 0.25;\n    }\n  #endif\nconst float FLT_EPSILON = 0.001;\nconst float FLT_EPSILON2 = 0.01;\nfloat CalculateLineIntegralShared(float FogHeightFalloff, float RayDirectionZ, float RayOriginTerms)\n{\n  float Falloff = max(-127.0, FogHeightFalloff * RayDirectionZ);\n  float LineIntegral = ( 1.0 - exp2(-Falloff) ) / Falloff;\n  float LineIntegralTaylor = log(2.0) - ( 0.5 * (pow(2., log(2.0))) ) * Falloff;\n  return RayOriginTerms * ( abs(Falloff) > FLT_EPSILON2 ? LineIntegral : LineIntegralTaylor );\n}\nvec3 ComputeInscatteringColor(vec3 CameraToReceiver, float CameraToReceiverLength)\n{\n  vec3 Inscattering = FogStruct_ExponentialFogColorParameter.xyz;\n  return Inscattering;\n}\nvec4 GetExponentialHeightFog(vec3 WorldPositionRelativeToCamera, float ExcludeDistance)\n{\n  float MinFogOpacity = FogStruct_ExponentialFogColorParameter.w;\n  float MaxWorldObserverHeight = FogStruct_ExponentialFogParameters.z;\n  vec3 View_WorldCameraOrigin = cc_cameraPos.xyz;\n  vec3 WorldObserverOrigin = vec3(View_WorldCameraOrigin.x, min(View_WorldCameraOrigin.y, MaxWorldObserverHeight), View_WorldCameraOrigin.z);\n  vec3 CameraToReceiver = WorldPositionRelativeToCamera;\n  CameraToReceiver.y += View_WorldCameraOrigin.y - WorldObserverOrigin.y;\n  float CameraToReceiverLengthSqr = dot(CameraToReceiver, CameraToReceiver);\n  float CameraToReceiverLengthInv = rsqrt(CameraToReceiverLengthSqr);\n  float CameraToReceiverLength = CameraToReceiverLengthSqr * CameraToReceiverLengthInv;\n  vec3 CameraToReceiverNormalized = CameraToReceiver * CameraToReceiverLengthInv;\n  float RayOriginTerms = FogStruct_ExponentialFogParameters.x;\n  float RayOriginTermsSecond = FogStruct_ExponentialFogParameters2.x;\n  float RayLength = CameraToReceiverLength;\n  float RayDirectionZ = CameraToReceiver.y;\n  ExcludeDistance = max(ExcludeDistance, FogStruct_ExponentialFogParameters.w);\n  if (ExcludeDistance > 0.)\n  {\n    float ExcludeIntersectionTime = ExcludeDistance * CameraToReceiverLengthInv;\n    float CameraToExclusionIntersectionZ = ExcludeIntersectionTime * CameraToReceiver.y;\n    float ExclusionIntersectionZ = WorldObserverOrigin.y + CameraToExclusionIntersectionZ;\n    float ExclusionIntersectionToReceiverZ = CameraToReceiver.y - CameraToExclusionIntersectionZ;\n    RayLength = (1.0 - ExcludeIntersectionTime) * CameraToReceiverLength;\n    RayDirectionZ = ExclusionIntersectionToReceiverZ;\n    float Exponent = max(-127.0, FogStruct_ExponentialFogParameters.y * (ExclusionIntersectionZ - FogStruct_ExponentialFogParameters3.y));\n    RayOriginTerms = FogStruct_ExponentialFogParameters3.x * exp2(-Exponent);\n    float ExponentSecond = max(-127.0, FogStruct_ExponentialFogParameters2.y * (ExclusionIntersectionZ - FogStruct_ExponentialFogParameters2.w));\n    RayOriginTermsSecond = FogStruct_ExponentialFogParameters2.z * exp2(-ExponentSecond);\n  }\n  float ExponentialHeightLineIntegralShared = CalculateLineIntegralShared(FogStruct_ExponentialFogParameters.y, RayDirectionZ, RayOriginTerms) + CalculateLineIntegralShared(FogStruct_ExponentialFogParameters2.y, RayDirectionZ, RayOriginTermsSecond);\n  float ExponentialHeightLineIntegral = ExponentialHeightLineIntegralShared * RayLength;\n  vec3 InscatteringColor = ComputeInscatteringColor(CameraToReceiver, CameraToReceiverLength);\n  vec3 DirectionalInscattering = vec3(0.);\n  float ExpFogFactor = max(clamp(exp2(-ExponentialHeightLineIntegral), 0.0, 1.0), MinFogOpacity);\n  if (FogStruct_ExponentialFogParameters3.w > 0. && CameraToReceiverLength > FogStruct_ExponentialFogParameters3.w)\n  {\n    ExpFogFactor = 1.;\n    DirectionalInscattering = vec3(0.);\n  }\n    vec3 FogColor = (InscatteringColor) * (1. - ExpFogFactor) + DirectionalInscattering;\n  return vec4(FogColor, ExpFogFactor);\n}\nvec4 CalculateHeightFog(vec3 WorldPositionRelativeToCamera)\n{\n  vec3 WorldPosition = WorldPositionRelativeToCamera;\n  float ExcludeDistance = 0.;\n  vec4 FogInscatteringAndOpacity = GetExponentialHeightFog(WorldPositionRelativeToCamera, ExcludeDistance);\n  return FogInscatteringAndOpacity;\n}\nvec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {\n    #ifdef GL_EXT_shader_texture_lod\n      return texture2DLodEXT(tex, coord, lod);\n    #else\n      return texture2D(tex, coord, lod);\n    #endif\n}\nvec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {\n    #ifdef GL_EXT_shader_texture_lod\n      return textureCubeLodEXT(tex, coord, lod);\n    #else\n      return textureCube(tex, coord, lod);\n    #endif\n}\nfloat ComputeReflectionCaptureMipFromRoughness(float Roughness, float CubemapMaxMip)\n{\n  float LevelFrom1x1 = 1.000001 - 1.2 * log2(Roughness);\n  return CubemapMaxMip - 1. - LevelFrom1x1;\n}\nvec3 GetSkySHDiffuseSimple(vec3 Normal)\n{\n  vec4 NormalVector = vec4(Normal.xzy, 1);\n  vec3 Intermediate0;\n  Intermediate0.x = dot(cc_view_SkyIrradianceEnvironmentMap[0], NormalVector);\n  Intermediate0.y = dot(cc_view_SkyIrradianceEnvironmentMap[1], NormalVector);\n  Intermediate0.z = dot(cc_view_SkyIrradianceEnvironmentMap[2], NormalVector);\n  return max(vec3(0.), Intermediate0);\n}\nuniform samplerCube cc_ibl_map_sky;\nvec3 GetSkyLightReflection(vec3 ReflectionVector, float Roughness, out float OutSkyAverageBrightness) {\n  float AbsoluteSpecularMip = ComputeReflectionCaptureMipFromRoughness(Roughness, cc_view_SkyLightParameters.x);\n  vec3 Reflection = decodeCCRGBE(fragTextureLod(cc_ibl_map_sky, ReflectionVector, AbsoluteSpecularMip)).rgb;\n  OutSkyAverageBrightness = cc_view_SkyColor.w * Luminance( cc_view_SkyColor.rgb );\n  return Reflection * cc_view_SkyColor.rgb;\n}\nvec3 posWS2screen (vec3 posWS) {\n  vec4 res = cc_matViewProj * vec4(posWS, 1.);\n  res.xyz /= res.w;\n  res.xyz = res.xyz * 0.5 + 0.5;\n  return res.xyz;\n}\nfloat CalcSpecular(float Roughness, float RoughnessWithClamp, float NoH, vec3 H, vec3 N)\n{\n  return (Roughness*0.25 + 0.25) * GGX_Mobile(RoughnessWithClamp, NoH, H, N);\n}\nFDirectLighting MobileIntegrateBxDF(FPixelMaterialInputs ShadingModelContext, vec3 N, vec3 H, float NoH)\n{\n  FDirectLighting Lighting;\n  Lighting.Specular = ShadingModelContext.SpecularColor * CalcSpecular(ShadingModelContext.Roughness, ShadingModelContext.RoughnessWithClamp, NoH, H, N);\n  Lighting.Diffuse = ShadingModelContext.DiffuseColor;\n  return Lighting;\n}\nvec3 EnvBRDFApprox( vec3 SpecularColor, float Roughness, float NoV )\n{\n  const vec4 c0 = vec4(-1., -0.0275, -0.572, 0.022);\n  const vec4 c1 = vec4(1., 0.0425, 1.04, -0.04);\n  vec4 r = Roughness * c0 + c1;\n  float a004 = min( r.x * r.x, exp2( -9.28 * NoV ) ) * r.x + r.y;\n  vec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n  AB.y *= clamp(50.0 * SpecularColor.g, 0.0, 1.0);\n  return SpecularColor * AB.x + AB.y;\n}\nuniform sampler2D cc_ibl_cluster_InfoTexture;\nuniform sampler2D cc_ibl_cluster_Texture;\nuniform sampler2D cc_ibl_cluster_CubemapAtlas;\nvec2 envMapEquirect(vec3 wcNormal) {\n  float phi = acos(-wcNormal.y);\n  float theta = atan(1. * wcNormal.x, wcNormal.z) + 3.14159265359;\n  vec2 uv = vec2(theta / 6.28318530718, 1. - phi / 3.14159265359);\n  return uv;\n}\nfloat ComputeMixingWeight(float IndirectIrradiance, float AverageBrightness, float Roughness)\n{\n  float MixingAlpha = smoothstep(0., 1., clamp(Roughness * 5.000001 + -0.5, 0.0, 1.0));\n  float MixingWeight = IndirectIrradiance / max(AverageBrightness, .0001);\n  MixingWeight = min(MixingWeight, 10000.000001);\n  return mix(1.0, MixingWeight, MixingAlpha);\n}\nvec3 GetLookupVectorForSphereCapture(vec3 ReflectionVector, vec3 WorldPosition, vec4 SphereCapturePositionAndRadius, float NormalizedDistanceToCapture, vec3 LocalCaptureOffset, inout float DistanceAlpha)\n{\n  vec3 ProjectedCaptureVector = ReflectionVector;\n  float ProjectionSphereRadius = SphereCapturePositionAndRadius.w;\n  float SphereRadiusSquared = ProjectionSphereRadius * ProjectionSphereRadius;\n  vec3 LocalPosition = WorldPosition - SphereCapturePositionAndRadius.xyz;\n  float LocalPositionSqr = dot(LocalPosition, LocalPosition);\n  vec3 QuadraticCoef;\n  QuadraticCoef.x = 1.;\n  QuadraticCoef.y = dot(ReflectionVector, LocalPosition);\n  QuadraticCoef.z = LocalPositionSqr - SphereRadiusSquared;\n  float Determinant = QuadraticCoef.y * QuadraticCoef.y - QuadraticCoef.z;\n  if (Determinant >= 0.)\n  {\n    float FarIntersection = sqrt(Determinant) - QuadraticCoef.y;\n    vec3 LocalIntersectionPosition = LocalPosition + FarIntersection * ReflectionVector;\n    ProjectedCaptureVector = normalize(LocalIntersectionPosition - LocalCaptureOffset);\n    float x = clamp(2.5 * NormalizedDistanceToCapture - 1.5, 0.0, 1.0);\n    DistanceAlpha = 1. - x*x*(3. - 2.*x);\n  }\n  return ProjectedCaptureVector;\n}\nvoid EvaluateClusterIBL(float iblIndex, FMaterialPixelParameters MaterialParameters, float mip, float IndirectIrradiance, inout vec4 ImageBasedReflections, inout vec2 CompositedAverageBrightness) {\n  float iblV = (iblIndex + 0.5) * cc_ibl_cluster_InfoTextureInvSize.y;\n  vec4 posRange = texture2D(cc_ibl_cluster_InfoTexture, vec2(0.5 * cc_ibl_cluster_InfoTextureInvSize.x, iblV));\n  float iblDistance = length(MaterialParameters.AbsoluteWorldPosition - posRange.xyz);\n  float DistanceAlpha = 0.;\n  vec3 ProjectedCaptureVector = MaterialParameters.ReflectionVector;\n  if (iblDistance < posRange.w) {\n    float NormalizedDistanceToCapture = clamp(iblDistance / posRange.w, 0.0, 1.0);\n    ProjectedCaptureVector = GetLookupVectorForSphereCapture(ProjectedCaptureVector, MaterialParameters.AbsoluteWorldPosition, posRange, NormalizedDistanceToCapture, vec3(0.0), DistanceAlpha);\n  }\n  vec4 data3 = texture2D(cc_ibl_cluster_InfoTexture, vec2(2.5 * cc_ibl_cluster_InfoTextureInvSize.x, iblV));\n  float AverageBrightness = data3.x;\n  float brightness = data3.y;\n  vec2 uv = envMapEquirect(ProjectedCaptureVector);\n  vec4 uvMapping = texture2D(cc_ibl_cluster_InfoTexture, vec2(1.5 * cc_ibl_cluster_InfoTextureInvSize.x, iblV));\n  vec2 scaleUV = vec2(uvMapping.z, uvMapping.w * 0.5);\n  vec2 rgbUV = uvMapping.xy + scaleUV * uv;\n  vec2 aUV = uvMapping.xy + scaleUV * vec2(uv.x, uv.y + 1.);\n  vec4 SpecularIBL = decodeCCRGBE(fragTextureLod(cc_ibl_cluster_CubemapAtlas, rgbUV, mip));\n  float pixelBrightness = decodeCCRGBE(fragTextureLod(cc_ibl_cluster_CubemapAtlas, aUV, mip)).r;\n  ImageBasedReflections.rgb += SpecularIBL.rgb * brightness * DistanceAlpha * ImageBasedReflections.a;\n  ImageBasedReflections.a *= 1. - (pixelBrightness * DistanceAlpha);\n  CompositedAverageBrightness.x += AverageBrightness * DistanceAlpha * CompositedAverageBrightness.y;\n  CompositedAverageBrightness.y *= 1. - DistanceAlpha;\n}\nvoid EvalCluster (float clusterU, float clusterV, in FMaterialPixelParameters MaterialParameters, float mip, float IndirectIrradiance, inout vec4 ImageBasedReflections, vec2 CompositedAverageBrightness) {\n  #if CC_IBL_MaxPixelsPerCell\n    int calcedIblCount = 0;\n    for (float pixelIndex = 0.5; pixelIndex < float(CC_IBL_MaxPixelsPerCell); pixelIndex++) {\n      vec4 iblIndices = texture2D(cc_ibl_cluster_Texture, vec2(cc_ibl_cluster_TextureSize.y * (clusterU + pixelIndex), clusterV));\n      vec4 indices = iblIndices * 255.0;\n      for (int e = 0; e < 4; e++) {\n        float iblIndex = indices[e];\n        if (iblIndex <= 0.0)\n          break;\n          EvaluateClusterIBL(iblIndex, MaterialParameters, mip, IndirectIrradiance, ImageBasedReflections, CompositedAverageBrightness);\n      }\n    }\n  #endif\n}\nfloat GetSpecularOcclusion(float NoV, float RoughnessSq, float AO)\n{\n  return clamp(pow( NoV + AO, RoughnessSq ) - 1. + AO, 0.0, 1.0);\n}\nvec3 GetOffSpecularPeakReflectionDir(vec3 Normal, vec3 ReflectionVector, float Roughness)\n{\n  float a = Square(Roughness);\n  return mix( Normal, ReflectionVector, (1. - a) * ( sqrt(1. - a) + a ) );\n}\nuniform sampler2D cc_planar_reflection_Texture;\nvec4 GetPlanarReflection (FMaterialPixelParameters MaterialParameters, GlobalView View) {\n  vec4 planarReflection = vec4(0.);\n  float DistanceFade = 1. - clamp(abs(MaterialParameters.AbsoluteWorldPosition.y) / 0.01, 0.0, 1.0);\n  if (DistanceFade > 0.) {\n    vec3 CameraToPixel = -MaterialParameters.CameraVector;\n    vec3 MirroredCameraVector = reflect(CameraToPixel, -cc_view_pr_reflectionPlane.xyz);\n    vec3 MirroredNormal = (cc_view_inverse_transpose_mirror * vec4(MaterialParameters.WorldNormal, 0.)).xyz;\n    vec3 MirroredReflectionVectorOffNormal = reflect(MirroredCameraVector, MirroredNormal);\n    vec3 VirtualReflectionSpherePosition = MaterialParameters.AbsoluteWorldPosition + MirroredReflectionVectorOffNormal * cc_view_pr_parameters.z;\n    vec2 screenUV = posWS2screen(VirtualReflectionSpherePosition.rgb).xy;\n    planarReflection = texture2D(cc_planar_reflection_Texture, screenUV);\n    planarReflection.a *= DistanceFade;\n    planarReflection.rgb /= View.PreExposure;\n  }\n  return planarReflection;\n}\nvec3 GetImageBasedReflectionLighting(FMaterialPixelParameters MaterialParameters, FPixelMaterialInputs ShadingModelContext, float IndirectIrradiance, GlobalView View) {\n  float Roughness = ShadingModelContext.Roughness;\n  float RoughnessSq = Roughness * Roughness;\n  float NoV = max(dot(MaterialParameters.WorldNormal, MaterialParameters.CameraVector), 0.);\n  float AO = ShadingModelContext.AmbientOcclusion;\n  float SpecularOcclusion = GetSpecularOcclusion(NoV, RoughnessSq, AO);\n  vec2 CompositedAverageBrightness = vec2(0.0, 1.0);\n  vec4 ImageBasedReflections = vec4(vec3(0.), SpecularOcclusion);\n  vec3 ReflectionVector = 2. * dot( MaterialParameters.CameraVector, MaterialParameters.WorldNormal ) * MaterialParameters.WorldNormal - MaterialParameters.CameraVector;\n  ReflectionVector = GetOffSpecularPeakReflectionDir(MaterialParameters.WorldNormal, ReflectionVector, Roughness);\n  MaterialParameters.ReflectionVector = ReflectionVector;\n  if (ImageBasedReflections.a > 0.) {\n    vec4 planarReflection = GetPlanarReflection(MaterialParameters, View);\n    ImageBasedReflections.rgb += planarReflection.rgb * ImageBasedReflections.a;\n    ImageBasedReflections.a -= planarReflection.a;\n  }\n  vec3 cellCoords = floor((MaterialParameters.AbsoluteWorldPosition - cc_ibl_cluster_BoundsMin.xyz) * cc_ibl_cluster_CellsCountByBoundsSizeAndPixelsPerCell.xyz);\n  if (ImageBasedReflections.a <= 0. || (cellCoords.x < 0.) || (cellCoords.y < 0.) || (cellCoords.z < 0.) ||\n      (cellCoords.x > cc_ibl_cluster_CellsMax.x) || (cellCoords.y > cc_ibl_cluster_CellsMax.y) || (cellCoords.z > cc_ibl_cluster_CellsMax.z)) {\n  }\n  else {\n    float mip = ComputeReflectionCaptureMipFromRoughness(Roughness, 7.000001);\n    float cellIndex = dot(cc_ibl_cluster_CellsDot.xyz, cellCoords);\n    float clusterV = floor(cellIndex * cc_ibl_cluster_TextureSize.y);\n    float clusterU = floor(cellIndex - (clusterV * cc_ibl_cluster_TextureSize.x));\n    clusterV = (clusterV + 0.5) * cc_ibl_cluster_TextureSize.z;\n    EvalCluster(clusterU, clusterV, MaterialParameters, mip, IndirectIrradiance, ImageBasedReflections, CompositedAverageBrightness);\n  }\n  ImageBasedReflections.rgb *= View.IndirectLightingColorScale;\n  CompositedAverageBrightness.x *= Luminance( View.IndirectLightingColorScale );\n  if (ImageBasedReflections.a > 0.) {\n    float SkyAverageBrightness = 1.;\n    vec3 SkyLighting = GetSkyLightReflection(ReflectionVector, Roughness, SkyAverageBrightness);\n    ImageBasedReflections.rgb += ImageBasedReflections.a * SkyLighting;\n    CompositedAverageBrightness.x += SkyAverageBrightness * CompositedAverageBrightness.y;\n      ImageBasedReflections.rgb *= ComputeMixingWeight(IndirectIrradiance, CompositedAverageBrightness.x, Roughness);\n  }\n    vec3 brdf = EnvBRDFApprox(ShadingModelContext.SpecularColor, Roughness, NoV);\n  ImageBasedReflections.rgb *= brdf;\n  return ImageBasedReflections.rgb;\n}\n#if (CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD)\n    varying vec3 v_luv;\n    uniform sampler2D cc_lightingMap;\n    #if USE_INSTANCING\n      varying vec4 v_lightingMapAdds0;\n      varying vec4 v_lightingMapAdds1;\n      varying vec4 v_lightingMapScales0;\n      varying vec4 v_lightingMapScales1;\n      void getLightingMapVectors (out vec4 lightingMapAdds0, out vec4 lightingMapAdds1, out vec4 lightingMapScales0, out vec4 lightingMapScales1) {\n        lightingMapAdds0 = v_lightingMapAdds0;\n        lightingMapAdds1 = v_lightingMapAdds1;\n        lightingMapScales0 = v_lightingMapScales0;\n        lightingMapScales1 = v_lightingMapScales1;\n      }\n    #endif\n    vec4 GetLightMapColorLQ( vec2 LightmapUV0, vec2 LightmapUV1, vec3 WorldNormal ) {\n      vec4 lightingMapAdds0 = vec4(0.);\n      vec4 lightingMapAdds1 = vec4(0.);\n      vec4 lightingMapScales0 = vec4(1.);\n      vec4 lightingMapScales1 = vec4(1.);\n      #if USE_INSTANCING\n        getLightingMapVectors(lightingMapAdds0, lightingMapAdds1, lightingMapScales0, lightingMapScales1);\n      #endif\n      vec4 Lightmap0 = texture2D(cc_lightingMap, LightmapUV0 );\n      vec3 LogRGB = Lightmap0.rgb * lightingMapScales0.xyz + lightingMapAdds0.xyz;\n      float LogL = Luminance( LogRGB );\n      const float LogBlackPoint = 0.00390625;\n      float L = exp2( LogL * 16. - 8. ) - LogBlackPoint;\n      float Directionality = 0.6;\n      float Luma = L * Directionality;\n      vec3 Color = LogRGB * (Luma / LogL);\n      return vec4( Color, Luma );\n    }\n#endif\nvec4 GetLightMapColor (vec3 worldNormal) {\n  vec4 lightmapColor =  vec4(vec3(0.), 0.);\n    #if (CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD)\n      vec2 LightmapUV0 = v_luv.xy * vec2( 1., 0.5 );\n      vec2 LightmapUV1 = LightmapUV0 + vec2( 0., 0.5 );\n        lightmapColor = GetLightMapColorLQ(LightmapUV0, LightmapUV1, worldNormal);\n    #endif\n  return lightmapColor;\n}\nvec4 lightingBase (FPixelMaterialInputs ShadingModelContext, FMaterialPixelParameters MaterialParameters, GlobalView View, vec4 shadowPos) {\n  vec3 Color = vec3(0);\n  #if CC_Lighting_Heavily\n    Color += vec3(0.1, 0, 0);\n  #else\n    vec3 direction = normalize(-cc_mainLitDir.xyz);\n    vec3 lightColor = cc_mainLitColor.rgb * cc_mainLitColor.w;\n    lightColor /= 3.14159265359;\n    float NoL = max(0., dot(MaterialParameters.WorldNormal, direction));\n    vec3 H = normalize(MaterialParameters.CameraVector + direction);\n    float NoH = max(0., dot(MaterialParameters.WorldNormal, H));\n    float Shadow = 1.;\n    #if CC_RECEIVE_SHADOW\n        {\n          vec4 pos = ApplyShadowDepthBias_FaceNormal(shadowPos, MaterialParameters.WorldNormal);\n          float pcf = cc_shadowWHPBInfo.z;\n          if (pcf > 1.9) Shadow = CCGetShadowFactorSoft2X(pos);\n          else if (pcf > 0.9) Shadow = CCGetShadowFactorSoft(pos);\n          else Shadow = CCGetShadowFactorHard(pos);\n          Shadow = mix(Shadow, 1.0, cc_shadowNFLSInfo.w);\n        }\n    #endif\n    FDirectLighting Lighting = MobileIntegrateBxDF(ShadingModelContext, MaterialParameters.WorldNormal, H, NoH);\n    Color += (Shadow * NoL) * lightColor * (Lighting.Diffuse + Lighting.Specular );\n    float IndirectIrradiance = MaterialParameters.IndirectIrradiance;\n    #if CC_ENABLE_IBL\n      vec3 SpecularIBL = GetImageBasedReflectionLighting(MaterialParameters, ShadingModelContext, IndirectIrradiance, View);\n      Color += SpecularIBL;\n    #endif\n    Color += ShadingModelContext.EmissiveColor;\n  #endif\n  return vec4(Color, ShadingModelContext.Opacity);\n}\nvec3 transmission (vec3 N, vec3 V, vec3 L, float Falloff, vec3 SubsurfaceColor) {\n    float Wrap = 0.5;\n    float WrapAddOne = ( 1. + Wrap );\n    float WrapNoL = clamp(( -dot(N, L) + Wrap ) / ( WrapAddOne * WrapAddOne ), 0.0, 1.0);\n    float VoL = dot(V, L);\n    float Scatter = D_GGX( 0.6*0.6, clamp(-VoL, 0.0, 1.0) );\n    return SubsurfaceColor * WrapNoL * Scatter * cc_mainLitColor.rgb * cc_mainLitColor.w;\n}\nvoid lightingPerObject (inout FMaterialPixelParameters Parameters, inout FPixelMaterialInputs PixelMaterialInputs) {\n    PixelMaterialInputs.EmissiveColor += transmission(\n      Parameters.WorldNormal,\n      Parameters.CameraVector,\n      normalize(-cc_mainLitDir.xyz), 1.,\n      PixelMaterialInputs.Subsurface\n    );\n  #if !(CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD)\n    vec3 DiffuseLookup = GetSkySHDiffuseSimple(Parameters.WorldNormal) * cc_view_SkyColor.rgb;\n    vec3 DiffuseColor = PixelMaterialInputs.BaseColor - PixelMaterialInputs.BaseColor * PixelMaterialInputs.Metallic;\n    PixelMaterialInputs.EmissiveColor += DiffuseLookup * PixelMaterialInputs.AmbientOcclusion * DiffuseColor;\n    if (PixelMaterialInputs.TwoSidedSign < 0.) {\n      vec3 BackfaceDiffuseLookup = GetSkySHDiffuseSimple(Parameters.WorldNormal * PixelMaterialInputs.TwoSidedSign);\n      PixelMaterialInputs.EmissiveColor += BackfaceDiffuseLookup * PixelMaterialInputs.Subsurface;\n    }\n  #endif\n}\n#if CC_FORWARD_ADD\n#if CC_PIPELINE_TYPE == 0\n# define LIGHTS_PER_PASS 1\n#else\n# define LIGHTS_PER_PASS 10\n#endif\n#if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\nuniform highp vec4 cc_lightPos[LIGHTS_PER_PASS];\n  uniform vec4 cc_lightColor[LIGHTS_PER_PASS];\n  uniform vec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];\n  uniform vec4 cc_lightDir[LIGHTS_PER_PASS];\n#endif\n#endif\nfloat SpotAttenuationMask(vec3 L, vec3 SpotDirection, vec2 SpotAngles)\n{\n  return clamp((dot(L, -SpotDirection) - SpotAngles.x) * SpotAngles.y, 0.0, 1.0);\n}\nfloat SpotAttenuation(vec3 L, vec3 SpotDirection, vec2 SpotAngles)\n{\n  float ConeAngleFalloff = Square(SpotAttenuationMask(L, SpotDirection, SpotAngles));\n  return ConeAngleFalloff;\n}\nvoid lightingAddPerLight(\n  in FPixelMaterialInputs ShadingModelContext, in FMaterialPixelParameters MaterialParameters,\n  vec3 pos, bool isSpotLight,\n  vec3 lightColor, float intensity,\n  float range, float spotAngle,\n  vec3 dir,\n  vec4 shadowPos,\n  inout vec3 outColor) {\n  vec3 toLight = pos - MaterialParameters.AbsoluteWorldPosition;\n  float distanceSqr = dot(toLight, toLight);\n  vec3 L = toLight * rsqrt(distanceSqr);\n  vec3 PointH = normalize(MaterialParameters.CameraVector + L);\n  float PointNoL = max(0., dot(MaterialParameters.WorldNormal, L));\n  float PointNoH = max(0., dot(MaterialParameters.WorldNormal, PointH));\n  float Attenuation;\n  {\n    Attenuation = 1. / ( distanceSqr + 0.01 );\n    float InvRadius = 1.0 / max(range, 0.01);\n    float LightRadiusMask = Square(clamp(1. - Square(distanceSqr * (InvRadius * InvRadius)), 0.0, 1.0));\n    Attenuation *= LightRadiusMask;\n  }\n  if (isSpotLight) {\n    vec3 SL = normalize(toLight);\n    float cosInner = 1.;\n    float cosOuter = spotAngle;\n    float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\n    vec2 SpotAngles = vec2(cosOuter, litAngleScale);\n    Attenuation *= SpotAttenuation(L, dir, SpotAngles);\n    float shadow = 1.;\n    #if CC_RECEIVE_SHADOW\n        {\n          vec4 pos = ApplyShadowDepthBias_FaceNormal(shadowPos, MaterialParameters.WorldNormal);\n          float pcf = cc_shadowWHPBInfo.z;\n          if (pcf > 1.9) shadow = CCGetShadowFactorSoft2X(pos);\n          else if (pcf > 0.9) shadow = CCGetShadowFactorSoft(pos);\n          else shadow = CCGetShadowFactorHard(pos);\n          shadow = mix(shadow, 1.0, cc_shadowNFLSInfo.w);\n        }\n    #endif\n    lightColor *= shadow;\n  }\n  FDirectLighting Lighting = MobileIntegrateBxDF(ShadingModelContext, MaterialParameters.WorldNormal, PointH, PointNoH);\n  outColor += min(vec3(65000.0), (Attenuation * PointNoL) * lightColor * intensity / 3.14159265359 * (Lighting.Diffuse + Lighting.Specular));\n}\nuniform sampler2D cc_light_cluster_InfoTexture;\nuniform sampler2D cc_light_cluster_Texture;\nvoid lightingCluster(float clusterIndex, in FPixelMaterialInputs ShadingModelContext, in FMaterialPixelParameters MaterialParameters, vec4 shadowPos, inout vec3 outColor) {\n  #if CC_Lighting_Heavily\n    outColor += vec3(0.1, 0, 0);\n  #else\n    float iblV = (clusterIndex + 0.5) * cc_light_cluster_InfoTextureInvSize.y;\n    vec4 lightPos = texture2D(cc_light_cluster_InfoTexture, vec2(0.5 * cc_light_cluster_InfoTextureInvSize.x, iblV));\n    vec4 lightColor = texture2D(cc_light_cluster_InfoTexture, vec2(1.5 * cc_light_cluster_InfoTextureInvSize.x, iblV));\n    vec4 lightSizeRangeAngle = texture2D(cc_light_cluster_InfoTexture, vec2(2.5 * cc_light_cluster_InfoTextureInvSize.x, iblV));\n    vec4 lightDir = texture2D(cc_light_cluster_InfoTexture, vec2(3.5 * cc_light_cluster_InfoTextureInvSize.x, iblV));\n    lightingAddPerLight(\n      ShadingModelContext, MaterialParameters,\n      lightPos.xyz, lightPos.w > 0.0,\n      lightColor.rgb, lightColor.w,\n      lightSizeRangeAngle.y, lightSizeRangeAngle.z,\n      lightDir.xyz,\n      shadowPos,\n      outColor\n    );\n  #endif\n}\n#if CC_ENABLE_CLUSTERED_LIGHT_CULLING && CC_ENABLE_Builtin_CLUSTERED_LIGHT_CULLING\n  float SmoothDistAtt (float distSqr, float invSqrAttRadius) {\n    float factor = distSqr * invSqrAttRadius;\n    float smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\n    return smoothFactor * smoothFactor;\n  }\n  float GetDistAtt (float distSqr, float invSqrAttRadius) {\n    float attenuation = 1.0 / max(distSqr, 0.01*0.01);\n    attenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\n    return attenuation;\n  }\n  float GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\n    float cd = dot(litDir, L);\n    float attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\n    return (attenuation * attenuation);\n  }\n  #if CC_USE_IBL\n    uniform samplerCube cc_environment;\n    #if CC_USE_DIFFUSEMAP\n      uniform samplerCube cc_diffuseMap;\n    #endif\n  #endif\n  float GGXMobile (float roughness, float NoH, vec3 H, vec3 N) {\n    vec3 NxH = cross(N, H);\n    float OneMinusNoHSqr = dot(NxH, NxH);\n    float a = roughness * roughness;\n    float n = NoH * a;\n    float p = a / (OneMinusNoHSqr + n * n);\n    return p * p;\n  }\n  float CalcSpecular (float roughness, float NoH, vec3 H, vec3 N) {\n    return (roughness * 0.25 + 0.25) * GGXMobile(roughness, NoH, H, N);\n  }\n  vec3 BRDFApprox (vec3 specular, float roughness, float NoV) {\n    const vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);\n    const vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);\n    vec4 r = roughness * c0 + c1;\n    float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\n    vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\n    AB.y *= clamp(50.0 * specular.g, 0.0, 1.0);\n    return specular * AB.x + AB.y;\n  }\n  #if USE_REFLECTION_DENOISE\n  #endif\n  struct StandardSurface {\n    vec4 albedo;\n    vec3 position;\n    vec3 normal;\n    vec3 emissive;\n    vec3 lightmap;\n    float lightmap_test;\n    float roughness;\n    float metallic;\n    float occlusion;\n  };\n  readonly buffer b_ccLightsBuffer { vec4 b_ccLights[]; };\n  readonly buffer b_clusterLightIndicesBuffer { uint b_clusterLightIndices[]; };\n  readonly buffer b_clusterLightGridBuffer { uvec4 b_clusterLightGrid[]; };\n  struct CCLight\n  {\n    vec4 cc_lightPos;\n    vec4 cc_lightColor;\n    vec4 cc_lightSizeRangeAngle;\n    vec4 cc_lightDir;\n  };\n  struct Cluster\n  {\n    vec3 minBounds;\n    vec3 maxBounds;\n  };\n  struct LightGrid\n  {\n    uint offset;\n    uint ccLights;\n  };\n  CCLight getCCLight(uint i)\n  {\n    CCLight light;\n    light.cc_lightPos = b_ccLights[4u * i + 0u];\n    light.cc_lightColor = b_ccLights[4u * i + 1u];\n    light.cc_lightSizeRangeAngle = b_ccLights[4u * i + 2u];\n    light.cc_lightDir = b_ccLights[4u * i + 3u];\n    return light;\n  }\n  LightGrid getLightGrid(uint cluster)\n  {\n    uvec4 gridvec = b_clusterLightGrid[cluster];\n    LightGrid grid;\n    grid.offset = gridvec.x;\n    grid.ccLights = gridvec.y;\n    return grid;\n  }\n  uint getGridLightIndex(uint start, uint offset)\n  {\n    return b_clusterLightIndices[start + offset];\n  }\n  uint getClusterZIndex(vec4 worldPos)\n  {\n    float scale = float(24) / log(cc_nearFar.y / cc_nearFar.x);\n    float bias = -(float(24) * log(cc_nearFar.x) / log(cc_nearFar.y / cc_nearFar.x));\n    float eyeDepth = -(cc_matView * worldPos).z;\n    uint zIndex = uint(max(log(eyeDepth) * scale + bias, 0.0));\n    return zIndex;\n  }\n  uint getClusterIndex(vec4 fragCoord, vec4 worldPos)\n  {\n    uint zIndex = getClusterZIndex(worldPos);\n    float clusterSizeX = ceil(cc_nativeSize.x / float(16));\n    float clusterSizeY = ceil(cc_nativeSize.y / float(8));\n    uvec3 indices = uvec3(uvec2(fragCoord.xy / vec2(clusterSizeX, clusterSizeY)), zIndex);\n    uint cluster = (16u * 8u) * indices.z + 16u * indices.y + indices.x;\n    return cluster;\n  }\n  vec4 CCClusterShadingAdditive (StandardSurface s, vec4 shadowPos) {\n    vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n    vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n    vec3 diffuseContrib = diffuse / 3.14159265359;\n    vec3 N = normalize(s.normal);\n    vec3 V = normalize(cc_cameraPos.xyz - s.position);\n    float NV = max(abs(dot(N, V)), 0.001);\n    specular = BRDFApprox(specular, s.roughness, NV);\n    vec3 finalColor = vec3(0.0);\n    uint cluster = getClusterIndex(gl_FragCoord, vec4(s.position, 1.0));\n    LightGrid grid = getLightGrid(cluster);\n    uint numLights = grid.ccLights;\n    for (uint i = 0u; i < 100u; i++) {\n      if (i >= numLights) break;\n      uint lightIndex = getGridLightIndex(grid.offset, i);\n      CCLight light = getCCLight(lightIndex);\n      vec3 SLU = light.cc_lightPos.xyz - s.position;\n      vec3 SL = normalize(SLU);\n      vec3 SH = normalize(SL + V);\n      float SNL = max(dot(N, SL), 0.001);\n      float SNH = max(dot(N, SH), 0.0);\n      float distSqr = dot(SLU, SLU);\n      float litRadius = light.cc_lightSizeRangeAngle.x;\n      float litRadiusSqr = litRadius * litRadius;\n      float illum = 3.14159265359 * (litRadiusSqr / max(litRadiusSqr , distSqr));\n      float attRadiusSqrInv = 1.0 / max(light.cc_lightSizeRangeAngle.y, 0.01);\n      attRadiusSqrInv *= attRadiusSqrInv;\n      float att = GetDistAtt(distSqr, attRadiusSqrInv);\n      vec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\n      if (light.cc_lightPos.w > 0.0) {\n        float cosInner = max(dot(-light.cc_lightDir.xyz, SL), 0.01);\n        float cosOuter = light.cc_lightSizeRangeAngle.z;\n        float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\n        float litAngleOffset = -cosOuter * litAngleScale;\n        att *= GetAngleAtt(SL, -light.cc_lightDir.xyz, litAngleScale, litAngleOffset);\n      }\n      vec3 lightColor = light.cc_lightColor.rgb;\n      float shadow = 1.0;\n      #if CC_RECEIVE_SHADOW\n        if (light.cc_lightPos.w > 0.0) {\n            {\n              float pcf = cc_shadowWHPBInfo.z;\n              if (pcf > 1.9) shadow = CCGetSpotLightShadowFactorSoft2X(shadowPos, s.position);\n              else if (pcf > 0.9) shadow = CCGetSpotLightShadowFactorSoft(shadowPos, s.position);\n              else shadow = CCGetSpotLightShadowFactorHard(shadowPos, s.position);\n            }\n        }\n      #endif\n      lightColor *= shadow;\n      finalColor += SNL * lightColor * light.cc_lightColor.w * illum * att * (diffuseContrib + lspec);\n    }\n    return vec4(finalColor, 0.0);\n  }\n#endif\nvec4 lightingAdd (in FPixelMaterialInputs ShadingModelContext, in FMaterialPixelParameters MaterialParameters, vec4 shadowPos) {\n  vec3 color = vec3(0.);\n  #if CC_ENABLE_CLUSTERED_LIGHT_CULLING && CC_ENABLE_Builtin_CLUSTERED_LIGHT_CULLING\n    StandardSurface s;\n    s.albedo.xyz = ShadingModelContext.BaseColor;\n    s.albedo.w = ShadingModelContext.Opacity;\n    s.metallic = ShadingModelContext.Metallic;\n    s.roughness = ShadingModelContext.Roughness;\n    s.normal = MaterialParameters.WorldNormal;\n    s.position = MaterialParameters.AbsoluteWorldPosition;\n    color = CCClusterShadingAdditive(s, shadowPos).rgb;\n  #else\n  vec3 cellCoords = floor((MaterialParameters.AbsoluteWorldPosition - cc_light_cluster_BoundsMin.xyz) * cc_light_cluster_CellsCountByBoundsSizeAndPixelsPerCell.xyz);\n  if ((cellCoords.x < 0.) || (cellCoords.y < 0.) || (cellCoords.z < 0.) ||\n      (cellCoords.x > cc_light_cluster_CellsMax.x) ||\n      (cellCoords.y > cc_light_cluster_CellsMax.y) ||\n      (cellCoords.z > cc_light_cluster_CellsMax.z)) {\n  }\n  else {\n    float cellIndex = dot(cc_light_cluster_CellsDot.xyz, cellCoords);\n    float clusterV = floor(cellIndex * cc_light_cluster_TextureSize.y);\n    float clusterU = cellIndex - (clusterV * cc_light_cluster_TextureSize.x);\n    clusterV = (clusterV + 0.5) * cc_light_cluster_TextureSize.z;\n    #if CC_LIGHT_MaxPixelsPerCell\n    for (float cellIndex = 0.5; cellIndex < float(CC_LIGHT_MaxPixelsPerCell); cellIndex++) {\n      vec4 lightIndices = texture2D(cc_light_cluster_Texture, vec2(cc_light_cluster_TextureSize.y * (clusterU + cellIndex), clusterV));\n      vec4 indices = lightIndices * 255.0;\n      for (int e = 0; e < 4; e++) {\n        if (indices[e] <= 0.0) {\n          break;\n        }\n        lightingCluster(indices[e], ShadingModelContext, MaterialParameters, shadowPos, color);\n      }\n      if (cellIndex > cc_light_cluster_CellsCountByBoundsSizeAndPixelsPerCell.w) {\n        break;\n      }\n    }\n    #endif\n  }\n  #endif\n  return vec4(color, ShadingModelContext.Opacity);\n}\nvoid InitShadingModelContext(inout FPixelMaterialInputs ShadingModelContext, FMaterialPixelParameters MaterialParameters) {\n  ShadingModelContext.RoughnessWithClamp = max(0.015625, ShadingModelContext.Roughness);\n  float NoV = max(dot(MaterialParameters.WorldNormal, MaterialParameters.CameraVector), 0.);\n  float DielectricSpecular = 0.08 * ShadingModelContext.Specular;\n  ShadingModelContext.DiffuseColor = ShadingModelContext.BaseColor - ShadingModelContext.BaseColor * ShadingModelContext.Metallic;\n  ShadingModelContext.SpecularColor = mix(0.08 * vec3(ShadingModelContext.Specular), ShadingModelContext.BaseColor, ShadingModelContext.Metallic);\n}\nvec4 lighting (FPixelMaterialInputs ShadingModelContext, FMaterialPixelParameters MaterialParameters, GlobalView View, vec4 shadowPos) {\n  vec4 color = vec4(vec3(0.), 1.);\n    #if CC_ENABLE_LIGHTING_BASE\n      color = lightingBase(ShadingModelContext, MaterialParameters, View, shadowPos);\n    #endif\n    #if CC_ENABLE_LIGHTING_ADD && (0 || 1)\n      color += lightingAdd(ShadingModelContext, MaterialParameters, shadowPos);\n    #endif\n  color *= ShadingModelContext.AmbientOcclusion;\n  return color;\n}\n#if CC_FORWARD_ADD\n#endif\nvec4 forward () {\n  FMaterialPixelParameters Parameters;\n  FPixelMaterialInputs PixelMaterialInputs;\n  GlobalView View;\n  surf(PixelMaterialInputs, Parameters, View);\n  lightingPerObject(Parameters, PixelMaterialInputs);\n  InitShadingModelContext(PixelMaterialInputs, Parameters);\n  vec4 color = lighting(PixelMaterialInputs, Parameters, View, v_shadowPos);\n  vec4 fogColor = CalculateHeightFog(Parameters.AbsoluteWorldPosition.xyz - cc_cameraPos.xyz);\n  color.rgb = color.rgb * fogColor.a + fogColor.rgb;\n  color.rgb *= View.PreExposure;\n  return color;\n}\nvoid deferred (out vec4 color0, out vec4 color1, out vec4 color2, out vec4 color3) {\n  FMaterialPixelParameters Parameters;\n  FPixelMaterialInputs PixelMaterialInputs;\n  GlobalView View;\n  surf(PixelMaterialInputs, Parameters, View);\n  lightingPerObject(Parameters, PixelMaterialInputs);\n  PixelMaterialInputs.DiffuseColor = max(PixelMaterialInputs.BaseColor - PixelMaterialInputs.BaseColor * PixelMaterialInputs.Metallic, 0.);\n  color0 = vec4(PixelMaterialInputs.BaseColor, PixelMaterialInputs.Opacity);\n  color1 = vec4(Parameters.AbsoluteWorldPosition, PixelMaterialInputs.Roughness);\n  color2 = vec4(Parameters.WorldNormal, PixelMaterialInputs.Metallic);\n  vec3 color = vec3(0.);\n  vec4 lightmapColor = GetLightMapColor(Parameters.WorldNormal);\n  Parameters.IndirectIrradiance += lightmapColor.a;\n  color += lightmapColor.xyz * PixelMaterialInputs.DiffuseColor * View.IndirectLightingColorScale;\n  color += PixelMaterialInputs.EmissiveColor;\n  color3 = vec4(color, Parameters.IndirectIrradiance * PixelMaterialInputs.AmbientOcclusion);\n}\n#if CC_TRANSPARENT || (CC_PIPELINE_TYPE == 0)\n  void main () {\n    gl_FragData[0] = forward();\n  }\n#elif CC_PIPELINE_TYPE == 1\n  void main () {\n    deferred(gl_FragData[0], gl_FragData[1], gl_FragData[2], gl_FragData[3]);\n  }\n#endif"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]},{"name":"CCCamera","defines":[]},{"name":"CCShadow","defines":[]},{"name":"CCCustomView","defines":[]}],"samplerTextures":[{"name":"cc_shadowMap","defines":["CC_RECEIVE_SHADOW"]},{"name":"cc_spotLightingMap","defines":["CC_RECEIVE_SHADOW"]},{"name":"cc_ibl_map_sky","defines":[]},{"name":"cc_ibl_cluster_InfoTexture","defines":[]},{"name":"cc_ibl_cluster_Texture","defines":[]},{"name":"cc_ibl_cluster_CubemapAtlas","defines":[]},{"name":"cc_planar_reflection_Texture","defines":[]},{"name":"cc_light_cluster_InfoTexture","defines":[]},{"name":"cc_light_cluster_Texture","defines":[]},{"name":"cc_environment","defines":["CC_ENABLE_CLUSTERED_LIGHT_CULLING","CC_ENABLE_Builtin_CLUSTERED_LIGHT_CULLING","CC_USE_IBL"]},{"name":"cc_diffuseMap","defines":["CC_ENABLE_CLUSTERED_LIGHT_CULLING","CC_ENABLE_Builtin_CLUSTERED_LIGHT_CULLING","CC_USE_IBL","CC_USE_DIFFUSEMAP"]}],"buffers":[],"images":[]},"locals":{"blocks":[{"name":"CCMorph","defines":["CC_USE_MORPH"]},{"name":"CCSkinningTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinningAnimation","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinning","defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION"]},{"name":"CCLocalBatched","defines":["!USE_INSTANCING","USE_BATCHING"]},{"name":"CCLocal","defines":["!USE_INSTANCING","!USE_BATCHING"]},{"name":"CCForwardLight","defines":["CC_FORWARD_ADD","CC_ENABLE_CLUSTERED_LIGHT_CULLING"]}],"samplerTextures":[{"name":"cc_PositionDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_POSITION"]},{"name":"cc_NormalDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_NORMAL"]},{"name":"cc_TangentDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_TANGENT"]},{"name":"cc_jointTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"cc_lightingMap","defines":["CC_USE_LIGHTMAP","!USE_BATCHING","!CC_FORWARD_ADD"]}],"buffers":[],"images":[]},"statistics":{"CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS":257,"CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS":109}},"defines":[{"name":"CC_USE_MORPH","type":"boolean","defines":[]},{"name":"CC_MORPH_TARGET_COUNT","type":"number","defines":["CC_USE_MORPH"],"range":[2,8]},{"name":"CC_MORPH_PRECOMPUTED","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_POSITION","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_NORMAL","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_TANGENT","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_USE_SKINNING","type":"boolean","defines":[]},{"name":"CC_USE_BAKED_ANIMATION","type":"boolean","defines":["CC_USE_SKINNING"]},{"name":"USE_INSTANCING","type":"boolean","defines":[],"editor":{"elevated":true}},{"name":"USE_BATCHING","type":"boolean","defines":["!USE_INSTANCING"],"editor":{"elevated":true}},{"name":"CC_USE_LIGHTMAP","type":"boolean","defines":[]},{"name":"CC_RECEIVE_SHADOW","type":"boolean","defines":[]},{"name":"CC_USE_ATTR_COLOR","type":"boolean","defines":[]},{"name":"CC_FORWARD_ADD","type":"boolean","defines":[]},{"name":"SAMPLE_FROM_RT","type":"boolean","defines":[]},{"name":"CC_IBL_MaxPixelsPerCell","type":"boolean","defines":[]},{"name":"CC_Lighting_Heavily","type":"boolean","defines":[]},{"name":"CC_ENABLE_IBL","type":"boolean","defines":["!CC_Lighting_Heavily"]},{"name":"CC_PIPELINE_TYPE","type":"number","defines":[],"range":[0,1]},{"name":"CC_FORCE_FORWARD_SHADING","type":"boolean","defines":["CC_FORWARD_ADD"]},{"name":"CC_ENABLE_Builtin_CLUSTERED_LIGHT_CULLING","type":"boolean","defines":["CC_ENABLE_CLUSTERED_LIGHT_CULLING"]},{"name":"CC_USE_IBL","type":"number","defines":["CC_ENABLE_CLUSTERED_LIGHT_CULLING","CC_ENABLE_Builtin_CLUSTERED_LIGHT_CULLING"],"range":[0,2]},{"name":"CC_USE_DIFFUSEMAP","type":"number","defines":["CC_ENABLE_CLUSTERED_LIGHT_CULLING","CC_ENABLE_Builtin_CLUSTERED_LIGHT_CULLING","CC_USE_IBL"],"range":[0,2]},{"name":"USE_REFLECTION_DENOISE","type":"boolean","defines":["CC_ENABLE_CLUSTERED_LIGHT_CULLING","CC_ENABLE_Builtin_CLUSTERED_LIGHT_CULLING"]},{"name":"CC_LIGHT_MaxPixelsPerCell","type":"boolean","defines":["!CC_ENABLE_CLUSTERED_LIGHT_CULLING","!CC_ENABLE_Builtin_CLUSTERED_LIGHT_CULLING"]},{"name":"CC_ENABLE_LIGHTING_BASE","type":"boolean","defines":[]},{"name":"CC_ENABLE_LIGHTING_ADD","type":"boolean","defines":[]},{"name":"CC_TRANSPARENT","type":"boolean","defines":[]}]},{"hash":3072557013,"name":"../resources/Exported/LakeWoodenHouse/Maps/TestPositionOffset|overdraw-vs:vert|overdraw-fs:frag","blocks":[],"samplerTextures":[],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[],"attributes":[{"name":"a_position","format":32,"location":0,"defines":[]},{"name":"a_normal","format":32,"location":1,"defines":[]},{"name":"a_texCoord","format":21,"location":2,"defines":[]},{"name":"a_tangent","format":44,"location":3,"defines":[]},{"name":"a_vertexId","format":11,"location":6,"defines":["CC_USE_MORPH"]},{"name":"a_joints","location":4,"defines":["CC_USE_SKINNING"]},{"name":"a_weights","format":44,"location":5,"defines":["CC_USE_SKINNING"]},{"name":"a_jointAnimInfo","format":44,"isInstanced":true,"location":7,"defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION","USE_INSTANCING"]},{"name":"a_matWorld0","format":44,"isInstanced":true,"location":8,"defines":["USE_INSTANCING"]},{"name":"a_matWorld1","format":44,"isInstanced":true,"location":9,"defines":["USE_INSTANCING"]},{"name":"a_matWorld2","format":44,"isInstanced":true,"location":10,"defines":["USE_INSTANCING"]},{"name":"a_lightingMapUVParam","format":44,"isInstanced":true,"location":11,"defines":["USE_INSTANCING","USE_LIGHTMAP"]},{"name":"a_dyn_batch_id","format":11,"location":12,"defines":["!USE_INSTANCING","USE_BATCHING"]}],"varyings":[],"fragColors":[{"name":"cc_FragColor","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":0,"defines":[]}],"glsl4":{"vert":"#extension GL_EXT_shader_explicit_arithmetic_types_int32: require\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec3 a_normal;\nlayout(location = 2) in vec2 a_texCoord;\nlayout(location = 3) in vec4 a_tangent;\n#if CC_USE_MORPH\n    int getVertexId() {\n      return gl_VertexIndex;\n    }\n  layout(set = 2, binding = 4) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n  };\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n        ivec2 texSize = textureSize(tex, 0);\n        return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture(tex, x)),\n        decode32(texture(tex, y)),\n        decode32(texture(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    layout(set = 2, binding = 7) uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    layout(set = 2, binding = 8) uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    layout(set = 2, binding = 9) uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout StandardVertInput attr) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    attr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    attr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    attr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n    layout(location = 4) in u32vec4 a_joints;\n  layout(location = 5) in vec4 a_weights;\n  #if CC_USE_BAKED_ANIMATION\n    #if USE_INSTANCING\n      layout(location = 7) in highp vec4 a_jointAnimInfo;\n    #endif\n    layout(set = 2, binding = 3) uniform CCSkinningTexture {\n      highp vec4 cc_jointTextureInfo;\n    };\n    layout(set = 2, binding = 2) uniform CCSkinningAnimation {\n      highp vec4 cc_jointAnimInfo;\n    };\n    layout(set = 2, binding = 6) uniform highp sampler2D cc_jointTexture;\n      #else\n    layout(set = 2, binding = 3) uniform CCSkinning {\n      highp vec4 cc_joints[30 * 3];\n    };\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout StandardVertInput attr) {\n    mat4 m = skinMatrix();\n    attr.position = m * attr.position;\n    attr.normal = (m * vec4(attr.normal, 0.0)).xyz;\n    attr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n  }\n#endif\n#if USE_INSTANCING\n  layout(location = 8) in vec4 a_matWorld0;\n  layout(location = 9) in vec4 a_matWorld1;\n  layout(location = 10) in vec4 a_matWorld2;\n  #if USE_LIGHTMAP\n    layout(location = 11) in vec4 a_lightingMapUVParam;\n  #endif\n#elif USE_BATCHING\n  layout(location = 12) in float a_dyn_batch_id;\n  layout(set = 2, binding = 0) uniform CCLocalBatched {\n    highp mat4 cc_matWorlds[10];\n  };\n#else\n  layout(set = 2, binding = 0) uniform CCLocal {\n    highp mat4 cc_matWorld;\n    highp mat4 cc_matWorldIT;\n    highp vec4 cc_lightingMapUVParam;\n  };\n#endif\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nvec4 vert () {\n  StandardVertInput In;\n      In.position = vec4(a_position, 1.0);\n      In.normal = a_normal;\n      In.tangent = a_tangent;\n    #if CC_USE_MORPH\n      applyMorph(In);\n    #endif\n    #if CC_USE_SKINNING\n      CCSkin(In);\n    #endif\n  mat4 matWorld, matWorldIT;\n    #if USE_INSTANCING\n      matWorld = mat4(\n        vec4(a_matWorld0.xyz, 0.0),\n        vec4(a_matWorld1.xyz, 0.0),\n        vec4(a_matWorld2.xyz, 0.0),\n        vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n      );\n      matWorldIT = matWorld;\n    #elif USE_BATCHING\n      matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n      matWorldIT = matWorld;\n    #else\n      matWorld = cc_matWorld;\n      matWorldIT = cc_matWorldIT;\n    #endif\n  return cc_matViewProj * matWorld * In.position;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\nvec4 frag () {\n  return vec4(0.5, 0.1, 0.1, 0.3);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"},"glsl3":{"vert":"\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\nin vec4 a_tangent;\n#if CC_USE_MORPH\n    in float a_vertexId;\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n  layout(std140) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n  };\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n        ivec2 texSize = textureSize(tex, 0);\n        return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture(tex, x)),\n        decode32(texture(tex, y)),\n        decode32(texture(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout StandardVertInput attr) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    attr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    attr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    attr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n    in vec4 a_joints;\n  in vec4 a_weights;\n  #if CC_USE_BAKED_ANIMATION\n    #if USE_INSTANCING\n      in highp vec4 a_jointAnimInfo;\n    #endif\n    layout(std140) uniform CCSkinningTexture {\n      highp vec4 cc_jointTextureInfo;\n    };\n    layout(std140) uniform CCSkinningAnimation {\n      highp vec4 cc_jointAnimInfo;\n    };\n    uniform highp sampler2D cc_jointTexture;\n      #else\n    layout(std140) uniform CCSkinning {\n      highp vec4 cc_joints[30 * 3];\n    };\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout StandardVertInput attr) {\n    mat4 m = skinMatrix();\n    attr.position = m * attr.position;\n    attr.normal = (m * vec4(attr.normal, 0.0)).xyz;\n    attr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n  }\n#endif\n#if USE_INSTANCING\n  in vec4 a_matWorld0;\n  in vec4 a_matWorld1;\n  in vec4 a_matWorld2;\n  #if USE_LIGHTMAP\n    in vec4 a_lightingMapUVParam;\n  #endif\n#elif USE_BATCHING\n  in float a_dyn_batch_id;\n  layout(std140) uniform CCLocalBatched {\n    highp mat4 cc_matWorlds[10];\n  };\n#else\n  layout(std140) uniform CCLocal {\n    highp mat4 cc_matWorld;\n    highp mat4 cc_matWorldIT;\n    highp vec4 cc_lightingMapUVParam;\n  };\n#endif\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nvec4 vert () {\n  StandardVertInput In;\n      In.position = vec4(a_position, 1.0);\n      In.normal = a_normal;\n      In.tangent = a_tangent;\n    #if CC_USE_MORPH\n      applyMorph(In);\n    #endif\n    #if CC_USE_SKINNING\n      CCSkin(In);\n    #endif\n  mat4 matWorld, matWorldIT;\n    #if USE_INSTANCING\n      matWorld = mat4(\n        vec4(a_matWorld0.xyz, 0.0),\n        vec4(a_matWorld1.xyz, 0.0),\n        vec4(a_matWorld2.xyz, 0.0),\n        vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n      );\n      matWorldIT = matWorld;\n    #elif USE_BATCHING\n      matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n      matWorldIT = matWorld;\n    #else\n      matWorld = cc_matWorld;\n      matWorldIT = cc_matWorldIT;\n    #endif\n  return cc_matViewProj * matWorld * In.position;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\nvec4 frag () {\n  return vec4(0.5, 0.1, 0.1, 0.3);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"},"glsl1":{"vert":"\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\nattribute vec4 a_tangent;\n#if CC_USE_MORPH\n    attribute float a_vertexId;\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n  uniform vec4 cc_displacementWeights[15];\n  uniform vec4 cc_displacementTextureInfo;\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n        int pixelIndex = elementIndex;\n        vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n        vec2 uv = getPixelCoordFromLocation(location, cc_displacementTextureInfo.xy);\n        return texture2D(tex, uv);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture2D(tex, x)),\n        decode32(texture2D(tex, y)),\n        decode32(texture2D(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout StandardVertInput attr) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    attr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    attr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    attr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n    attribute vec4 a_joints;\n  attribute vec4 a_weights;\n  #if CC_USE_BAKED_ANIMATION\n    #if USE_INSTANCING\n      attribute highp vec4 a_jointAnimInfo;\n    #endif\n    uniform highp vec4 cc_jointTextureInfo;\n    uniform highp vec4 cc_jointAnimInfo;\n    uniform highp sampler2D cc_jointTexture;\n      #else\n    uniform highp vec4 cc_joints[90];\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout StandardVertInput attr) {\n    mat4 m = skinMatrix();\n    attr.position = m * attr.position;\n    attr.normal = (m * vec4(attr.normal, 0.0)).xyz;\n    attr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n  }\n#endif\n#if USE_INSTANCING\n  attribute vec4 a_matWorld0;\n  attribute vec4 a_matWorld1;\n  attribute vec4 a_matWorld2;\n  #if USE_LIGHTMAP\n    attribute vec4 a_lightingMapUVParam;\n  #endif\n#elif USE_BATCHING\n  attribute float a_dyn_batch_id;\n  uniform highp mat4 cc_matWorlds[10];\n#else\n  uniform highp mat4 cc_matWorld;\n  uniform highp mat4 cc_matWorldIT;\n#endif\nuniform highp mat4 cc_matViewProj;\nvec4 vert () {\n  StandardVertInput In;\n      In.position = vec4(a_position, 1.0);\n      In.normal = a_normal;\n      In.tangent = a_tangent;\n    #if CC_USE_MORPH\n      applyMorph(In);\n    #endif\n    #if CC_USE_SKINNING\n      CCSkin(In);\n    #endif\n  mat4 matWorld, matWorldIT;\n    #if USE_INSTANCING\n      matWorld = mat4(\n        vec4(a_matWorld0.xyz, 0.0),\n        vec4(a_matWorld1.xyz, 0.0),\n        vec4(a_matWorld2.xyz, 0.0),\n        vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n      );\n      matWorldIT = matWorld;\n    #elif USE_BATCHING\n      matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n      matWorldIT = matWorld;\n    #else\n      matWorld = cc_matWorld;\n      matWorldIT = cc_matWorldIT;\n    #endif\n  return cc_matViewProj * matWorld * In.position;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\nvec4 frag () {\n  return vec4(0.5, 0.1, 0.1, 0.3);\n}\nvoid main() { gl_FragColor = frag(); }"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]},{"name":"CCCamera","defines":[]}],"samplerTextures":[],"buffers":[],"images":[]},"locals":{"blocks":[{"name":"CCMorph","defines":["CC_USE_MORPH"]},{"name":"CCSkinningTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinningAnimation","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinning","defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION"]},{"name":"CCLocalBatched","defines":["!USE_INSTANCING","USE_BATCHING"]},{"name":"CCLocal","defines":["!USE_INSTANCING","!USE_BATCHING"]}],"samplerTextures":[{"name":"cc_PositionDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_POSITION"]},{"name":"cc_NormalDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_NORMAL"]},{"name":"cc_TangentDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_TANGENT"]},{"name":"cc_jointTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]}],"buffers":[],"images":[]},"statistics":{"CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS":196,"CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS":0}},"defines":[{"name":"CC_USE_MORPH","type":"boolean","defines":[]},{"name":"CC_MORPH_TARGET_COUNT","type":"number","defines":["CC_USE_MORPH"],"range":[2,8]},{"name":"CC_MORPH_PRECOMPUTED","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_POSITION","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_NORMAL","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_TANGENT","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_USE_SKINNING","type":"boolean","defines":[]},{"name":"CC_USE_BAKED_ANIMATION","type":"boolean","defines":["CC_USE_SKINNING"]},{"name":"USE_INSTANCING","type":"boolean","defines":[],"editor":{"elevated":true}},{"name":"USE_BATCHING","type":"boolean","defines":["!USE_INSTANCING"],"editor":{"elevated":true}},{"name":"USE_LIGHTMAP","type":"boolean","defines":["USE_INSTANCING"]}]},{"hash":4223129997,"name":"../resources/Exported/LakeWoodenHouse/Maps/TestPositionOffset|shadow-caster-vs:vert|shadow-caster-fs:frag","blocks":[],"samplerTextures":[],"samplers":[],"textures":[],"buffers":[{"name":"b_ccLightsBuffer","memoryAccess":1,"stageFlags":16,"binding":0,"defines":["CC_ENABLE_CLUSTERED_LIGHT_CULLING","CC_ENABLE_Builtin_CLUSTERED_LIGHT_CULLING"]},{"name":"b_clusterLightIndicesBuffer","memoryAccess":1,"stageFlags":16,"binding":1,"defines":["CC_ENABLE_CLUSTERED_LIGHT_CULLING","CC_ENABLE_Builtin_CLUSTERED_LIGHT_CULLING"]},{"name":"b_clusterLightGridBuffer","memoryAccess":1,"stageFlags":16,"binding":2,"defines":["CC_ENABLE_CLUSTERED_LIGHT_CULLING","CC_ENABLE_Builtin_CLUSTERED_LIGHT_CULLING"]}],"images":[],"subpassInputs":[],"attributes":[{"name":"a_position","format":32,"location":0,"defines":[]},{"name":"a_normal","format":32,"location":1,"defines":[]},{"name":"a_texCoord","format":21,"location":2,"defines":[]},{"name":"a_tangent","format":44,"location":3,"defines":[]},{"name":"a_vertexId","format":11,"location":6,"defines":["CC_USE_MORPH"]},{"name":"a_joints","location":4,"defines":["CC_USE_SKINNING"]},{"name":"a_weights","format":44,"location":5,"defines":["CC_USE_SKINNING"]},{"name":"a_jointAnimInfo","format":44,"isInstanced":true,"location":7,"defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION","USE_INSTANCING"]},{"name":"a_matWorld0","format":44,"isInstanced":true,"location":8,"defines":["USE_INSTANCING"]},{"name":"a_matWorld1","format":44,"isInstanced":true,"location":9,"defines":["USE_INSTANCING"]},{"name":"a_matWorld2","format":44,"isInstanced":true,"location":10,"defines":["USE_INSTANCING"]},{"name":"a_lightingMapUVParam","format":44,"isInstanced":true,"location":11,"defines":["USE_INSTANCING","USE_LIGHTMAP"]},{"name":"a_dyn_batch_id","format":11,"location":12,"defines":["!USE_INSTANCING","USE_BATCHING"]}],"varyings":[{"name":"v_worldPos","type":16,"count":1,"stageFlags":17,"location":0,"defines":[]},{"name":"v_clip_depth","type":13,"count":1,"stageFlags":17,"location":1,"defines":[]},{"name":"v_uv","type":14,"count":1,"stageFlags":17,"location":2,"defines":[]},{"name":"v_color","type":16,"count":1,"stageFlags":16,"location":3,"defines":["CC_USE_ATTR_COLOR"]},{"name":"v_obj_position","type":15,"count":1,"stageFlags":16,"location":4,"defines":[]},{"name":"v_position","type":15,"count":1,"stageFlags":16,"location":5,"defines":[]},{"name":"v_normal","type":15,"count":1,"stageFlags":16,"location":6,"defines":[]},{"name":"v_uv1","type":14,"count":1,"stageFlags":16,"location":7,"defines":[]},{"name":"v_tangent","type":15,"count":1,"stageFlags":16,"location":8,"defines":[]},{"name":"v_bitangent","type":15,"count":1,"stageFlags":16,"location":9,"defines":[]},{"name":"v_shadowPos","type":16,"count":1,"stageFlags":16,"location":10,"defines":[]},{"name":"v_luv","type":15,"count":1,"stageFlags":16,"location":11,"defines":["CC_USE_LIGHTMAP","!USE_BATCHING","!CC_FORWARD_ADD"]},{"name":"v_lightingMapAdds0","type":16,"count":1,"stageFlags":16,"location":12,"defines":["CC_USE_LIGHTMAP","!USE_BATCHING","!CC_FORWARD_ADD","USE_INSTANCING"]},{"name":"v_lightingMapAdds1","type":16,"count":1,"stageFlags":16,"location":13,"defines":["CC_USE_LIGHTMAP","!USE_BATCHING","!CC_FORWARD_ADD","USE_INSTANCING"]},{"name":"v_lightingMapScales0","type":16,"count":1,"stageFlags":16,"location":14,"defines":["CC_USE_LIGHTMAP","!USE_BATCHING","!CC_FORWARD_ADD","USE_INSTANCING"]},{"name":"v_lightingMapScales1","type":16,"count":1,"stageFlags":16,"location":15,"defines":["CC_USE_LIGHTMAP","!USE_BATCHING","!CC_FORWARD_ADD","USE_INSTANCING"]}],"fragColors":[{"name":"cc_FragColor","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":0,"defines":[]}],"glsl4":{"vert":"#extension GL_EXT_shader_explicit_arithmetic_types_int32: require\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec3 a_normal;\nlayout(location = 2) in vec2 a_texCoord;\nlayout(location = 3) in vec4 a_tangent;\n#if CC_USE_MORPH\n    int getVertexId() {\n      return gl_VertexIndex;\n    }\n  layout(set = 2, binding = 4) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n  };\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n        ivec2 texSize = textureSize(tex, 0);\n        return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture(tex, x)),\n        decode32(texture(tex, y)),\n        decode32(texture(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    layout(set = 2, binding = 7) uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    layout(set = 2, binding = 8) uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    layout(set = 2, binding = 9) uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout StandardVertInput attr) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    attr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    attr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    attr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n    layout(location = 4) in u32vec4 a_joints;\n  layout(location = 5) in vec4 a_weights;\n  #if CC_USE_BAKED_ANIMATION\n    #if USE_INSTANCING\n      layout(location = 7) in highp vec4 a_jointAnimInfo;\n    #endif\n    layout(set = 2, binding = 3) uniform CCSkinningTexture {\n      highp vec4 cc_jointTextureInfo;\n    };\n    layout(set = 2, binding = 2) uniform CCSkinningAnimation {\n      highp vec4 cc_jointAnimInfo;\n    };\n    layout(set = 2, binding = 6) uniform highp sampler2D cc_jointTexture;\n      #else\n    layout(set = 2, binding = 3) uniform CCSkinning {\n      highp vec4 cc_joints[30 * 3];\n    };\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout StandardVertInput attr) {\n    mat4 m = skinMatrix();\n    attr.position = m * attr.position;\n    attr.normal = (m * vec4(attr.normal, 0.0)).xyz;\n    attr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n  }\n#endif\n#if USE_INSTANCING\n  layout(location = 8) in vec4 a_matWorld0;\n  layout(location = 9) in vec4 a_matWorld1;\n  layout(location = 10) in vec4 a_matWorld2;\n  #if USE_LIGHTMAP\n    layout(location = 11) in vec4 a_lightingMapUVParam;\n  #endif\n#elif USE_BATCHING\n  layout(location = 12) in float a_dyn_batch_id;\n  layout(set = 2, binding = 0) uniform CCLocalBatched {\n    highp mat4 cc_matWorlds[10];\n  };\n#else\n  layout(set = 2, binding = 0) uniform CCLocal {\n    highp mat4 cc_matWorld;\n    highp mat4 cc_matWorldIT;\n    highp vec4 cc_lightingMapUVParam;\n  };\n#endif\nlayout(set = 0, binding = 2) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  lowp  vec4 cc_shadowNFLSInfo;\n  lowp  vec4 cc_shadowWHPBInfo;\n  lowp  vec4 cc_shadowLPNNInfo;\n  lowp  vec4 cc_shadowColor;\n};\nlayout(location = 0) out vec4 v_worldPos;\nlayout(location = 1) out float v_clip_depth;\nlayout(location = 2) out vec2 v_uv;\nvec4 vert () {\n  StandardVertInput In;\n      In.position = vec4(a_position, 1.0);\n      In.normal = a_normal;\n      In.tangent = a_tangent;\n    #if CC_USE_MORPH\n      applyMorph(In);\n    #endif\n    #if CC_USE_SKINNING\n      CCSkin(In);\n    #endif\n  mat4 matWorld, matWorldIT;\n    #if USE_INSTANCING\n      matWorld = mat4(\n        vec4(a_matWorld0.xyz, 0.0),\n        vec4(a_matWorld1.xyz, 0.0),\n        vec4(a_matWorld2.xyz, 0.0),\n        vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n      );\n      matWorldIT = matWorld;\n    #elif USE_BATCHING\n      matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n      matWorldIT = matWorld;\n    #else\n      matWorld = cc_matWorld;\n      matWorldIT = cc_matWorldIT;\n    #endif\n  v_worldPos = matWorld * In.position;\n  vec4 clipPos = cc_matLightViewProj * v_worldPos;\n  v_uv = a_texCoord;\n  v_clip_depth = clipPos.z / clipPos.w * 0.5 + 0.5;\n  return clipPos;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\nvec4 packDepthToRGBA (float depth) {\n  vec4 ret = vec4(1.0, 255.0, 65025.0, 16581375.0) * depth;\n  ret = fract(ret);\n  ret -= vec4(ret.yzw, 0.0) / 255.0;\n  return ret;\n}\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nlayout(set = 0, binding = 2) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  lowp  vec4 cc_shadowNFLSInfo;\n  lowp  vec4 cc_shadowWHPBInfo;\n  lowp  vec4 cc_shadowLPNNInfo;\n  lowp  vec4 cc_shadowColor;\n};\nfloat CCGetLinearDepthFromViewSpace(vec3 viewPos) {\n  float dist = length(viewPos);\n  return (dist - cc_shadowNFLSInfo.x) / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\n  vec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n  return CCGetLinearDepthFromViewSpace(viewStartPos.xyz);\n}\n#if CC_RECEIVE_SHADOW\n  layout(set = 0, binding = 3) uniform highp sampler2D cc_shadowMap;\n  layout(set = 0, binding = 5) uniform highp sampler2D cc_spotLightingMap;\n#endif\n  layout(set = 2, binding = 0) uniform CCLocal {\n    highp mat4 cc_matWorld;\n    highp mat4 cc_matWorldIT;\n    highp vec4 cc_lightingMapUVParam;\n  };\n  layout(set = 0, binding = 7) uniform CCCustomView {\n      mat4 cc_view_taa_prev_viewProj;\n      mat4 cc_view_inverse_transpose_mirror;\n      vec4 cc_view_pr_reflectionPlane;\n      vec4 cc_view_pr_parameters;\n      vec4 cc_view_SkyIrradianceEnvironmentMap[7];\n      vec4 cc_view_SkyColor;\n      vec4 cc_view_SkyLightParameters;\n      vec4 cc_view_IndirectLightingColorScale_Intensity;\n      vec4 cc_view_PreExposure;\n      vec4 cc_view_taa_params1;\n      vec4 cc_view_taa_params2;\n      vec4 cc_view_final_screen_params;\n      vec4 cc_ibl_cluster_BoundsMin;\n      vec4 cc_ibl_cluster_BoundsDelta;\n      vec4 cc_ibl_cluster_CellsDot;\n      vec4 cc_ibl_cluster_CellsMax;\n      vec4 cc_ibl_cluster_TextureSize;\n      vec4 cc_ibl_cluster_InfoTextureInvSize;\n      vec4 cc_ibl_cluster_CellsCountByBoundsSizeAndPixelsPerCell;\n      vec4 cc_light_cluster_BoundsMin;\n      vec4 cc_light_cluster_BoundsDelta;\n      vec4 cc_light_cluster_CellsDot;\n      vec4 cc_light_cluster_CellsMax;\n      vec4 cc_light_cluster_TextureSize;\n      vec4 cc_light_cluster_InfoTextureInvSize;\n      vec4 cc_light_cluster_CellsCountByBoundsSizeAndPixelsPerCell;\n      vec4 FogStruct_ExponentialFogParameters;\n      vec4 FogStruct_ExponentialFogColorParameter;\n      vec4 FogStruct_ExponentialFogParameters2;\n      vec4 FogStruct_ExponentialFogParameters3;\n  };\n  struct GlobalView {\n      vec3 IndirectLightingColorScale;\n      float PreExposure;\n  };\nstruct Light {\n  vec3 color;\n  vec3 direction;\n};\nstruct FDirectLighting\n{\n  vec3 Diffuse;\n  vec3 Specular;\n};\nstruct FPixelMaterialInputs\n{\n  vec3 Normal;\n  vec3 EmissiveColor;\n  float Opacity;\n  float OpacityMask;\n  vec3 BaseColor;\n  float Metallic;\n  float Specular;\n  float Roughness;\n  float AmbientOcclusion;\n  float Anisotropy;\n  float Tangent;\n  float Refraction;\n  float PixelDepthOffset;\n  float ShadingModel;\n  float TwoSidedSign;\n  float RoughnessWithClamp;\n  vec3 DiffuseColor;\n  vec3 SpecularColor;\n  vec3 Subsurface;\n};\nstruct FMaterialPixelParameters {\n  float IndirectIrradiance;\n  vec2 TexCoords_0;\n  vec2 TexCoords_1;\n  vec4 VertexColor;\n  vec3 WorldNormal;\n  vec3 WorldTangent;\n  vec3 ReflectionVector;\n  vec3 CameraVector;\n  vec3 LightVector;\n  vec4 SvPosition;\n  vec4 ScreenPosition;\n  mat3 TangentToWorld;\n  vec3 AbsoluteWorldPosition;\n  vec3 ObjectWorldPosition;\n  vec2 LightmapUVs;\n  int PrimitiveId;\n};\nstruct FMaterialVertexParameters {\n  vec3 WorldPosition;\n  vec4 VertexColor;\n};\n  vec3 GetMaterialNormalRaw(FPixelMaterialInputs PixelMaterialInputs) {\n      return vec3 ((PixelMaterialInputs).Normal);\n  }\n  vec3 GetMaterialNormal(FMaterialPixelParameters Parameters, FPixelMaterialInputs PixelMaterialInputs) {\n      vec3 RetNormal = GetMaterialNormalRaw(PixelMaterialInputs);\n      return RetNormal;\n  }\n  vec3 TransformTangentNormalToWorld(mat3 TangentToWorld, vec3 normal) {\n      return normalize((TangentToWorld * normalize(normal)));\n  }\n  vec3 ReflectionAboutCustomWorldNormal(inout FMaterialPixelParameters Parameters, vec3 WorldNormal, bool bNormalizeInputNormal) {\n      ((Parameters).WorldNormal = (TransformTangentNormalToWorld((Parameters).TangentToWorld, (Parameters).WorldNormal)).xzy);\n      ((Parameters).ReflectionVector = normalize(reflect((-(Parameters).CameraVector), (Parameters).WorldNormal)));\n      return (Parameters).ReflectionVector;\n  }\n   vec4 F4_0101 = vec4(0, 1, 0, 1);\nvoid CalcPixelMaterialInputs(inout FMaterialPixelParameters Parameters, inout FPixelMaterialInputs PixelMaterialInputs) {\n    ((PixelMaterialInputs).Normal = vec3(0.000000, 0.000000, 1.000000));\n    vec3 MaterialNormal = vec3 (GetMaterialNormal(Parameters, PixelMaterialInputs));\n    ((Parameters).WorldNormal = normalize(MaterialNormal));\n    ((Parameters).ReflectionVector = ReflectionAboutCustomWorldNormal(Parameters, (Parameters).WorldNormal, false));\n    ((PixelMaterialInputs).EmissiveColor = vec3(0.000000, 0.000000, 0.000000));\n    ((PixelMaterialInputs).Opacity = 1.000000);\n    ((PixelMaterialInputs).OpacityMask = 1.000000);\n    ((PixelMaterialInputs).BaseColor = vec3(0.270222, 0.242972, 0.937500));\n    ((PixelMaterialInputs).Metallic = 0.000000);\n    ((PixelMaterialInputs).Specular = 0.500000);\n    ((PixelMaterialInputs).Roughness = 0.500000);\n    ((PixelMaterialInputs).Anisotropy = 0.000000);\n    ((PixelMaterialInputs).Tangent = float (vec3(1.000000, 0.000000, 0.000000)));\n    ((PixelMaterialInputs).Subsurface = vec3 (0));\n    ((PixelMaterialInputs).AmbientOcclusion = 1.000000);\n    ((Parameters).WorldTangent = vec3 (0));\n}\n#if CC_USE_ATTR_COLOR\nlayout(location = 3) in vec4 v_color;\n#endif\nlayout(location = 4) in vec3 v_obj_position;\nlayout(location = 5) in vec3 v_position;\nlayout(location = 6) in vec3 v_normal;\nlayout(location = 2) in vec2 v_uv;\nlayout(location = 7) in vec2 v_uv1;\nlayout(location = 8) in vec3 v_tangent;\nlayout(location = 9) in vec3 v_bitangent;\n  layout(location = 10) in highp vec4 v_shadowPos;\nconst float FLT_EPSILON = 0.001;\nconst float FLT_EPSILON2 = 0.01;\nlayout(set = 0, binding = 9) uniform samplerCube cc_ibl_map_sky;\nlayout(set = 0, binding = 10) uniform sampler2D cc_ibl_cluster_InfoTexture;\nlayout(set = 0, binding = 11) uniform sampler2D cc_ibl_cluster_Texture;\nlayout(set = 0, binding = 12) uniform sampler2D cc_ibl_cluster_CubemapAtlas;\nlayout(set = 0, binding = 15) uniform sampler2D cc_planar_reflection_Texture;\n#if (CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD)\n    layout(location = 11) in vec3 v_luv;\n    layout(set = 2, binding = 10) uniform sampler2D cc_lightingMap;\n    #if USE_INSTANCING\n      layout(location = 12) in vec4 v_lightingMapAdds0;\n      layout(location = 13) in vec4 v_lightingMapAdds1;\n      layout(location = 14) in vec4 v_lightingMapScales0;\n      layout(location = 15) in vec4 v_lightingMapScales1;\n    #endif\n#endif\n#if CC_FORWARD_ADD\n#if CC_PIPELINE_TYPE == 0\n# define LIGHTS_PER_PASS 1\n#else\n# define LIGHTS_PER_PASS 10\n#endif\n#if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\nlayout(set = 2, binding = 1) uniform CCForwardLight {\n  highp vec4 cc_lightPos[LIGHTS_PER_PASS];\n  vec4 cc_lightColor[LIGHTS_PER_PASS];\n  vec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];\n  vec4 cc_lightDir[LIGHTS_PER_PASS];\n};\n#endif\n#endif\nlayout(set = 0, binding = 13) uniform sampler2D cc_light_cluster_InfoTexture;\nlayout(set = 0, binding = 14) uniform sampler2D cc_light_cluster_Texture;\n#if CC_ENABLE_CLUSTERED_LIGHT_CULLING && CC_ENABLE_Builtin_CLUSTERED_LIGHT_CULLING\n  #if CC_USE_IBL\n    layout(set = 0, binding = 4) uniform samplerCube cc_environment;\n    #if CC_USE_DIFFUSEMAP\n      layout(set = 0, binding = 6) uniform samplerCube cc_diffuseMap;\n    #endif\n  #endif\n  #if USE_REFLECTION_DENOISE\n  #endif\n  struct StandardSurface {\n    vec4 albedo;\n    vec3 position;\n    vec3 normal;\n    vec3 emissive;\n    vec3 lightmap;\n    float lightmap_test;\n    float roughness;\n    float metallic;\n    float occlusion;\n  };\n  layout(set = 1, binding = 0) readonly buffer b_ccLightsBuffer { vec4 b_ccLights[]; };\n  layout(set = 1, binding = 1) readonly buffer b_clusterLightIndicesBuffer { uint b_clusterLightIndices[]; };\n  layout(set = 1, binding = 2) readonly buffer b_clusterLightGridBuffer { uvec4 b_clusterLightGrid[]; };\n  struct CCLight\n  {\n    vec4 cc_lightPos;\n    vec4 cc_lightColor;\n    vec4 cc_lightSizeRangeAngle;\n    vec4 cc_lightDir;\n  };\n  struct Cluster\n  {\n    vec3 minBounds;\n    vec3 maxBounds;\n  };\n  struct LightGrid\n  {\n    uint offset;\n    uint ccLights;\n  };\n#endif\nlayout(location = 0) in vec4 v_worldPos;\nlayout(location = 1) in float v_clip_depth;\nvec4 frag () {\n  FMaterialPixelParameters Parameters;\n  Parameters.TexCoords_0 = v_uv;\n  FPixelMaterialInputs PixelMaterialInputs;\n  CalcPixelMaterialInputs(Parameters, PixelMaterialInputs);\n  if (PixelMaterialInputs.OpacityMask < 0.33330) {\n    discard;\n  }\n  if(cc_shadowLPNNInfo.x > 0.000001 && cc_shadowLPNNInfo.x < 1.999999) {\n    if (cc_shadowNFLSInfo.z > 0.000001) {\n      return vec4(CCGetLinearDepth(v_worldPos.xyz), 1.0, 1.0, 1.0);\n    }\n  }\n  if (cc_shadowLPNNInfo.y > 0.000001) {\n    return packDepthToRGBA(v_clip_depth);\n  }\n  return vec4(v_clip_depth, 1.0, 1.0, 1.0);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"},"glsl3":{"vert":"\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\nin vec4 a_tangent;\n#if CC_USE_MORPH\n    in float a_vertexId;\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n  layout(std140) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n  };\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n        ivec2 texSize = textureSize(tex, 0);\n        return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture(tex, x)),\n        decode32(texture(tex, y)),\n        decode32(texture(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout StandardVertInput attr) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    attr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    attr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    attr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n    in vec4 a_joints;\n  in vec4 a_weights;\n  #if CC_USE_BAKED_ANIMATION\n    #if USE_INSTANCING\n      in highp vec4 a_jointAnimInfo;\n    #endif\n    layout(std140) uniform CCSkinningTexture {\n      highp vec4 cc_jointTextureInfo;\n    };\n    layout(std140) uniform CCSkinningAnimation {\n      highp vec4 cc_jointAnimInfo;\n    };\n    uniform highp sampler2D cc_jointTexture;\n      #else\n    layout(std140) uniform CCSkinning {\n      highp vec4 cc_joints[30 * 3];\n    };\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout StandardVertInput attr) {\n    mat4 m = skinMatrix();\n    attr.position = m * attr.position;\n    attr.normal = (m * vec4(attr.normal, 0.0)).xyz;\n    attr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n  }\n#endif\n#if USE_INSTANCING\n  in vec4 a_matWorld0;\n  in vec4 a_matWorld1;\n  in vec4 a_matWorld2;\n  #if USE_LIGHTMAP\n    in vec4 a_lightingMapUVParam;\n  #endif\n#elif USE_BATCHING\n  in float a_dyn_batch_id;\n  layout(std140) uniform CCLocalBatched {\n    highp mat4 cc_matWorlds[10];\n  };\n#else\n  layout(std140) uniform CCLocal {\n    highp mat4 cc_matWorld;\n    highp mat4 cc_matWorldIT;\n    highp vec4 cc_lightingMapUVParam;\n  };\n#endif\nlayout(std140) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  lowp  vec4 cc_shadowNFLSInfo;\n  lowp  vec4 cc_shadowWHPBInfo;\n  lowp  vec4 cc_shadowLPNNInfo;\n  lowp  vec4 cc_shadowColor;\n};\nout vec4 v_worldPos;\nout float v_clip_depth;\nout vec2 v_uv;\nvec4 vert () {\n  StandardVertInput In;\n      In.position = vec4(a_position, 1.0);\n      In.normal = a_normal;\n      In.tangent = a_tangent;\n    #if CC_USE_MORPH\n      applyMorph(In);\n    #endif\n    #if CC_USE_SKINNING\n      CCSkin(In);\n    #endif\n  mat4 matWorld, matWorldIT;\n    #if USE_INSTANCING\n      matWorld = mat4(\n        vec4(a_matWorld0.xyz, 0.0),\n        vec4(a_matWorld1.xyz, 0.0),\n        vec4(a_matWorld2.xyz, 0.0),\n        vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n      );\n      matWorldIT = matWorld;\n    #elif USE_BATCHING\n      matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n      matWorldIT = matWorld;\n    #else\n      matWorld = cc_matWorld;\n      matWorldIT = cc_matWorldIT;\n    #endif\n  v_worldPos = matWorld * In.position;\n  vec4 clipPos = cc_matLightViewProj * v_worldPos;\n  v_uv = a_texCoord;\n  v_clip_depth = clipPos.z / clipPos.w * 0.5 + 0.5;\n  return clipPos;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\nvec4 packDepthToRGBA (float depth) {\n  vec4 ret = vec4(1.0, 255.0, 65025.0, 16581375.0) * depth;\n  ret = fract(ret);\n  ret -= vec4(ret.yzw, 0.0) / 255.0;\n  return ret;\n}\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nlayout(std140) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  lowp  vec4 cc_shadowNFLSInfo;\n  lowp  vec4 cc_shadowWHPBInfo;\n  lowp  vec4 cc_shadowLPNNInfo;\n  lowp  vec4 cc_shadowColor;\n};\nfloat CCGetLinearDepthFromViewSpace(vec3 viewPos) {\n  float dist = length(viewPos);\n  return (dist - cc_shadowNFLSInfo.x) / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\n  vec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n  return CCGetLinearDepthFromViewSpace(viewStartPos.xyz);\n}\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotLightingMap;\n#endif\n  layout(std140) uniform CCLocal {\n    highp mat4 cc_matWorld;\n    highp mat4 cc_matWorldIT;\n    highp vec4 cc_lightingMapUVParam;\n  };\n  layout(std140) uniform CCCustomView {\n      mat4 cc_view_taa_prev_viewProj;\n      mat4 cc_view_inverse_transpose_mirror;\n      vec4 cc_view_pr_reflectionPlane;\n      vec4 cc_view_pr_parameters;\n      vec4 cc_view_SkyIrradianceEnvironmentMap[7];\n      vec4 cc_view_SkyColor;\n      vec4 cc_view_SkyLightParameters;\n      vec4 cc_view_IndirectLightingColorScale_Intensity;\n      vec4 cc_view_PreExposure;\n      vec4 cc_view_taa_params1;\n      vec4 cc_view_taa_params2;\n      vec4 cc_view_final_screen_params;\n      vec4 cc_ibl_cluster_BoundsMin;\n      vec4 cc_ibl_cluster_BoundsDelta;\n      vec4 cc_ibl_cluster_CellsDot;\n      vec4 cc_ibl_cluster_CellsMax;\n      vec4 cc_ibl_cluster_TextureSize;\n      vec4 cc_ibl_cluster_InfoTextureInvSize;\n      vec4 cc_ibl_cluster_CellsCountByBoundsSizeAndPixelsPerCell;\n      vec4 cc_light_cluster_BoundsMin;\n      vec4 cc_light_cluster_BoundsDelta;\n      vec4 cc_light_cluster_CellsDot;\n      vec4 cc_light_cluster_CellsMax;\n      vec4 cc_light_cluster_TextureSize;\n      vec4 cc_light_cluster_InfoTextureInvSize;\n      vec4 cc_light_cluster_CellsCountByBoundsSizeAndPixelsPerCell;\n      vec4 FogStruct_ExponentialFogParameters;\n      vec4 FogStruct_ExponentialFogColorParameter;\n      vec4 FogStruct_ExponentialFogParameters2;\n      vec4 FogStruct_ExponentialFogParameters3;\n  };\n  struct GlobalView {\n      vec3 IndirectLightingColorScale;\n      float PreExposure;\n  };\nstruct Light {\n  vec3 color;\n  vec3 direction;\n};\nstruct FDirectLighting\n{\n  vec3 Diffuse;\n  vec3 Specular;\n};\nstruct FPixelMaterialInputs\n{\n  vec3 Normal;\n  vec3 EmissiveColor;\n  float Opacity;\n  float OpacityMask;\n  vec3 BaseColor;\n  float Metallic;\n  float Specular;\n  float Roughness;\n  float AmbientOcclusion;\n  float Anisotropy;\n  float Tangent;\n  float Refraction;\n  float PixelDepthOffset;\n  float ShadingModel;\n  float TwoSidedSign;\n  float RoughnessWithClamp;\n  vec3 DiffuseColor;\n  vec3 SpecularColor;\n  vec3 Subsurface;\n};\nstruct FMaterialPixelParameters {\n  float IndirectIrradiance;\n  vec2 TexCoords_0;\n  vec2 TexCoords_1;\n  vec4 VertexColor;\n  vec3 WorldNormal;\n  vec3 WorldTangent;\n  vec3 ReflectionVector;\n  vec3 CameraVector;\n  vec3 LightVector;\n  vec4 SvPosition;\n  vec4 ScreenPosition;\n  mat3 TangentToWorld;\n  vec3 AbsoluteWorldPosition;\n  vec3 ObjectWorldPosition;\n  vec2 LightmapUVs;\n  int PrimitiveId;\n};\nstruct FMaterialVertexParameters {\n  vec3 WorldPosition;\n  vec4 VertexColor;\n};\n  vec3 GetMaterialNormalRaw(FPixelMaterialInputs PixelMaterialInputs) {\n      return vec3 ((PixelMaterialInputs).Normal);\n  }\n  vec3 GetMaterialNormal(FMaterialPixelParameters Parameters, FPixelMaterialInputs PixelMaterialInputs) {\n      vec3 RetNormal = GetMaterialNormalRaw(PixelMaterialInputs);\n      return RetNormal;\n  }\n  vec3 TransformTangentNormalToWorld(mat3 TangentToWorld, vec3 normal) {\n      return normalize((TangentToWorld * normalize(normal)));\n  }\n  vec3 ReflectionAboutCustomWorldNormal(inout FMaterialPixelParameters Parameters, vec3 WorldNormal, bool bNormalizeInputNormal) {\n      ((Parameters).WorldNormal = (TransformTangentNormalToWorld((Parameters).TangentToWorld, (Parameters).WorldNormal)).xzy);\n      ((Parameters).ReflectionVector = normalize(reflect((-(Parameters).CameraVector), (Parameters).WorldNormal)));\n      return (Parameters).ReflectionVector;\n  }\n   vec4 F4_0101 = vec4(0, 1, 0, 1);\nvoid CalcPixelMaterialInputs(inout FMaterialPixelParameters Parameters, inout FPixelMaterialInputs PixelMaterialInputs) {\n    ((PixelMaterialInputs).Normal = vec3(0.000000, 0.000000, 1.000000));\n    vec3 MaterialNormal = vec3 (GetMaterialNormal(Parameters, PixelMaterialInputs));\n    ((Parameters).WorldNormal = normalize(MaterialNormal));\n    ((Parameters).ReflectionVector = ReflectionAboutCustomWorldNormal(Parameters, (Parameters).WorldNormal, false));\n    ((PixelMaterialInputs).EmissiveColor = vec3(0.000000, 0.000000, 0.000000));\n    ((PixelMaterialInputs).Opacity = 1.000000);\n    ((PixelMaterialInputs).OpacityMask = 1.000000);\n    ((PixelMaterialInputs).BaseColor = vec3(0.270222, 0.242972, 0.937500));\n    ((PixelMaterialInputs).Metallic = 0.000000);\n    ((PixelMaterialInputs).Specular = 0.500000);\n    ((PixelMaterialInputs).Roughness = 0.500000);\n    ((PixelMaterialInputs).Anisotropy = 0.000000);\n    ((PixelMaterialInputs).Tangent = float (vec3(1.000000, 0.000000, 0.000000)));\n    ((PixelMaterialInputs).Subsurface = vec3 (0));\n    ((PixelMaterialInputs).AmbientOcclusion = 1.000000);\n    ((Parameters).WorldTangent = vec3 (0));\n}\n#if CC_USE_ATTR_COLOR\nin vec4 v_color;\n#endif\nin vec3 v_obj_position;\nin vec3 v_position;\nin vec3 v_normal;\nin vec2 v_uv;\nin vec2 v_uv1;\nin vec3 v_tangent;\nin vec3 v_bitangent;\n  in highp vec4 v_shadowPos;\nconst float FLT_EPSILON = 0.001;\nconst float FLT_EPSILON2 = 0.01;\nuniform samplerCube cc_ibl_map_sky;\nuniform sampler2D cc_ibl_cluster_InfoTexture;\nuniform sampler2D cc_ibl_cluster_Texture;\nuniform sampler2D cc_ibl_cluster_CubemapAtlas;\nuniform sampler2D cc_planar_reflection_Texture;\n#if (CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD)\n    in vec3 v_luv;\n    uniform sampler2D cc_lightingMap;\n    #if USE_INSTANCING\n      in vec4 v_lightingMapAdds0;\n      in vec4 v_lightingMapAdds1;\n      in vec4 v_lightingMapScales0;\n      in vec4 v_lightingMapScales1;\n    #endif\n#endif\n#if CC_FORWARD_ADD\n#if CC_PIPELINE_TYPE == 0\n# define LIGHTS_PER_PASS 1\n#else\n# define LIGHTS_PER_PASS 10\n#endif\n#if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\nlayout(std140) uniform CCForwardLight {\n  highp vec4 cc_lightPos[LIGHTS_PER_PASS];\n  vec4 cc_lightColor[LIGHTS_PER_PASS];\n  vec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];\n  vec4 cc_lightDir[LIGHTS_PER_PASS];\n};\n#endif\n#endif\nuniform sampler2D cc_light_cluster_InfoTexture;\nuniform sampler2D cc_light_cluster_Texture;\n#if CC_ENABLE_CLUSTERED_LIGHT_CULLING && CC_ENABLE_Builtin_CLUSTERED_LIGHT_CULLING\n  #if CC_USE_IBL\n    uniform samplerCube cc_environment;\n    #if CC_USE_DIFFUSEMAP\n      uniform samplerCube cc_diffuseMap;\n    #endif\n  #endif\n  #if USE_REFLECTION_DENOISE\n  #endif\n  struct StandardSurface {\n    vec4 albedo;\n    vec3 position;\n    vec3 normal;\n    vec3 emissive;\n    vec3 lightmap;\n    float lightmap_test;\n    float roughness;\n    float metallic;\n    float occlusion;\n  };\n  layout(std430, binding = 4) readonly buffer b_ccLightsBuffer { vec4 b_ccLights[]; };\n  layout(std430, binding = 5) readonly buffer b_clusterLightIndicesBuffer { uint b_clusterLightIndices[]; };\n  layout(std430, binding = 6) readonly buffer b_clusterLightGridBuffer { uvec4 b_clusterLightGrid[]; };\n  struct CCLight\n  {\n    vec4 cc_lightPos;\n    vec4 cc_lightColor;\n    vec4 cc_lightSizeRangeAngle;\n    vec4 cc_lightDir;\n  };\n  struct Cluster\n  {\n    vec3 minBounds;\n    vec3 maxBounds;\n  };\n  struct LightGrid\n  {\n    uint offset;\n    uint ccLights;\n  };\n#endif\nin vec4 v_worldPos;\nin float v_clip_depth;\nvec4 frag () {\n  FMaterialPixelParameters Parameters;\n  Parameters.TexCoords_0 = v_uv;\n  FPixelMaterialInputs PixelMaterialInputs;\n  CalcPixelMaterialInputs(Parameters, PixelMaterialInputs);\n  if (PixelMaterialInputs.OpacityMask < 0.33330) {\n    discard;\n  }\n  if(cc_shadowLPNNInfo.x > 0.000001 && cc_shadowLPNNInfo.x < 1.999999) {\n    if (cc_shadowNFLSInfo.z > 0.000001) {\n      return vec4(CCGetLinearDepth(v_worldPos.xyz), 1.0, 1.0, 1.0);\n    }\n  }\n  if (cc_shadowLPNNInfo.y > 0.000001) {\n    return packDepthToRGBA(v_clip_depth);\n  }\n  return vec4(v_clip_depth, 1.0, 1.0, 1.0);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"},"glsl1":{"vert":"\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\nattribute vec4 a_tangent;\n#if CC_USE_MORPH\n    attribute float a_vertexId;\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n  uniform vec4 cc_displacementWeights[15];\n  uniform vec4 cc_displacementTextureInfo;\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n        int pixelIndex = elementIndex;\n        vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n        vec2 uv = getPixelCoordFromLocation(location, cc_displacementTextureInfo.xy);\n        return texture2D(tex, uv);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture2D(tex, x)),\n        decode32(texture2D(tex, y)),\n        decode32(texture2D(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout StandardVertInput attr) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    attr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    attr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    attr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n    attribute vec4 a_joints;\n  attribute vec4 a_weights;\n  #if CC_USE_BAKED_ANIMATION\n    #if USE_INSTANCING\n      attribute highp vec4 a_jointAnimInfo;\n    #endif\n    uniform highp vec4 cc_jointTextureInfo;\n    uniform highp vec4 cc_jointAnimInfo;\n    uniform highp sampler2D cc_jointTexture;\n      #else\n    uniform highp vec4 cc_joints[90];\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout StandardVertInput attr) {\n    mat4 m = skinMatrix();\n    attr.position = m * attr.position;\n    attr.normal = (m * vec4(attr.normal, 0.0)).xyz;\n    attr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n  }\n#endif\n#if USE_INSTANCING\n  attribute vec4 a_matWorld0;\n  attribute vec4 a_matWorld1;\n  attribute vec4 a_matWorld2;\n  #if USE_LIGHTMAP\n    attribute vec4 a_lightingMapUVParam;\n  #endif\n#elif USE_BATCHING\n  attribute float a_dyn_batch_id;\n  uniform highp mat4 cc_matWorlds[10];\n#else\n  uniform highp mat4 cc_matWorld;\n  uniform highp mat4 cc_matWorldIT;\n#endif\nuniform highp mat4 cc_matLightViewProj;\nvarying vec4 v_worldPos;\nvarying float v_clip_depth;\nvarying vec2 v_uv;\nvec4 vert () {\n  StandardVertInput In;\n      In.position = vec4(a_position, 1.0);\n      In.normal = a_normal;\n      In.tangent = a_tangent;\n    #if CC_USE_MORPH\n      applyMorph(In);\n    #endif\n    #if CC_USE_SKINNING\n      CCSkin(In);\n    #endif\n  mat4 matWorld, matWorldIT;\n    #if USE_INSTANCING\n      matWorld = mat4(\n        vec4(a_matWorld0.xyz, 0.0),\n        vec4(a_matWorld1.xyz, 0.0),\n        vec4(a_matWorld2.xyz, 0.0),\n        vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n      );\n      matWorldIT = matWorld;\n    #elif USE_BATCHING\n      matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n      matWorldIT = matWorld;\n    #else\n      matWorld = cc_matWorld;\n      matWorldIT = cc_matWorldIT;\n    #endif\n  v_worldPos = matWorld * In.position;\n  vec4 clipPos = cc_matLightViewProj * v_worldPos;\n  v_uv = a_texCoord;\n  v_clip_depth = clipPos.z / clipPos.w * 0.5 + 0.5;\n  return clipPos;\n}\nvoid main() { gl_Position = vert(); }","frag":"\n#ifdef GL_EXT_shader_texture_lod\n#extension GL_EXT_shader_texture_lod: enable\n#endif\nprecision highp float;\nvec4 packDepthToRGBA (float depth) {\n  vec4 ret = vec4(1.0, 255.0, 65025.0, 16581375.0) * depth;\n  ret = fract(ret);\n  ret -= vec4(ret.yzw, 0.0) / 255.0;\n  return ret;\n}\nuniform highp mat4 cc_matLightView;\n  uniform lowp vec4 cc_shadowNFLSInfo;\n  uniform lowp vec4 cc_shadowLPNNInfo;\nfloat CCGetLinearDepthFromViewSpace(vec3 viewPos) {\n  float dist = length(viewPos);\n  return (dist - cc_shadowNFLSInfo.x) / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\n  vec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n  return CCGetLinearDepthFromViewSpace(viewStartPos.xyz);\n}\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotLightingMap;\n#endif\n  struct GlobalView {\n      vec3 IndirectLightingColorScale;\n      float PreExposure;\n  };\n  #ifdef GL_OES_standard_derivatives\n  #else\n  #endif\nstruct Light {\n  vec3 color;\n  vec3 direction;\n};\nstruct FDirectLighting\n{\n  vec3 Diffuse;\n  vec3 Specular;\n};\nstruct FPixelMaterialInputs\n{\n  vec3 Normal;\n  vec3 EmissiveColor;\n  float Opacity;\n  float OpacityMask;\n  vec3 BaseColor;\n  float Metallic;\n  float Specular;\n  float Roughness;\n  float AmbientOcclusion;\n  float Anisotropy;\n  float Tangent;\n  float Refraction;\n  float PixelDepthOffset;\n  float ShadingModel;\n  float TwoSidedSign;\n  float RoughnessWithClamp;\n  vec3 DiffuseColor;\n  vec3 SpecularColor;\n  vec3 Subsurface;\n};\nstruct FMaterialPixelParameters {\n  float IndirectIrradiance;\n  vec2 TexCoords_0;\n  vec2 TexCoords_1;\n  vec4 VertexColor;\n  vec3 WorldNormal;\n  vec3 WorldTangent;\n  vec3 ReflectionVector;\n  vec3 CameraVector;\n  vec3 LightVector;\n  vec4 SvPosition;\n  vec4 ScreenPosition;\n  mat3 TangentToWorld;\n  vec3 AbsoluteWorldPosition;\n  vec3 ObjectWorldPosition;\n  vec2 LightmapUVs;\n  int PrimitiveId;\n};\nstruct FMaterialVertexParameters {\n  vec3 WorldPosition;\n  vec4 VertexColor;\n};\n  vec3 GetMaterialNormalRaw(FPixelMaterialInputs PixelMaterialInputs) {\n      return vec3 ((PixelMaterialInputs).Normal);\n  }\n  vec3 GetMaterialNormal(FMaterialPixelParameters Parameters, FPixelMaterialInputs PixelMaterialInputs) {\n      vec3 RetNormal = GetMaterialNormalRaw(PixelMaterialInputs);\n      return RetNormal;\n  }\n  vec3 TransformTangentNormalToWorld(mat3 TangentToWorld, vec3 normal) {\n      return normalize((TangentToWorld * normalize(normal)));\n  }\n  vec3 ReflectionAboutCustomWorldNormal(inout FMaterialPixelParameters Parameters, vec3 WorldNormal, bool bNormalizeInputNormal) {\n      ((Parameters).WorldNormal = (TransformTangentNormalToWorld((Parameters).TangentToWorld, (Parameters).WorldNormal)).xzy);\n      ((Parameters).ReflectionVector = normalize(reflect((-(Parameters).CameraVector), (Parameters).WorldNormal)));\n      return (Parameters).ReflectionVector;\n  }\n   vec4 F4_0101 = vec4(0, 1, 0, 1);\nvoid CalcPixelMaterialInputs(inout FMaterialPixelParameters Parameters, inout FPixelMaterialInputs PixelMaterialInputs) {\n    ((PixelMaterialInputs).Normal = vec3(0.000000, 0.000000, 1.000000));\n    vec3 MaterialNormal = vec3 (GetMaterialNormal(Parameters, PixelMaterialInputs));\n    ((Parameters).WorldNormal = normalize(MaterialNormal));\n    ((Parameters).ReflectionVector = ReflectionAboutCustomWorldNormal(Parameters, (Parameters).WorldNormal, false));\n    ((PixelMaterialInputs).EmissiveColor = vec3(0.000000, 0.000000, 0.000000));\n    ((PixelMaterialInputs).Opacity = 1.000000);\n    ((PixelMaterialInputs).OpacityMask = 1.000000);\n    ((PixelMaterialInputs).BaseColor = vec3(0.270222, 0.242972, 0.937500));\n    ((PixelMaterialInputs).Metallic = 0.000000);\n    ((PixelMaterialInputs).Specular = 0.500000);\n    ((PixelMaterialInputs).Roughness = 0.500000);\n    ((PixelMaterialInputs).Anisotropy = 0.000000);\n    ((PixelMaterialInputs).Tangent = float (vec3(1.000000, 0.000000, 0.000000)));\n    ((PixelMaterialInputs).Subsurface = vec3 (0));\n    ((PixelMaterialInputs).AmbientOcclusion = 1.000000);\n    ((Parameters).WorldTangent = vec3 (0));\n}\n#if CC_USE_ATTR_COLOR\nvarying vec4 v_color;\n#endif\nvarying vec3 v_obj_position;\nvarying vec3 v_position;\nvarying vec3 v_normal;\nvarying vec2 v_uv;\nvarying vec2 v_uv1;\nvarying vec3 v_tangent;\nvarying vec3 v_bitangent;\n  varying highp vec4 v_shadowPos;\nconst float FLT_EPSILON = 0.001;\nconst float FLT_EPSILON2 = 0.01;\nuniform samplerCube cc_ibl_map_sky;\nuniform sampler2D cc_ibl_cluster_InfoTexture;\nuniform sampler2D cc_ibl_cluster_Texture;\nuniform sampler2D cc_ibl_cluster_CubemapAtlas;\nuniform sampler2D cc_planar_reflection_Texture;\n#if (CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD)\n    varying vec3 v_luv;\n    uniform sampler2D cc_lightingMap;\n    #if USE_INSTANCING\n      varying vec4 v_lightingMapAdds0;\n      varying vec4 v_lightingMapAdds1;\n      varying vec4 v_lightingMapScales0;\n      varying vec4 v_lightingMapScales1;\n    #endif\n#endif\n#if CC_FORWARD_ADD\n#if CC_PIPELINE_TYPE == 0\n# define LIGHTS_PER_PASS 1\n#else\n# define LIGHTS_PER_PASS 10\n#endif\n#if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\nuniform highp vec4 cc_lightPos[LIGHTS_PER_PASS];\n  uniform vec4 cc_lightColor[LIGHTS_PER_PASS];\n  uniform vec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];\n  uniform vec4 cc_lightDir[LIGHTS_PER_PASS];\n#endif\n#endif\nuniform sampler2D cc_light_cluster_InfoTexture;\nuniform sampler2D cc_light_cluster_Texture;\n#if CC_ENABLE_CLUSTERED_LIGHT_CULLING && CC_ENABLE_Builtin_CLUSTERED_LIGHT_CULLING\n  #if CC_USE_IBL\n    uniform samplerCube cc_environment;\n    #if CC_USE_DIFFUSEMAP\n      uniform samplerCube cc_diffuseMap;\n    #endif\n  #endif\n  #if USE_REFLECTION_DENOISE\n  #endif\n  struct StandardSurface {\n    vec4 albedo;\n    vec3 position;\n    vec3 normal;\n    vec3 emissive;\n    vec3 lightmap;\n    float lightmap_test;\n    float roughness;\n    float metallic;\n    float occlusion;\n  };\n  readonly buffer b_ccLightsBuffer { vec4 b_ccLights[]; };\n  readonly buffer b_clusterLightIndicesBuffer { uint b_clusterLightIndices[]; };\n  readonly buffer b_clusterLightGridBuffer { uvec4 b_clusterLightGrid[]; };\n  struct CCLight\n  {\n    vec4 cc_lightPos;\n    vec4 cc_lightColor;\n    vec4 cc_lightSizeRangeAngle;\n    vec4 cc_lightDir;\n  };\n  struct Cluster\n  {\n    vec3 minBounds;\n    vec3 maxBounds;\n  };\n  struct LightGrid\n  {\n    uint offset;\n    uint ccLights;\n  };\n#endif\nvarying vec4 v_worldPos;\nvarying float v_clip_depth;\nvec4 frag () {\n  FMaterialPixelParameters Parameters;\n  Parameters.TexCoords_0 = v_uv;\n  FPixelMaterialInputs PixelMaterialInputs;\n  CalcPixelMaterialInputs(Parameters, PixelMaterialInputs);\n  if (PixelMaterialInputs.OpacityMask < 0.33330) {\n    discard;\n  }\n  if(cc_shadowLPNNInfo.x > 0.000001 && cc_shadowLPNNInfo.x < 1.999999) {\n    if (cc_shadowNFLSInfo.z > 0.000001) {\n      return vec4(CCGetLinearDepth(v_worldPos.xyz), 1.0, 1.0, 1.0);\n    }\n  }\n  if (cc_shadowLPNNInfo.y > 0.000001) {\n    return packDepthToRGBA(v_clip_depth);\n  }\n  return vec4(v_clip_depth, 1.0, 1.0, 1.0);\n}\nvoid main() { gl_FragColor = frag(); }"},"builtins":{"globals":{"blocks":[{"name":"CCShadow","defines":[]},{"name":"CCGlobal","defines":[]},{"name":"CCCamera","defines":[]},{"name":"CCCustomView","defines":[]}],"samplerTextures":[{"name":"cc_shadowMap","defines":["CC_RECEIVE_SHADOW"]},{"name":"cc_spotLightingMap","defines":["CC_RECEIVE_SHADOW"]},{"name":"cc_ibl_map_sky","defines":[]},{"name":"cc_ibl_cluster_InfoTexture","defines":[]},{"name":"cc_ibl_cluster_Texture","defines":[]},{"name":"cc_ibl_cluster_CubemapAtlas","defines":[]},{"name":"cc_planar_reflection_Texture","defines":[]},{"name":"cc_light_cluster_InfoTexture","defines":[]},{"name":"cc_light_cluster_Texture","defines":[]},{"name":"cc_environment","defines":["CC_ENABLE_CLUSTERED_LIGHT_CULLING","CC_ENABLE_Builtin_CLUSTERED_LIGHT_CULLING","CC_USE_IBL"]},{"name":"cc_diffuseMap","defines":["CC_ENABLE_CLUSTERED_LIGHT_CULLING","CC_ENABLE_Builtin_CLUSTERED_LIGHT_CULLING","CC_USE_IBL","CC_USE_DIFFUSEMAP"]}],"buffers":[],"images":[]},"locals":{"blocks":[{"name":"CCMorph","defines":["CC_USE_MORPH"]},{"name":"CCSkinningTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinningAnimation","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinning","defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION"]},{"name":"CCLocalBatched","defines":["!USE_INSTANCING","USE_BATCHING"]},{"name":"CCLocal","defines":["!USE_INSTANCING","!USE_BATCHING"]},{"name":"CCForwardLight","defines":["CC_FORWARD_ADD","CC_ENABLE_CLUSTERED_LIGHT_CULLING"]}],"samplerTextures":[{"name":"cc_PositionDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_POSITION"]},{"name":"cc_NormalDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_NORMAL"]},{"name":"cc_TangentDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_TANGENT"]},{"name":"cc_jointTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"cc_lightingMap","defines":["CC_USE_LIGHTMAP","!USE_BATCHING","!CC_FORWARD_ADD"]}],"buffers":[],"images":[]},"statistics":{"CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS":176,"CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS":109}},"defines":[{"name":"CC_USE_MORPH","type":"boolean","defines":[]},{"name":"CC_MORPH_TARGET_COUNT","type":"number","defines":["CC_USE_MORPH"],"range":[2,8]},{"name":"CC_MORPH_PRECOMPUTED","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_POSITION","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_NORMAL","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_TANGENT","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_USE_SKINNING","type":"boolean","defines":[]},{"name":"CC_USE_BAKED_ANIMATION","type":"boolean","defines":["CC_USE_SKINNING"]},{"name":"USE_INSTANCING","type":"boolean","defines":[],"editor":{"elevated":true}},{"name":"USE_BATCHING","type":"boolean","defines":["!USE_INSTANCING"],"editor":{"elevated":true}},{"name":"USE_LIGHTMAP","type":"boolean","defines":["USE_INSTANCING"]},{"name":"CC_RECEIVE_SHADOW","type":"boolean","defines":[]},{"name":"CC_USE_ATTR_COLOR","type":"boolean","defines":[]},{"name":"CC_USE_LIGHTMAP","type":"boolean","defines":[]},{"name":"CC_FORWARD_ADD","type":"boolean","defines":[]},{"name":"CC_PIPELINE_TYPE","type":"number","defines":["CC_FORWARD_ADD"],"range":[0,1]},{"name":"CC_FORCE_FORWARD_SHADING","type":"boolean","defines":["CC_FORWARD_ADD"]},{"name":"CC_ENABLE_Builtin_CLUSTERED_LIGHT_CULLING","type":"boolean","defines":["CC_ENABLE_CLUSTERED_LIGHT_CULLING"]},{"name":"CC_USE_IBL","type":"number","defines":["CC_ENABLE_CLUSTERED_LIGHT_CULLING","CC_ENABLE_Builtin_CLUSTERED_LIGHT_CULLING"],"range":[0,2]},{"name":"CC_USE_DIFFUSEMAP","type":"number","defines":["CC_ENABLE_CLUSTERED_LIGHT_CULLING","CC_ENABLE_Builtin_CLUSTERED_LIGHT_CULLING","CC_USE_IBL"],"range":[0,2]},{"name":"USE_REFLECTION_DENOISE","type":"boolean","defines":["CC_ENABLE_CLUSTERED_LIGHT_CULLING","CC_ENABLE_Builtin_CLUSTERED_LIGHT_CULLING"]}]}],[{"name":"opaque","passes":[{"program":"../resources/Exported/LakeWoodenHouse/Maps/TestPositionOffset|pbr-vs|pbr-fs","embeddedMacros":{"CC_ENABLE_CLUSTERED_LIGHT_CULLING":1,"CC_ENABLE_IBL":1,"CC_IBL_MaxPixelsPerCell":4,"CC_LIGHT_MaxPixelsPerCell":4,"CC_ENABLE_LIGHTING":1,"CC_ENABLE_LIGHTING_ADD":1,"CC_ENABLE_LIGHTING_BASE":1}},{"phase":"deferred","propertyIndex":0,"program":"../resources/Exported/LakeWoodenHouse/Maps/TestPositionOffset|pbr-vs|pbr-fs","embeddedMacros":{"CC_ENABLE_CLUSTERED_LIGHT_CULLING":1,"CC_ENABLE_IBL":1,"CC_IBL_MaxPixelsPerCell":4,"CC_LIGHT_MaxPixelsPerCell":4,"CC_ENABLE_LIGHTING":1,"CC_ENABLE_LIGHTING_ADD":1,"CC_ENABLE_LIGHTING_BASE":1},"blendState":{"targets":[{"blend":false}]}},{"phase":"forward-add","propertyIndex":0,"program":"../resources/Exported/LakeWoodenHouse/Maps/TestPositionOffset|pbr-vs|pbr-fs","embeddedMacros":{"CC_FORWARD_ADD":true,"CC_ENABLE_IBL":1,"CC_IBL_MaxPixelsPerCell":0,"CC_LIGHT_MaxPixelsPerCell":0,"CC_ENABLE_LIGHTING":1,"CC_ENABLE_LIGHTING_ADD":1,"CC_ENABLE_LIGHTING_BASE":1},"blendState":{"targets":[{"blend":true,"blendSrc":1,"blendDst":1,"blendSrcAlpha":0,"blendDstAlpha":1}]},"depthStencilState":{"depthFunc":2,"depthTest":true,"depthWrite":false}},{"phase":"overdraw","program":"../resources/Exported/LakeWoodenHouse/Maps/TestPositionOffset|overdraw-vs:vert|overdraw-fs:frag","embeddedMacros":{"USE_INSTANCING":false},"blendState":{"targets":[{"blend":true,"blendSrc":2,"blendDst":4,"blendDstAlpha":4}]},"depthStencilState":{"depthTest":true,"depthWrite":false}},{"phase":"shadow-caster","propertyIndex":0,"program":"../resources/Exported/LakeWoodenHouse/Maps/TestPositionOffset|shadow-caster-vs:vert|shadow-caster-fs:frag","rasterizerState":{"cullMode":1}}]},{"name":"transparent","passes":[{"program":"../resources/Exported/LakeWoodenHouse/Maps/TestPositionOffset|pbr-vs|pbr-fs","embeddedMacros":{"CC_TRANSPARENT":true},"blendState":{"targets":[{"blend":true,"blendSrc":2,"blendDst":4,"blendDstAlpha":4}]},"depthStencilState":{"depthTest":true,"depthWrite":false}},{"phase":"forward-add","propertyIndex":0,"program":"../resources/Exported/LakeWoodenHouse/Maps/TestPositionOffset|pbr-vs|pbr-fs","embeddedMacros":{"CC_FORWARD_ADD":true,"CC_ENABLE_IBL":1,"CC_IBL_MaxPixelsPerCell":0,"CC_LIGHT_MaxPixelsPerCell":0,"CC_ENABLE_LIGHTING":1,"CC_ENABLE_LIGHTING_ADD":1,"CC_ENABLE_LIGHTING_BASE":1},"blendState":{"targets":[{"blend":true,"blendSrc":1,"blendDst":1,"blendSrcAlpha":0,"blendDstAlpha":1}]},"depthStencilState":{"depthFunc":2,"depthTest":true,"depthWrite":false}},{"phase":"shadow-caster","propertyIndex":0,"program":"../resources/Exported/LakeWoodenHouse/Maps/TestPositionOffset|shadow-caster-vs:vert|shadow-caster-fs:frag","rasterizerState":{"cullMode":1}}]}]]],0,0,[],[],[]]
