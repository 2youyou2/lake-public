[1,0,0,[["cc.EffectAsset",["_name","shaders","techniques"],0]],[[0,0,1,2,4]],[[0,"../resources/Exported/__builtin__/custom-deferred-taa",[{"hash":3006565057,"name":"../resources/Exported/__builtin__/custom-deferred-taa|vs|fs","blocks":[],"samplerTextures":[{"name":"lighting_resultMap","type":28,"count":1,"stageFlags":16,"binding":0,"defines":[]},{"name":"depth_buffer_map","type":28,"count":1,"stageFlags":16,"binding":1,"defines":[]},{"name":"taa_prev_tex","type":28,"count":1,"stageFlags":16,"binding":2,"defines":[]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[],"attributes":[{"name":"a_position","format":32,"location":0,"defines":[]},{"name":"a_normal","format":32,"location":1,"defines":[]},{"name":"a_texCoord","format":21,"location":2,"defines":[]},{"name":"a_tangent","format":44,"location":3,"defines":[]},{"name":"a_vertexId","format":11,"location":6,"defines":["CC_USE_MORPH"]},{"name":"a_joints","location":4,"defines":["CC_USE_SKINNING"]},{"name":"a_weights","format":44,"location":5,"defines":["CC_USE_SKINNING"]},{"name":"a_jointAnimInfo","format":44,"isInstanced":true,"location":7,"defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION","USE_INSTANCING"]}],"varyings":[{"name":"v_uv","type":14,"count":1,"stageFlags":17,"location":0,"defines":[]}],"fragColors":[{"name":"fragColor","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":0,"defines":[]}],"glsl4":{"vert":"#extension GL_EXT_shader_explicit_arithmetic_types_int32: require\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec3 a_normal;\nlayout(location = 2) in vec2 a_texCoord;\nlayout(location = 3) in vec4 a_tangent;\n#if CC_USE_MORPH\n    int getVertexId() {\n      return gl_VertexIndex;\n    }\n  layout(set = 2, binding = 4) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n  };\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n        ivec2 texSize = textureSize(tex, 0);\n        return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture(tex, x)),\n        decode32(texture(tex, y)),\n        decode32(texture(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    layout(set = 2, binding = 7) uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    layout(set = 2, binding = 8) uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    layout(set = 2, binding = 9) uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout StandardVertInput attr) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    attr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    attr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    attr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n    layout(location = 4) in u32vec4 a_joints;\n  layout(location = 5) in vec4 a_weights;\n  #if CC_USE_BAKED_ANIMATION\n    #if USE_INSTANCING\n      layout(location = 7) in highp vec4 a_jointAnimInfo;\n    #endif\n    layout(set = 2, binding = 3) uniform CCSkinningTexture {\n      highp vec4 cc_jointTextureInfo;\n    };\n    layout(set = 2, binding = 2) uniform CCSkinningAnimation {\n      highp vec4 cc_jointAnimInfo;\n    };\n    layout(set = 2, binding = 6) uniform highp sampler2D cc_jointTexture;\n      #else\n    layout(set = 2, binding = 3) uniform CCSkinning {\n      highp vec4 cc_joints[30 * 3];\n    };\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout StandardVertInput attr) {\n    mat4 m = skinMatrix();\n    attr.position = m * attr.position;\n    attr.normal = (m * vec4(attr.normal, 0.0)).xyz;\n    attr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n  }\n#endif\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nlayout(location = 0) out vec2 v_uv;\nvoid main () {\n  StandardVertInput In;\n      In.position = vec4(a_position, 1.0);\n      In.normal = a_normal;\n      In.tangent = a_tangent;\n    #if CC_USE_MORPH\n      applyMorph(In);\n    #endif\n    #if CC_USE_SKINNING\n      CCSkin(In);\n    #endif\n  In.position.xy = cc_cameraPos.w == 0.0 ? vec2(In.position.xy.x, -In.position.xy.y) : In.position.xy;\n  gl_Position = In.position;\n  v_uv = a_texCoord;\n}","frag":"\n  precision highp float;\n  layout(set = 0, binding = 0) uniform CCGlobal {\n    highp   vec4 cc_time;\n    mediump vec4 cc_screenSize;\n    mediump vec4 cc_nativeSize;\n  };\n  layout(set = 0, binding = 1) uniform CCCamera {\n    highp   mat4 cc_matView;\n    highp   mat4 cc_matViewInv;\n    highp   mat4 cc_matProj;\n    highp   mat4 cc_matProjInv;\n    highp   mat4 cc_matViewProj;\n    highp   mat4 cc_matViewProjInv;\n    highp   vec4 cc_cameraPos;\n    mediump vec4 cc_screenScale;\n    mediump vec4 cc_exposure;\n    mediump vec4 cc_mainLitDir;\n    mediump vec4 cc_mainLitColor;\n    mediump vec4 cc_ambientSky;\n    mediump vec4 cc_ambientGround;\n    mediump vec4 cc_fogColor;\n    mediump vec4 cc_fogBase;\n    mediump vec4 cc_fogAdd;\n    mediump vec4 cc_nearFar;\n    mediump vec4 cc_viewPort;\n  };\nstruct Light {\n  vec3 color;\n  vec3 direction;\n};\nstruct FDirectLighting\n{\n  vec3 Diffuse;\n  vec3 Specular;\n};\nstruct FPixelMaterialInputs\n{\n  vec3 Normal;\n  vec3 EmissiveColor;\n  float Opacity;\n  float OpacityMask;\n  vec3 BaseColor;\n  float Metallic;\n  float Specular;\n  float Roughness;\n  float AmbientOcclusion;\n  float Anisotropy;\n  float Tangent;\n  float Refraction;\n  float PixelDepthOffset;\n  float ShadingModel;\n  float TwoSidedSign;\n  float RoughnessWithClamp;\n  vec3 DiffuseColor;\n  vec3 SpecularColor;\n  vec3 Subsurface;\n};\nstruct FMaterialPixelParameters {\n  float IndirectIrradiance;\n  vec2 TexCoords_0;\n  vec2 TexCoords_1;\n  vec4 VertexColor;\n  vec3 WorldNormal;\n  vec3 WorldTangent;\n  vec3 ReflectionVector;\n  vec3 CameraVector;\n  vec3 LightVector;\n  vec4 SvPosition;\n  vec4 ScreenPosition;\n  mat3 TangentToWorld;\n  vec3 AbsoluteWorldPosition;\n  vec3 ObjectWorldPosition;\n  vec2 LightmapUVs;\n  int PrimitiveId;\n};\nstruct FMaterialVertexParameters {\n  vec3 WorldPosition;\n  vec4 VertexColor;\n};\nlayout(set = 0, binding = 7) uniform CCCustomView {\n    mat4 cc_view_taa_prev_viewProj;\n    mat4 cc_view_inverse_transpose_mirror;\n    vec4 cc_view_pr_reflectionPlane;\n    vec4 cc_view_pr_parameters;\n    vec4 cc_view_SkyIrradianceEnvironmentMap[7];\n    vec4 cc_view_SkyColor;\n    vec4 cc_view_SkyLightParameters;\n    vec4 cc_view_IndirectLightingColorScale_Intensity;\n    vec4 cc_view_PreExposure;\n    vec4 cc_view_taa_params1;\n    vec4 cc_view_taa_params2;\n    vec4 cc_view_final_screen_params;\n    vec4 cc_ibl_cluster_BoundsMin;\n    vec4 cc_ibl_cluster_BoundsDelta;\n    vec4 cc_ibl_cluster_CellsDot;\n    vec4 cc_ibl_cluster_CellsMax;\n    vec4 cc_ibl_cluster_TextureSize;\n    vec4 cc_ibl_cluster_InfoTextureInvSize;\n    vec4 cc_ibl_cluster_CellsCountByBoundsSizeAndPixelsPerCell;\n    vec4 cc_light_cluster_BoundsMin;\n    vec4 cc_light_cluster_BoundsDelta;\n    vec4 cc_light_cluster_CellsDot;\n    vec4 cc_light_cluster_CellsMax;\n    vec4 cc_light_cluster_TextureSize;\n    vec4 cc_light_cluster_InfoTextureInvSize;\n    vec4 cc_light_cluster_CellsCountByBoundsSizeAndPixelsPerCell;\n    vec4 FogStruct_ExponentialFogParameters;\n    vec4 FogStruct_ExponentialFogColorParameter;\n    vec4 FogStruct_ExponentialFogParameters2;\n    vec4 FogStruct_ExponentialFogParameters3;\n    vec4 cc_global_parameters;\n};\nstruct GlobalView {\n    vec3 IndirectLightingColorScale;\n    float PreExposure;\n};\nvec3 screen2WS(vec3 screenPos) {\n  vec4 ndc = vec4(screenPos.xyz * 2. - 1.0, 1.0);\n  vec4 world = cc_matViewProjInv * ndc;\n  world = world / world.w;\n  return world.xyz;\n}\nvec2 historyPostion(sampler2D depth_buffer_map, vec2 unjittedUV, vec2 uv) {\n  float depth = texture(depth_buffer_map, unjittedUV).x;\n  vec3 worldPos = screen2WS(vec3(uv, depth));\n  if (abs(worldPos.x) < 0.0001 && abs(worldPos.y) < 0.0001) {\n    return uv;\n  }\n  vec4 historyNDC = cc_view_taa_prev_viewProj * vec4(worldPos, 1.);\n  historyNDC /= historyNDC.w;\n  vec2 screenPos = historyNDC.xy * 0.5 + 0.5;\n  return screenPos;\n}\nvec3 RGBToYCoCg( vec3 RGB ) {\n  float Y  = dot( RGB, vec3(  1, 2,  1 ) );\n  float Co = dot( RGB, vec3(  2, 0, -2 ) );\n  float Cg = dot( RGB, vec3( -1, 2, -1 ) );\n  return vec3( Y, Co, Cg );\n}\nvec3 YCoCgToRGB( vec3 YCoCg ) {\n  float Y  = YCoCg.x * 0.25;\n  float Co = YCoCg.y * 0.25;\n  float Cg = YCoCg.z * 0.25;\n  float R = Y + Co - Cg;\n  float G = Y + Cg;\n  float B = Y - Co - Cg;\n  return vec3( R, G, B );\n}\nvec4 sampleYCoCg(sampler2D tex, vec2 uv) {\n    vec4 color = texture(tex, uv);\n    color.rgb = RGBToYCoCg(color.rgb);\n    return color;\n}\nvoid minmax(sampler2D mainTex, in vec2 uv, out vec4 color_min, out vec4 color_max, out vec4 color_avg) {\n    vec2 mainTexSize = cc_nativeSize.zw;\n    vec2 du = vec2(mainTexSize.x, 0.0);\n    vec2 dv = vec2(0.0, mainTexSize.y);\n    vec4 t = sampleYCoCg(mainTex, uv - dv);\n    vec4 l = sampleYCoCg(mainTex, uv - du);\n    vec4 c = sampleYCoCg(mainTex, uv);\n    vec4 r = sampleYCoCg(mainTex, uv + du);\n    vec4 b = sampleYCoCg(mainTex, uv + dv);\n    color_min = min(t, min(l, min(c, min(r, b))));\n    color_max = max(t, max(l, max(c, max(r, b))));\n    color_avg = (t + l + c + r + b) / 5.0;\n}\nfloat HdrWeightY(float Color, float Exposure) {\n  return 1. / (Color * Exposure + 4.0);\n}\nvec2 WeightedLerpFactors(float WeightA, float WeightB, float Blend) {\n  float BlendA = (1.0 - Blend) * WeightA;\n  float BlendB = Blend * WeightB;\n  float RcpBlend = 1. / (BlendA + BlendB);\n  BlendA *= RcpBlend;\n  BlendB *= RcpBlend;\n  return vec2(BlendA, BlendB);\n}\nvec4 temporalAAPS (sampler2D taa_prev_tex, sampler2D mainTex, sampler2D depth_buffer_map, vec2 uv) {\n    vec2 unjittedUV = uv - cc_view_taa_params1.xy / 2.;\n    vec2 previousUV = historyPostion(depth_buffer_map, unjittedUV, uv);\n    vec4 prevColor = texture(taa_prev_tex, previousUV);\n    prevColor.rgb = RGBToYCoCg(prevColor.rgb);\n    vec4 color = texture(mainTex, unjittedUV);\n    color.rgb = RGBToYCoCg(color.rgb);\n    vec4 color_min, color_max, color_avg;\n    minmax(mainTex, unjittedUV, color_min, color_max, color_avg);\n    vec3 resultColor;\n    {\n        prevColor.rgb = clamp(prevColor.rgb, color_min.rgb, color_max.rgb);\n        float blendFinal = 1. - cc_view_taa_params2.y;\n        float currentWeight = HdrWeightY(color.x, 1.);\n        float historyWeight = HdrWeightY(prevColor.x, 1.);\n        vec2 weights = WeightedLerpFactors(historyWeight, currentWeight, blendFinal);\n        resultColor = prevColor.rgb * weights.x + color.rgb * weights.y;\n    }\n    {\n    }\n    resultColor = YCoCgToRGB(resultColor);\n    return vec4(resultColor, color.a);\n}\n  layout(location = 0) in vec2 v_uv;\n  layout(set = 1, binding = 0) uniform sampler2D lighting_resultMap;\n  layout(set = 1, binding = 1) uniform sampler2D depth_buffer_map;\n  layout(set = 1, binding = 2) uniform sampler2D taa_prev_tex;\n  layout(location = 0) out vec4 fragColor;\n  void main () {\n    #if CC_ANTI_ALIASING_TEMPORALAA\n      fragColor = temporalAAPS(taa_prev_tex, lighting_resultMap, depth_buffer_map, v_uv);\n    #else\n      fragColor = texture(lighting_resultMap, v_uv);\n    #endif\n  }"},"glsl3":{"vert":"\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\nin vec4 a_tangent;\n#if CC_USE_MORPH\n    in float a_vertexId;\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n  layout(std140) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n  };\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n        ivec2 texSize = textureSize(tex, 0);\n        return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture(tex, x)),\n        decode32(texture(tex, y)),\n        decode32(texture(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout StandardVertInput attr) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    attr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    attr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    attr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n    in vec4 a_joints;\n  in vec4 a_weights;\n  #if CC_USE_BAKED_ANIMATION\n    #if USE_INSTANCING\n      in highp vec4 a_jointAnimInfo;\n    #endif\n    layout(std140) uniform CCSkinningTexture {\n      highp vec4 cc_jointTextureInfo;\n    };\n    layout(std140) uniform CCSkinningAnimation {\n      highp vec4 cc_jointAnimInfo;\n    };\n    uniform highp sampler2D cc_jointTexture;\n      #else\n    layout(std140) uniform CCSkinning {\n      highp vec4 cc_joints[30 * 3];\n    };\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout StandardVertInput attr) {\n    mat4 m = skinMatrix();\n    attr.position = m * attr.position;\n    attr.normal = (m * vec4(attr.normal, 0.0)).xyz;\n    attr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n  }\n#endif\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nout vec2 v_uv;\nvoid main () {\n  StandardVertInput In;\n      In.position = vec4(a_position, 1.0);\n      In.normal = a_normal;\n      In.tangent = a_tangent;\n    #if CC_USE_MORPH\n      applyMorph(In);\n    #endif\n    #if CC_USE_SKINNING\n      CCSkin(In);\n    #endif\n  In.position.xy = cc_cameraPos.w == 0.0 ? vec2(In.position.xy.x, -In.position.xy.y) : In.position.xy;\n  gl_Position = In.position;\n  v_uv = a_texCoord;\n}","frag":"\n  precision highp float;\n  layout(std140) uniform CCGlobal {\n    highp   vec4 cc_time;\n    mediump vec4 cc_screenSize;\n    mediump vec4 cc_nativeSize;\n  };\n  layout(std140) uniform CCCamera {\n    highp   mat4 cc_matView;\n    highp   mat4 cc_matViewInv;\n    highp   mat4 cc_matProj;\n    highp   mat4 cc_matProjInv;\n    highp   mat4 cc_matViewProj;\n    highp   mat4 cc_matViewProjInv;\n    highp   vec4 cc_cameraPos;\n    mediump vec4 cc_screenScale;\n    mediump vec4 cc_exposure;\n    mediump vec4 cc_mainLitDir;\n    mediump vec4 cc_mainLitColor;\n    mediump vec4 cc_ambientSky;\n    mediump vec4 cc_ambientGround;\n    mediump vec4 cc_fogColor;\n    mediump vec4 cc_fogBase;\n    mediump vec4 cc_fogAdd;\n    mediump vec4 cc_nearFar;\n    mediump vec4 cc_viewPort;\n  };\nstruct Light {\n  vec3 color;\n  vec3 direction;\n};\nstruct FDirectLighting\n{\n  vec3 Diffuse;\n  vec3 Specular;\n};\nstruct FPixelMaterialInputs\n{\n  vec3 Normal;\n  vec3 EmissiveColor;\n  float Opacity;\n  float OpacityMask;\n  vec3 BaseColor;\n  float Metallic;\n  float Specular;\n  float Roughness;\n  float AmbientOcclusion;\n  float Anisotropy;\n  float Tangent;\n  float Refraction;\n  float PixelDepthOffset;\n  float ShadingModel;\n  float TwoSidedSign;\n  float RoughnessWithClamp;\n  vec3 DiffuseColor;\n  vec3 SpecularColor;\n  vec3 Subsurface;\n};\nstruct FMaterialPixelParameters {\n  float IndirectIrradiance;\n  vec2 TexCoords_0;\n  vec2 TexCoords_1;\n  vec4 VertexColor;\n  vec3 WorldNormal;\n  vec3 WorldTangent;\n  vec3 ReflectionVector;\n  vec3 CameraVector;\n  vec3 LightVector;\n  vec4 SvPosition;\n  vec4 ScreenPosition;\n  mat3 TangentToWorld;\n  vec3 AbsoluteWorldPosition;\n  vec3 ObjectWorldPosition;\n  vec2 LightmapUVs;\n  int PrimitiveId;\n};\nstruct FMaterialVertexParameters {\n  vec3 WorldPosition;\n  vec4 VertexColor;\n};\nlayout(std140) uniform CCCustomView {\n    mat4 cc_view_taa_prev_viewProj;\n    mat4 cc_view_inverse_transpose_mirror;\n    vec4 cc_view_pr_reflectionPlane;\n    vec4 cc_view_pr_parameters;\n    vec4 cc_view_SkyIrradianceEnvironmentMap[7];\n    vec4 cc_view_SkyColor;\n    vec4 cc_view_SkyLightParameters;\n    vec4 cc_view_IndirectLightingColorScale_Intensity;\n    vec4 cc_view_PreExposure;\n    vec4 cc_view_taa_params1;\n    vec4 cc_view_taa_params2;\n    vec4 cc_view_final_screen_params;\n    vec4 cc_ibl_cluster_BoundsMin;\n    vec4 cc_ibl_cluster_BoundsDelta;\n    vec4 cc_ibl_cluster_CellsDot;\n    vec4 cc_ibl_cluster_CellsMax;\n    vec4 cc_ibl_cluster_TextureSize;\n    vec4 cc_ibl_cluster_InfoTextureInvSize;\n    vec4 cc_ibl_cluster_CellsCountByBoundsSizeAndPixelsPerCell;\n    vec4 cc_light_cluster_BoundsMin;\n    vec4 cc_light_cluster_BoundsDelta;\n    vec4 cc_light_cluster_CellsDot;\n    vec4 cc_light_cluster_CellsMax;\n    vec4 cc_light_cluster_TextureSize;\n    vec4 cc_light_cluster_InfoTextureInvSize;\n    vec4 cc_light_cluster_CellsCountByBoundsSizeAndPixelsPerCell;\n    vec4 FogStruct_ExponentialFogParameters;\n    vec4 FogStruct_ExponentialFogColorParameter;\n    vec4 FogStruct_ExponentialFogParameters2;\n    vec4 FogStruct_ExponentialFogParameters3;\n    vec4 cc_global_parameters;\n};\nstruct GlobalView {\n    vec3 IndirectLightingColorScale;\n    float PreExposure;\n};\nvec3 screen2WS(vec3 screenPos) {\n  vec4 ndc = vec4(screenPos.xyz * 2. - 1.0, 1.0);\n  vec4 world = cc_matViewProjInv * ndc;\n  world = world / world.w;\n  return world.xyz;\n}\nvec2 historyPostion(sampler2D depth_buffer_map, vec2 unjittedUV, vec2 uv) {\n  float depth = texture(depth_buffer_map, unjittedUV).x;\n  vec3 worldPos = screen2WS(vec3(uv, depth));\n  if (abs(worldPos.x) < 0.0001 && abs(worldPos.y) < 0.0001) {\n    return uv;\n  }\n  vec4 historyNDC = cc_view_taa_prev_viewProj * vec4(worldPos, 1.);\n  historyNDC /= historyNDC.w;\n  vec2 screenPos = historyNDC.xy * 0.5 + 0.5;\n  return screenPos;\n}\nvec3 RGBToYCoCg( vec3 RGB ) {\n  float Y  = dot( RGB, vec3(  1, 2,  1 ) );\n  float Co = dot( RGB, vec3(  2, 0, -2 ) );\n  float Cg = dot( RGB, vec3( -1, 2, -1 ) );\n  return vec3( Y, Co, Cg );\n}\nvec3 YCoCgToRGB( vec3 YCoCg ) {\n  float Y  = YCoCg.x * 0.25;\n  float Co = YCoCg.y * 0.25;\n  float Cg = YCoCg.z * 0.25;\n  float R = Y + Co - Cg;\n  float G = Y + Cg;\n  float B = Y - Co - Cg;\n  return vec3( R, G, B );\n}\nvec4 sampleYCoCg(sampler2D tex, vec2 uv) {\n    vec4 color = texture(tex, uv);\n    color.rgb = RGBToYCoCg(color.rgb);\n    return color;\n}\nvoid minmax(sampler2D mainTex, in vec2 uv, out vec4 color_min, out vec4 color_max, out vec4 color_avg) {\n    vec2 mainTexSize = cc_nativeSize.zw;\n    vec2 du = vec2(mainTexSize.x, 0.0);\n    vec2 dv = vec2(0.0, mainTexSize.y);\n    vec4 t = sampleYCoCg(mainTex, uv - dv);\n    vec4 l = sampleYCoCg(mainTex, uv - du);\n    vec4 c = sampleYCoCg(mainTex, uv);\n    vec4 r = sampleYCoCg(mainTex, uv + du);\n    vec4 b = sampleYCoCg(mainTex, uv + dv);\n    color_min = min(t, min(l, min(c, min(r, b))));\n    color_max = max(t, max(l, max(c, max(r, b))));\n    color_avg = (t + l + c + r + b) / 5.0;\n}\nfloat HdrWeightY(float Color, float Exposure) {\n  return 1. / (Color * Exposure + 4.0);\n}\nvec2 WeightedLerpFactors(float WeightA, float WeightB, float Blend) {\n  float BlendA = (1.0 - Blend) * WeightA;\n  float BlendB = Blend * WeightB;\n  float RcpBlend = 1. / (BlendA + BlendB);\n  BlendA *= RcpBlend;\n  BlendB *= RcpBlend;\n  return vec2(BlendA, BlendB);\n}\nvec4 temporalAAPS (sampler2D taa_prev_tex, sampler2D mainTex, sampler2D depth_buffer_map, vec2 uv) {\n    vec2 unjittedUV = uv - cc_view_taa_params1.xy / 2.;\n    vec2 previousUV = historyPostion(depth_buffer_map, unjittedUV, uv);\n    vec4 prevColor = texture(taa_prev_tex, previousUV);\n    prevColor.rgb = RGBToYCoCg(prevColor.rgb);\n    vec4 color = texture(mainTex, unjittedUV);\n    color.rgb = RGBToYCoCg(color.rgb);\n    vec4 color_min, color_max, color_avg;\n    minmax(mainTex, unjittedUV, color_min, color_max, color_avg);\n    vec3 resultColor;\n    {\n        prevColor.rgb = clamp(prevColor.rgb, color_min.rgb, color_max.rgb);\n        float blendFinal = 1. - cc_view_taa_params2.y;\n        float currentWeight = HdrWeightY(color.x, 1.);\n        float historyWeight = HdrWeightY(prevColor.x, 1.);\n        vec2 weights = WeightedLerpFactors(historyWeight, currentWeight, blendFinal);\n        resultColor = prevColor.rgb * weights.x + color.rgb * weights.y;\n    }\n    {\n    }\n    resultColor = YCoCgToRGB(resultColor);\n    return vec4(resultColor, color.a);\n}\n  in vec2 v_uv;\n  uniform sampler2D lighting_resultMap;\n  uniform sampler2D depth_buffer_map;\n  uniform sampler2D taa_prev_tex;\n  layout(location = 0) out vec4 fragColor;\n  void main () {\n    #if CC_ANTI_ALIASING_TEMPORALAA\n      fragColor = temporalAAPS(taa_prev_tex, lighting_resultMap, depth_buffer_map, v_uv);\n    #else\n      fragColor = texture(lighting_resultMap, v_uv);\n    #endif\n  }"},"glsl1":{"vert":"\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\nattribute vec4 a_tangent;\n#if CC_USE_MORPH\n    attribute float a_vertexId;\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n  uniform vec4 cc_displacementWeights[15];\n  uniform vec4 cc_displacementTextureInfo;\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n        int pixelIndex = elementIndex;\n        vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n        vec2 uv = getPixelCoordFromLocation(location, cc_displacementTextureInfo.xy);\n        return texture2D(tex, uv);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture2D(tex, x)),\n        decode32(texture2D(tex, y)),\n        decode32(texture2D(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout StandardVertInput attr) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    attr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    attr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    attr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n    attribute vec4 a_joints;\n  attribute vec4 a_weights;\n  #if CC_USE_BAKED_ANIMATION\n    #if USE_INSTANCING\n      attribute highp vec4 a_jointAnimInfo;\n    #endif\n    uniform highp vec4 cc_jointTextureInfo;\n    uniform highp vec4 cc_jointAnimInfo;\n    uniform highp sampler2D cc_jointTexture;\n      #else\n    uniform highp vec4 cc_joints[90];\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout StandardVertInput attr) {\n    mat4 m = skinMatrix();\n    attr.position = m * attr.position;\n    attr.normal = (m * vec4(attr.normal, 0.0)).xyz;\n    attr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n  }\n#endif\nuniform highp vec4 cc_cameraPos;\nvarying vec2 v_uv;\nvoid main () {\n  StandardVertInput In;\n      In.position = vec4(a_position, 1.0);\n      In.normal = a_normal;\n      In.tangent = a_tangent;\n    #if CC_USE_MORPH\n      applyMorph(In);\n    #endif\n    #if CC_USE_SKINNING\n      CCSkin(In);\n    #endif\n  In.position.xy = cc_cameraPos.w == 0.0 ? vec2(In.position.xy.x, -In.position.xy.y) : In.position.xy;\n  gl_Position = In.position;\n  v_uv = a_texCoord;\n}","frag":"\n  precision highp float;\n  uniform mediump vec4 cc_nativeSize;\n  uniform highp mat4 cc_matViewProjInv;\n  #ifdef GL_OES_standard_derivatives\n  #else\n  #endif\nstruct Light {\n  vec3 color;\n  vec3 direction;\n};\nstruct FDirectLighting\n{\n  vec3 Diffuse;\n  vec3 Specular;\n};\nstruct FPixelMaterialInputs\n{\n  vec3 Normal;\n  vec3 EmissiveColor;\n  float Opacity;\n  float OpacityMask;\n  vec3 BaseColor;\n  float Metallic;\n  float Specular;\n  float Roughness;\n  float AmbientOcclusion;\n  float Anisotropy;\n  float Tangent;\n  float Refraction;\n  float PixelDepthOffset;\n  float ShadingModel;\n  float TwoSidedSign;\n  float RoughnessWithClamp;\n  vec3 DiffuseColor;\n  vec3 SpecularColor;\n  vec3 Subsurface;\n};\nstruct FMaterialPixelParameters {\n  float IndirectIrradiance;\n  vec2 TexCoords_0;\n  vec2 TexCoords_1;\n  vec4 VertexColor;\n  vec3 WorldNormal;\n  vec3 WorldTangent;\n  vec3 ReflectionVector;\n  vec3 CameraVector;\n  vec3 LightVector;\n  vec4 SvPosition;\n  vec4 ScreenPosition;\n  mat3 TangentToWorld;\n  vec3 AbsoluteWorldPosition;\n  vec3 ObjectWorldPosition;\n  vec2 LightmapUVs;\n  int PrimitiveId;\n};\nstruct FMaterialVertexParameters {\n  vec3 WorldPosition;\n  vec4 VertexColor;\n};\nuniform mat4 cc_view_taa_prev_viewProj;\n  uniform vec4 cc_view_taa_params1;\n  uniform vec4 cc_view_taa_params2;\nstruct GlobalView {\n    vec3 IndirectLightingColorScale;\n    float PreExposure;\n};\nvec3 screen2WS(vec3 screenPos) {\n  vec4 ndc = vec4(screenPos.xyz * 2. - 1.0, 1.0);\n  vec4 world = cc_matViewProjInv * ndc;\n  world = world / world.w;\n  return world.xyz;\n}\nvec2 historyPostion(sampler2D depth_buffer_map, vec2 unjittedUV, vec2 uv) {\n  float depth = texture2D(depth_buffer_map, unjittedUV).x;\n  vec3 worldPos = screen2WS(vec3(uv, depth));\n  if (abs(worldPos.x) < 0.0001 && abs(worldPos.y) < 0.0001) {\n    return uv;\n  }\n  vec4 historyNDC = cc_view_taa_prev_viewProj * vec4(worldPos, 1.);\n  historyNDC /= historyNDC.w;\n  vec2 screenPos = historyNDC.xy * 0.5 + 0.5;\n  return screenPos;\n}\nvec3 RGBToYCoCg( vec3 RGB ) {\n  float Y  = dot( RGB, vec3(  1, 2,  1 ) );\n  float Co = dot( RGB, vec3(  2, 0, -2 ) );\n  float Cg = dot( RGB, vec3( -1, 2, -1 ) );\n  return vec3( Y, Co, Cg );\n}\nvec3 YCoCgToRGB( vec3 YCoCg ) {\n  float Y  = YCoCg.x * 0.25;\n  float Co = YCoCg.y * 0.25;\n  float Cg = YCoCg.z * 0.25;\n  float R = Y + Co - Cg;\n  float G = Y + Cg;\n  float B = Y - Co - Cg;\n  return vec3( R, G, B );\n}\nvec4 sampleYCoCg(sampler2D tex, vec2 uv) {\n    vec4 color = texture2D(tex, uv);\n    color.rgb = RGBToYCoCg(color.rgb);\n    return color;\n}\nvoid minmax(sampler2D mainTex, in vec2 uv, out vec4 color_min, out vec4 color_max, out vec4 color_avg) {\n    vec2 mainTexSize = cc_nativeSize.zw;\n    vec2 du = vec2(mainTexSize.x, 0.0);\n    vec2 dv = vec2(0.0, mainTexSize.y);\n    vec4 t = sampleYCoCg(mainTex, uv - dv);\n    vec4 l = sampleYCoCg(mainTex, uv - du);\n    vec4 c = sampleYCoCg(mainTex, uv);\n    vec4 r = sampleYCoCg(mainTex, uv + du);\n    vec4 b = sampleYCoCg(mainTex, uv + dv);\n    color_min = min(t, min(l, min(c, min(r, b))));\n    color_max = max(t, max(l, max(c, max(r, b))));\n    color_avg = (t + l + c + r + b) / 5.0;\n}\nfloat HdrWeightY(float Color, float Exposure) {\n  return 1. / (Color * Exposure + 4.0);\n}\nvec2 WeightedLerpFactors(float WeightA, float WeightB, float Blend) {\n  float BlendA = (1.0 - Blend) * WeightA;\n  float BlendB = Blend * WeightB;\n  float RcpBlend = 1. / (BlendA + BlendB);\n  BlendA *= RcpBlend;\n  BlendB *= RcpBlend;\n  return vec2(BlendA, BlendB);\n}\nvec4 temporalAAPS (sampler2D taa_prev_tex, sampler2D mainTex, sampler2D depth_buffer_map, vec2 uv) {\n    vec2 unjittedUV = uv - cc_view_taa_params1.xy / 2.;\n    vec2 previousUV = historyPostion(depth_buffer_map, unjittedUV, uv);\n    vec4 prevColor = texture2D(taa_prev_tex, previousUV);\n    prevColor.rgb = RGBToYCoCg(prevColor.rgb);\n    vec4 color = texture2D(mainTex, unjittedUV);\n    color.rgb = RGBToYCoCg(color.rgb);\n    vec4 color_min, color_max, color_avg;\n    minmax(mainTex, unjittedUV, color_min, color_max, color_avg);\n    vec3 resultColor;\n    {\n        prevColor.rgb = clamp(prevColor.rgb, color_min.rgb, color_max.rgb);\n        float blendFinal = 1. - cc_view_taa_params2.y;\n        float currentWeight = HdrWeightY(color.x, 1.);\n        float historyWeight = HdrWeightY(prevColor.x, 1.);\n        vec2 weights = WeightedLerpFactors(historyWeight, currentWeight, blendFinal);\n        resultColor = prevColor.rgb * weights.x + color.rgb * weights.y;\n    }\n    {\n    }\n    resultColor = YCoCgToRGB(resultColor);\n    return vec4(resultColor, color.a);\n}\n  varying vec2 v_uv;\n  uniform sampler2D lighting_resultMap;\n  uniform sampler2D depth_buffer_map;\n  uniform sampler2D taa_prev_tex;\n  void main () {\n    #if CC_ANTI_ALIASING_TEMPORALAA\n      gl_FragColor = temporalAAPS(taa_prev_tex, lighting_resultMap, depth_buffer_map, v_uv);\n    #else\n      gl_FragColor = texture2D(lighting_resultMap, v_uv);\n    #endif\n  }"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]},{"name":"CCCamera","defines":[]},{"name":"CCCustomView","defines":[]}],"samplerTextures":[],"buffers":[],"images":[]},"locals":{"blocks":[{"name":"CCMorph","defines":["CC_USE_MORPH"]},{"name":"CCSkinningTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinningAnimation","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinning","defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION"]}],"samplerTextures":[{"name":"cc_PositionDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_POSITION"]},{"name":"cc_NormalDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_NORMAL"]},{"name":"cc_TangentDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_TANGENT"]},{"name":"cc_jointTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]}],"buffers":[],"images":[]},"statistics":{"CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS":147,"CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS":82}},"defines":[{"name":"CC_USE_MORPH","type":"boolean","defines":[]},{"name":"CC_MORPH_TARGET_COUNT","type":"number","defines":["CC_USE_MORPH"],"range":[2,8]},{"name":"CC_MORPH_PRECOMPUTED","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_POSITION","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_NORMAL","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_TANGENT","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_USE_SKINNING","type":"boolean","defines":[]},{"name":"CC_USE_BAKED_ANIMATION","type":"boolean","defines":["CC_USE_SKINNING"]},{"name":"USE_INSTANCING","type":"boolean","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CC_ANTI_ALIASING_TEMPORALAA","type":"boolean","defines":[]}]}],[{"passes":[{"phase":"post-process","program":"../resources/Exported/__builtin__/custom-deferred-taa|vs|fs","rasterizerState":{"cullMode":0},"depthStencilState":{"depthTest":false}}]}]]],0,0,[],[],[]]
